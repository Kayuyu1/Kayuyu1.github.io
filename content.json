{"meta":{"title":"湖底幽魂","subtitle":"","description":"","author":"kuangyu","url":"http://Kayuyu1.github.io","root":"/"},"pages":[{"title":"tags","date":"2020-04-27T13:20:42.000Z","updated":"2020-04-27T13:38:56.044Z","comments":true,"path":"tags/index.html","permalink":"http://kayuyu1.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JUC探索下","slug":"JUC探索下","date":"2020-06-01T07:20:22.000Z","updated":"2020-06-01T14:01:02.984Z","comments":true,"path":"2020/06/01/JUC探索下/","link":"","permalink":"http://kayuyu1.github.io/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/","excerpt":"1、函数式接口 什么是函数式接口？ 函数式接口是指只有一个抽象方法的接口。 使用函数式接口的好处？ 使用函数式接口，能让我们脱离面向对象的条条框框，只注重参数和方法体的编写。","text":"1、函数式接口 什么是函数式接口？ 函数式接口是指只有一个抽象方法的接口。 使用函数式接口的好处？ 使用函数式接口，能让我们脱离面向对象的条条框框，只注重参数和方法体的编写。 2、流式编程流式思想类似于工厂车间的“生产流水线”。我们将原本分开的操作组合成一组“模型“统一执行。 当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结 果。 之前学习过流，这里就做两个小demo复习 要求：留下所有姓张的人，选择第二和第三个元素，并将姓张的替换成姓刘。 1234567891011public class StreamDemo &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;(); Collections.addAll(strings,\"张无忌\",\"张三丰\",\"张翠山\",\"赵敏\",\"周芷若\"); strings.stream().filter(s -&gt; s.startsWith(\"张\")) .skip(1) .map(s -&gt; s.replace('张','刘')) .forEach(s -&gt; System.out.println(s)); &#125;&#125; 要求：找到姓名里有”三“的人,并将其转换为老师，根据年龄从小到大输出前两个对象： 1234567891011121314151617public class StreamDemo02 &#123; public static void main(String[] args) &#123; Student student1 = new Student(\"张三\",15); Student student2 = new Student(\"李三\",16); Student student3 = new Student(\"王2\",13); ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;(); Collections.addAll(students,student1,student2,student3); students.stream().filter(student -&gt; student.getName().contains(\"三\")) .limit(2) .map(student -&gt; new Teacher(student.getName(),student.getAge())) .sorted((s1,s2)-&gt;s1.getAge()-s2.getAge()) .forEach(teacher -&gt; System.out.println(teacher)); &#125;&#125; 3、ForkJoin3.1、什么是ForkJoin在古代，皇帝要想办成一件事肯定不会自己亲自去动手，而是把任务细分发给下面的大臣，下面的大臣也懒呀，于是把任务继续分成几个部分，继续下发，于是到了最后最终负责的人就完成了一个小功能。上面的领导再把这些结果一层一层汇总，最终返回给皇帝。这就是分而治之的思想，也是就是ForkJoin。 ForkJoin中最重要的特性是工作窃取。比如，大家都是很勤快的人，有的人工作不熟悉，完成的慢；有的人是老鸟，完成的快，完成的快的人不会闲着没事做，他会从未完成任务的人手里拿任务继续工作。这就是工作窃取。 3.2、ForkJoin如何使用 继承RecursiveTask或者RecursiveAction实现compute()； 创建ForkJoinPool； 用ForkJoinPool执行实现类； 使用ForkJoin，流计算，普通代码执行求和效率对比 实现类： 123456789101112131415161718192021222324252627282930public class ForkJoinDemo extends RecursiveTask&lt;Long&gt; &#123; private Long start; private Long end; private Long temp=10000L; public ForkJoinDemo(Long start, Long end) &#123; this.start = start; this.end = end; &#125; @Override protected Long compute() &#123; if ((end-start)&gt;temp) &#123; Long sum=0L; for (Long i=start;i&lt;end;i++) &#123; sum+=sum; &#125; return sum; &#125;else &#123; Long middle=(end-start)/2; ForkJoinDemo forkJoinDemo1 = new ForkJoinDemo(start, middle); forkJoinDemo1.fork(); ForkJoinDemo forkJoinDemo2 = new ForkJoinDemo(middle, start); forkJoinDemo2.fork(); return forkJoinDemo1.join()+forkJoinDemo2.join(); &#125; &#125;&#125; 测试类： 1234567891011121314151617181920212223242526272829303132333435363738394041public class ForkJoinTest &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; test1(); test2(); test3(); &#125; private static void test3() &#123; Long start=System.currentTimeMillis(); //rangeClosed是(] //range是() long sum = LongStream.rangeClosed(0L, 1000000000L).parallel().reduce(0,Long::sum); Long end=System.currentTimeMillis(); System.out.println(\"执行时间\"+(end-start)+\"结果\"+sum); &#125; private static void test1() &#123; Long start=System.currentTimeMillis(); Long sum=0L; for (Long i=0L;i&lt;1000000000L;i++) &#123; sum+=i; &#125; Long end=System.currentTimeMillis(); System.out.println(\"执行时间\"+(end-start)+\"结果\"+sum); &#125; private static void test2() throws ExecutionException, InterruptedException &#123; Long start=System.currentTimeMillis(); ForkJoinDemo forkJoinDemo = new ForkJoinDemo(0L,1000000000L); ForkJoinPool forkJoinPool = new ForkJoinPool(); ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(forkJoinDemo); //获取执行结果 Long sum = submit.get(); Long end=System.currentTimeMillis(); System.out.println(\"执行时间\"+(end-start)+\"结果\"+sum); &#125;&#125; 哇哇哇！！！！，震惊流计算居然如此之快！ 补充：类型::方法名 中的::在Java 8中被用作方法引用，方法引用是与lambda表达式相关的一个重要特性。它提供了一种不执行方法的方法。这种[方法引用]或者说[双冒号运算]对应的参数类型是Function&lt;T,R&gt; T表示传入类型，R表示返回类型。比如表达式person -&gt; person.getAge(); 传入参数是person，返回值是person.getAge()，那么方法引用Person::getAge就对应着Function&lt;Person,Integer&gt;类型。————————————————版权声明：本文为CSDN博主「lumence」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/lsmsrc/article/details/41747159","categories":[],"tags":[{"name":"JUC","slug":"JUC","permalink":"http://kayuyu1.github.io/tags/JUC/"}]},{"title":"mysql的事务隔离级别","slug":"mysql的事务隔离级别","date":"2020-05-31T08:32:15.000Z","updated":"2020-05-31T08:36:33.362Z","comments":true,"path":"2020/05/31/mysql的事务隔离级别/","link":"","permalink":"http://kayuyu1.github.io/2020/05/31/mysql%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/","excerpt":"","text":"1、首先了解什么是事务以及它的特性https://www.cnblogs.com/Kevin-ZhangCG/p/9038371.html 2、了解脏读，幻读，不可重复读https://www.jianshu.com/p/0cef4c68b8f3 3、事务隔离级别https://www.cnblogs.com/yuxiang1/p/11989667.html https://www.cnblogs.com/QX-Tang/p/11516567.html","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://kayuyu1.github.io/tags/mysql/"}]},{"title":"内存溢出和内存泄露的区别","slug":"内存溢出和内存泄露的区别","date":"2020-05-30T08:57:52.000Z","updated":"2020-05-30T09:00:24.269Z","comments":true,"path":"2020/05/30/内存溢出和内存泄露的区别/","link":"","permalink":"http://kayuyu1.github.io/2020/05/30/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"内存溢出 out of memory是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请 了一个integer,但给它存了long才能存下的数，那就是内存溢出。 内存泄露 memory leak是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。memory leak会最终会导致out of memory！ 内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。","text":"内存溢出 out of memory是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请 了一个integer,但给它存了long才能存下的数，那就是内存溢出。 内存泄露 memory leak是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。memory leak会最终会导致out of memory！ 内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://kayuyu1.github.io/tags/JVM/"}]},{"title":"java中堆和栈的区别","slug":"java中堆和栈的区别","date":"2020-05-30T08:45:50.000Z","updated":"2020-05-30T08:48:52.541Z","comments":true,"path":"2020/05/30/java中堆和栈的区别/","link":"","permalink":"http://kayuyu1.github.io/2020/05/30/java%E4%B8%AD%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"区别java中堆和栈的区别自然是面试中的常见问题，下面几点就是其具体的区别","text":"区别java中堆和栈的区别自然是面试中的常见问题，下面几点就是其具体的区别 各司其职最主要的区别就是栈内存用来存储局部变量和方法调用。而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。 独有还是共享栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。 异常错误如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。而如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。 空间大小栈的内存要远远小于堆内存","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://kayuyu1.github.io/tags/JVM/"}]},{"title":"JUC探索上","slug":"JUC探索上","date":"2020-05-26T01:55:41.000Z","updated":"2020-06-01T07:18:00.729Z","comments":true,"path":"2020/05/26/JUC探索上/","link":"","permalink":"http://kayuyu1.github.io/2020/05/26/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8A/","excerpt":"1、什么是JUCJUC是java.util.concurrent的缩写，它提供了一些在高并发情况下可使用的线程安全的类。","text":"1、什么是JUCJUC是java.util.concurrent的缩写，它提供了一些在高并发情况下可使用的线程安全的类。 2、传统的synchronized与Lock锁的区别synchronized基本使用： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.ky.juc;/** * @program: workspace_idea * @description: * @author: Mr.Kuang * @create: 2020-05-26 14:00 **/public class JucDemo01 &#123; public static void main(String[] args) &#123; Tick tick = new Tick(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 50; i++) &#123; tick.sale(); &#125; &#125;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 50; i++) &#123; tick.sale(); &#125; &#125;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 50; i++) &#123; tick.sale(); &#125; &#125;).start(); &#125; static class Tick &#123; //票数 private int num = 50; public synchronized void sale() &#123; if (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + \"买票第\" + num); &#125; &#125; &#125;&#125; Lock锁基本使用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.ky.juc;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @program: workspace_idea * @description: * @author: Mr.Kuang * @create: 2020-05-26 14:00 **/public class JucDemo02 &#123; public static void main(String[] args) &#123; Tick tick = new Tick(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 50; i++) &#123; tick.sale(); &#125; &#125;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 50; i++) &#123; tick.sale(); &#125; &#125;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 50; i++) &#123; tick.sale(); &#125; &#125;).start(); &#125; static class Tick &#123; //票数 private int num = 50; public void sale() &#123; Lock lock = new ReentrantLock(); lock.lock(); try &#123; if (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + \"买票第\" + num); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;&#125; 传统的synchronized与Lock锁的区别： synchronized是关键字；Lock是接口 synchronized有代码锁、方法锁；Lock只用代码锁 synchronized是非公平锁；Lock可以自己设置非公平/公平锁 非公平锁：是可以插队的一种锁机制，比如一个线程3s执行完，但它排在要3h执行完的线程后面，就可以先执行。（效率高） 公平锁：就是老老实实排队。（效率低） synchronized会自动释放锁；Lock必须手动释放，不然会死锁 synchronized适合少量的同步代码；Lock适合大量的同步代码 synchronized操作比较固定；Lock相对灵活 补充：请简述wait()与sleep()的区别 1.wait()的根类是Object()，sleep()的的根类是Thread 2.wait()会释放锁，sleep()会抱着锁睡觉 3.wait()必须在同步代码块/同步方法里面，而sleep()可以在任意位置 3、虚假唤醒问题什么是虚假唤醒？ 线程也可以唤醒，而不会被通知，中断或超时，即所谓的虚假唤醒 （这是api上的解释但说的不通俗）。 以下实在别人博客上找到的通俗解释： 当一个条件满足时，很多线程都被唤醒了，但是只有其中部分是有用的唤醒，其它的唤醒都是无用功 比如说买货，如果商架本来没有货物，突然进了一件商品，这是所有的线程都被唤醒了 ，但是只能一个人买，所以其他人都是假唤醒，获取不到对象的锁 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * @program: workspace_idea * @description: * @author: Mr.Kuang * @create: 2020-05-26 20:36 **/public class JucDemo03 &#123; public static void main(String[] args) &#123; Data data = new Data(); new Thread(()-&gt;&#123; for (int i = 0; i &lt;10; i++) &#123; data.increment(); &#125; &#125;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt;10; i++) &#123; data.increment(); &#125; &#125;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt;10 ; i++) &#123; data.decrement(); &#125; &#125;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt;10 ; i++) &#123; data.decrement(); &#125; &#125;).start(); &#125;&#125;class Data&#123; int num=0; public synchronized void increment() &#123; if (num!=0) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName()+\":\"+num); num++; //唤醒 this.notifyAll(); &#125; public synchronized void decrement() &#123; if (num==0) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName()+\":\"+num); num--; this.notifyAll(); &#125;&#125; 在上面代码中我们有两个消费者，两个生产者，但生产资料却出现了负数。这是为什么了 原因：if语句只执行一次，执行完毕后或执行外面的语句，这就导致无论你是否wait()了线程他都会执行notifyAll()唤醒线程。 解决：将if换成while，因为while直到条件满足才会向下执行while（）外边的。 4、使用JUC实现生产者与消费者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class JucDemo04 &#123; public static void main(String[] args) &#123; Data data = new Data(); new Thread(()-&gt;&#123; for (int i = 0; i &lt;5; i++) &#123; data.increment(); &#125; &#125;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt;5; i++) &#123; data.increment(); &#125; &#125;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt;5 ; i++) &#123; data.decrement(); &#125; &#125;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt;5 ; i++) &#123; data.decrement(); &#125; &#125;).start(); &#125;&#125;class Data4&#123; int num=0; Lock lock=new ReentrantLock(); Condition condition=lock.newCondition(); public void increment() &#123; lock.lock(); try &#123; while(num!=0) &#123; condition.await(); &#125; System.out.println(Thread.currentThread().getName()+\":\"+num); num++; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void decrement() &#123; lock.lock(); try &#123; while(num==0) &#123; condition.signalAll(); &#125; System.out.println(Thread.currentThread().getName()+\":\"+num); num--; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 通过对比我们发现： lock.lock();lock.unlock();代替了synchronized, condition.await();代替了wait(),condition.signalAll();代替notifyAll()Lock替换synchronized方法和语句的使用， Condition取代了对象监视器方法的使用。 Condition的优势：传统的线程通知是随机的，Condition可以精准通知线程。 4.1、实验：使用多线程循环打印ABC123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.ky.juc;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @program: workspace_idea * @description:通过不同的监视器解决指定唤醒 * @author: Mr.Kuang * @create: 2020-05-27 11:40 **/public class JucDemo05 &#123; public static void main(String[] args) &#123; Data5 data5 = new Data5(); new Thread(() -&gt; &#123; while (true) &#123; data5.printA(); &#125; &#125;, \"A\").start(); new Thread(() -&gt; &#123; while (true) &#123; data5.printB(); &#125; &#125;, \"B\").start(); new Thread(() -&gt; &#123; while (true) &#123; data5.printC(); &#125; &#125;, \"C\").start(); &#125;&#125;//资源类class Data5 &#123; private Lock lock = new ReentrantLock(); private Condition condition1 = lock.newCondition(); private Condition condition2 = lock.newCondition(); private Condition condition3 = lock.newCondition(); private int num=1; public void printA() &#123; //上锁 lock.lock(); try &#123; //判断-&gt;业务-&gt;通知 while (num != 1) &#123; condition1.await(); &#125; System.out.println(Thread.currentThread().getName()); num = 2; condition2.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //释放锁 lock.unlock(); &#125; &#125; public void printB() &#123; //上锁 lock.lock(); try &#123; while (num != 2) &#123; condition2.await(); &#125; System.out.println(Thread.currentThread().getName()); num = 3; condition3.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //释放锁 lock.unlock(); &#125; &#125; public void printC() &#123; //上锁 lock.lock(); try &#123; while (num != 3) &#123; condition3.await(); &#125; System.out.println(Thread.currentThread().getName()); num = 1; condition1.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //释放锁 lock.unlock(); &#125; &#125;&#125; 图解流程： 5、锁现象测试测试模板： 1234567891011121314151617181920212223242526272829303132333435/** * @program: workspace_idea * @description:模板 * @author: Mr.Kuang * @create: 2020-05-27 15:29 **/public class Test &#123; public static void main(String[] args) &#123; Phone phone1 = new Phone(); //发短信 new Thread(()-&gt;&#123; phone1.sendmsg(); &#125;).start(); //休息一秒保证打电话先拿到锁 try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //打电话 new Thread(()-&gt;&#123; phone1.call(); &#125;).start(); &#125;&#125;class Phone&#123; public synchronized void sendmsg() &#123; System.out.println(\"发短信\"); &#125; public synchronized void call() &#123; System.out.println(\"打电话\"); &#125;&#125; 5.1、测试问题一：如果在执行sendmsg()方法的时候休眠4秒，那么发短信和打电话谁先执行 修改sendmsg()代码为： 123456789public synchronized void sendmsg() &#123; try &#123; TimeUnit.SECONDS.sleep(4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"发短信\"); &#125; 结果：4秒后发短信先执行 原因：因为非静态的synchronized方法，锁的是调用的对象，又因为两个线程共用对象phone1，而且两个线程在main方法中启动的先后不同时，所以在第一个线程抢到锁，就必须等它执行完sendmsg()释放锁后，下一个线程才能拿到锁执行，无论同步代码块中是否有休眠。 问题二：如果将call()方法上的关键字去掉结果如何？ 修改call(): 1234public void call() &#123; System.out.println(\"打电话\"); &#125; 结果：打电话先打印，4秒后发短信打印 原因：没有了sychronized也就没有了锁，不存在抢占，又因为phone1.sendmsg()会休眠4秒，所以打电话先打印。 问题三：如果再加入一个phone2对象，第一个线程执行 phone1.sendmsg();第二个线程执行 phone2.call()。请问发短信和打电话谁先打印？ 添加phone2对象： 1Phone phone2 = new Phone(); 结果：打电话先打印，4秒后发短信打印 原因：锁的对象不同，phone1.sendmsg()与phone2.call()无关，并不会出现抢锁现象，又因为phone1.sendmsg()会休眠4秒，所以打电话先打印。 问题四：在问题三的基础上将所有的sychronized方法改为静态的，又如何。 修改代码： 12345678910111213public static synchronized void sendmsg() &#123; try &#123; TimeUnit.SECONDS.sleep(4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"发短信\"); &#125; public static synchronized void call() &#123; System.out.println(\"打电话\"); &#125; 结果：4秒后发短信先执行 原因：被static修饰的关键字从属于类，因为无论有多少个实例对象，类模板都只有一个，所以第一个线程和第二个线程的锁是相同的,所以在第一个线程抢到锁，就必须等它执行完sendmsg()释放锁后，下一个线程才能拿到锁执行 6、List，Set集合类不安全12345678910111213public class JucDemo06 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;30 ; i++) &#123; new Thread(()-&gt;&#123; strings.add(UUID.randomUUID().toString().substring(0,3)); strings.forEach(s -&gt; System.out.print(s)); System.out.println(\" \"); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; 在多线程的情况下会报并发修改异常java.util.ConcurrentModificationException 解决方案： List strings = new Vector&lt;&gt;(); List strings = Collections.synchronizedList(new ArrayList&lt;&gt;()); List strings = new CopyOnWriteArrayList&lt;&gt;(); 写时复制思想： CopyOnWrite简称COW，写入时复制（CopyOnWrite，简称COW）思想是计算机程序设计领域中的一种优化策略，它的核心思想是当修改资源的时候调用者修改的是副本，其他调用者看到的仍然是原始数据。 CopyOnWriteXXX的add()方法源码分析： CopyOnWriteArrayList的add方法： 1234567891011121314public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 它在进行元素添加的时候，会先将原数组复制并长度加一Object[] newElements = Arrays.copyOf(elements, len + 1);再将待添加的元素加入新数组中，最后setArray(newElements)将原容器的引用指向新容器。这样做的好处是避免了写入时覆盖。 2.使用了lock锁，保证了多线程添加下的线程安全。 使用场景: 在读多，写少的情况下适用。比如白名单，黑名单等场景。 CopyOnWriteXXX的优点 读写分离 线程安全 CopyOnWriteXXX的两个缺点 因为采用了写时复制，所以CopyOnWriteXXX在添加的时候会多一次复制操作，这增加系统资源的消耗。 CopyOnWriteXXX只能保证最终数据的一致性，不能保证实时数据一致性。 补充回顾： HashSet的底层是HashMap 123public HashSet() &#123; map = new HashMap&lt;&gt;();&#125; HashSet的add()方法本质是用的HashMap的put()方法 1private static final Object PRESENT = new Object();//静态不变类 123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 7、Map集合类不安全123456789101112public class JucDemo06 &#123; public static void main(String[] args) &#123; Map&lt;String,String&gt; hashMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt;30 ; i++) &#123; Integer num=i; new Thread(()-&gt;&#123; hashMap.put(Thread.currentThread().getName(),String.valueOf(num)); System.out.println(hashMap); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; 在多线程的情况下会报并发修改异常java.util.ConcurrentModificationException 解决方案： Map&lt;String,String&gt; hashMap = new Hashtable&lt;&gt;(); Map&lt;String,String&gt; hashMap = Collections.synchronizedMap(new Hashtable&lt;&gt;()); Map&lt;String,String&gt; hashMap = new ConcurrentHashMap&lt;&gt;(); 回顾hashmap，探究currenthashmap： https://www.bilibili.com/video/BV1oE411n7ug?from=search&amp;seid=6027548520959686442 https://www.bilibili.com/video/BV1N4411d7pm?from=search&amp;seid=6027548520959686442 https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/ 8、CountDownLatch1234567891011121314151617181920public class JucDemo07 &#123; public static void main(String[] args) &#123; CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 0; i &lt;6 ; i++) &#123; new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\"Go\"); countDownLatch.countDown(); &#125; ).start(); &#125; try &#123; countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"关门\"); &#125;&#125; CountDownLatch相当于一个守门人，countDownLatch.countDown();每当有一个人出门就-1， countDownLatch.await();规定当人走完即减为0后，才执行下面的语句。 9、CyclicBarrier12345678910111213141516171819public class JucDemo08 &#123; public static void main(String[] args) &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; System.out.println(\"召唤神龙\")); for (int i = 0; i &lt;7 ; i++) &#123; final int temp=i; new Thread(()-&gt; &#123; System.out.println(Thread.currentThread().getName()+\"第\"+temp+\"颗\"); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; System.out.println(&quot;召唤神龙&quot;));设定了线程执行的个数，以及所以线程执行完后的结果。 注意 :cyclicBarrier.await();在线程内，而countDownLatch.await();在线程外。 CountDownLatch与CyclicBarrier的区别 CountDownLatch CyclicBarrier 减数方式 加数方式 计算为0时释放所有等待的线程 计数达到指定值时释放所有等待线程 计数为0时，无法重置 计数达到指定值时，计数置为0重新开始 调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响 调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞 CountDownLatch的下一步的动作实施者是调用者 CyclicBarrier的下一步动作实施者还是“其他线程”本身 不可重复利用 可重复利用 10、Semaphore123456789101112131415161718192021public class JucDemo09 &#123; public static void main(String[] args) &#123; //3个停车场 Semaphore semaphore = new Semaphore(3); //6俩车 for (int i = 0; i &lt;6 ; i++) &#123; new Thread(()-&gt;&#123; try &#123; semaphore.acquire();//得到停车位 System.out.println(Thread.currentThread().getName()+\"进入\"); TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; semaphore.release();//释放停车位 System.out.println(Thread.currentThread().getName()+\"离开\"); &#125;).start(); &#125; &#125;&#125; Semaphore semaphore = new Semaphore(3);定义最大线程执行个数 semaphore.acquire();得到信号量 semaphore.release();释放信号量 作用：并发限流。 11、读写锁，ReadWriteLock要求：写的时候只能一个写入，读的时候可以多个人读取 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class JucDemo10 &#123; public static void main(String[] args) &#123; MyCache myCache = new MyCache(); for (int i = 0; i &lt;10 ; i++) &#123; String temp=String.valueOf(i); new Thread(()-&gt;&#123; myCache.writer(temp,temp+\"k\"); &#125;).start(); &#125; for (int i = 0; i &lt;10 ; i++) &#123; String temp=String.valueOf(i); new Thread(()-&gt;&#123; myCache.read(temp); &#125;).start(); &#125; &#125;&#125;class MyCache&#123; private Map&lt;String, String&gt; map=new HashMap&lt;&gt;(); private ReadWriteLock readWriteLock=new ReentrantReadWriteLock(); public void writer(String key,String value) &#123; readWriteLock.writeLock().lock(); try &#123; System.out.println(Thread.currentThread().getName()+\"正在写入\"); map.put(key,value); System.out.println(Thread.currentThread().getName()+\"写完\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; readWriteLock.writeLock().unlock(); &#125; &#125; public void read(String key) &#123; readWriteLock.readLock().lock(); try &#123; System.out.println(Thread.currentThread().getName()+\"正在读取\"); String value = map.get(key); System.out.println(Thread.currentThread().getName()+\"读取完毕\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; readWriteLock.readLock().unlock(); &#125; &#125;&#125; readWriteLock.writeLock()属于独占锁，只允许一个线程占有锁，就是要修改数据，外人连想进来读数据都不行，完全霸占数据使用权。 readWriteLock.readLock()属于共享锁，允许多个线程使用锁，且只允许读取资源，如果想修改必须等读锁释放。 注意：由于在main线程中已经实现了读写分离，所以加不加读锁结果也符合。那为什么读取写不分离地方必须要加读锁？是因为要==避免脏读==（你读取的时候，别人正在修改，你读取的就是别人修改的数据，但如果别人因为某种原因回滚，你读取的就是无效的数据，这就是脏读） 12.线程池12.1、池化技术对象池，线程池，连接池….. 为了避免资源的消耗而出现的技术，其核心思想是减少每次获取资源的消耗，提高对资源的利用率。 12.2、线程池的好处 减少资源消耗 提高了响应速度 方便管理 ==线程复用、控制最大并发数、方便管理== 12.3、使用Executors四种创建线程池的方式 Executors.newFixedThreadPool(X) Executors.newCachedThreadPool() Executors.newSingleThreadExecutor() Executors.newScheduledThreadPool(x) 1234567891011121314151617181920212223242526272829303132public class JucDemo11 &#123; public static void main(String[] args) &#123; //创建有固定线程数量的线程池 ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5); //创建可伸缩线程池 ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); //创建只有一个线程的线程池 ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); //创建一个可定期或者延时执行任务的定长线程池，支持定时及周期性任务执行 ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(5); /* for (int i = 0; i &lt;10 ; i++) &#123; final Integer temp=i; fixedThreadPool.submit(()-&gt; System.out.println(Thread.currentThread().getName()+\"-&gt;\"+temp)); &#125;*/ /* for (int i = 0; i &lt;10 ; i++) &#123; final Integer temp=i; cachedThreadPool.submit(()-&gt; System.out.println(Thread.currentThread().getName()+\"-&gt;\"+temp)); &#125;*/ /* for (int i = 0; i &lt;10 ; i++) &#123; final Integer temp=i; singleThreadExecutor.submit(()-&gt; System.out.println(Thread.currentThread().getName()+\"-&gt;\"+temp)); &#125;*/ for (int i = 0; i &lt;10 ; i++) &#123; final Integer temp=i; scheduledExecutorService.schedule(()-&gt; System.out.println(Thread.currentThread(). getName()+\"-&gt;\"+temp),3, TimeUnit.SECONDS); &#125; &#125;&#125; 在阿里巴巴开发手册中不建议使用Executors,原因如下： 12.4、七大参数 查看创建线程池的源码 123456789101112131415161718192021public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125;public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125;public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize); &#125; 通过源码观察，我们发现线程池创建的四个方法中有三与ThreadPoolExecutor有直接关系（ScheduledThreadPoolExecutor其实继承了ThreadPoolExecutor），所以它们本质都是ThreadPoolExecutor。 查看ThreadPoolExecutor 123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; int corePoolSize：基本线程个数 int maximumPoolSize：最大线程个数 long keepAliveTime：超时等待时间 TimeUnit unit：等待时间单位 BlockingQueue workQueue,：阻塞队列 ThreadFactory threadFactory：创造线程的工厂 RejectedExecutionHandler handler：拒绝策略 通过模拟银行业务来理解： 当人不多的时候，只开启两个窗口（corePoolSize），其他人在接待处等着（workQueue） 当人多，接待处满了，就会开启其他窗口。 当人很多的时候，窗口也满了，接待区也满了，进来的人要么站在等，要么就不进来，这就是拒绝策略生效。 窗口相当于我们要开启的线程、窗口初始数量相当于corePoolSize、窗口最大数量相当于maximumPoolSize、接待处相当于workQueue 人爆满后的的执行策略就相当于 handler。 12.5、四种拒绝策略 最大承载数=队列容量+最大线程数 AbortPolicy():当线程池到达最大承载数，如果还有线程要求就会抛出异常java.util.concurrent.RejectedExecutionException。 1234567891011121314151617public class JucDemo12 &#123; public static void main(String[] args) &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 3, 5, 3, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); //最大承载数=Queue.size+maximumPoolSize for (int i = 0; i &lt; 9; i++) &#123; final int temp=i; threadPoolExecutor.execute(()-&gt; System.out.println(Thread.currentThread().getName()+\"-&gt;\"+temp)) &#125; &#125; 以上代码的最大承载数为8，我们选择执行9和线程 CallerRunsPolicy():当线程池到达最大承载数，如果还有线程要求就会将任务返还给调用者线程执行,俗称从哪来回哪去。 1new ThreadPoolExecutor.CallerRunsPolicy() DiscardPolicy():当线程池到达最大承载数，如果还有线程要求就不执行。 1new ThreadPoolExecutor.DiscardPolicy() DiscardOldestPolicy():尝试与第一个线程争抢，争抢到就执行，争抢不到就不执行 总结： 这四种策略是独立无关的，是对任务拒绝处理的四中表现形式。最简单的方式就是直接丢弃任务。但是却有两种方式，到底是该丢弃哪一个任务，比如可以丢弃当前将要加入队列的任务本身（DiscardPolicy）或者丢弃任务队列中最旧任务（DiscardOldestPolicy）。丢弃最旧任务也不是简单的丢弃最旧的任务，而是有一些额外的处理。除了丢弃任务还可以直接抛出一个异常（RejectedExecutionException），这是比较简单的方式。抛出异常的方式（AbortPolicy）尽管实现方式比较简单，但是由于抛出一个RuntimeException，因此会中断调用者的处理过程。除了抛出异常以外还可以不进入线程池执行，在这种方式（CallerRunsPolicy）中任务将有调用者线程去执行。 补充：到底如何定义多大的线程数量才合理 如果是IO密集型应用，则线程池大小设置为2N+1； 如果是CPU密集型应用，则线程池大小设置为N+1； N代表CPU的核数","categories":[],"tags":[{"name":"JUC","slug":"JUC","permalink":"http://kayuyu1.github.io/tags/JUC/"}]},{"title":"hashmap普通分析","slug":"hashmap源码分析","date":"2020-05-24T01:08:31.000Z","updated":"2020-05-26T01:50:20.456Z","comments":true,"path":"2020/05/24/hashmap源码分析/","link":"","permalink":"http://kayuyu1.github.io/2020/05/24/hashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"HashMap是面试的重点，要是一个HashMap能讲一个小时，估计就稳了哦（听某大佬说的） 1.提问 HashMap的初始化容量为多少? HashMap的初始化容量又为什么是2的幂次方？ HashMap的负载因子为什么为0.75？ JDK1.7中的HashMap有什么安全隐患？ JDK1.8中的HashMap与JDK1.7中的HashMap有啥不同？","text":"HashMap是面试的重点，要是一个HashMap能讲一个小时，估计就稳了哦（听某大佬说的） 1.提问 HashMap的初始化容量为多少? HashMap的初始化容量又为什么是2的幂次方？ HashMap的负载因子为什么为0.75？ JDK1.7中的HashMap有什么安全隐患？ JDK1.8中的HashMap与JDK1.7中的HashMap有啥不同？ HashMap的初始化容量？查看源码得知初始值为16，且MUST be a power of two. 必须是2的幂次方 1234/** * The default initial capacity - MUST be a power of two. */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 HashMap的初始化容量又为什么必须是2的幂次方？首先我们要知道HashMap是通过对键对象的hash值来计算要放的位置的索引的。上源码 因为n永远是2的次幂，所以n的二进制表达式就为100000或者1000，而n-1的二进制表达式就为11111或者111 重点来了(n - 1) &amp; hash]我们设置n为16，它的二进制是10000，接下来于不同的hash值做与运算 上面四种情况我们可以看出，不同的hash值，和(n-1)进行位运算后，能够得出不同的值，使得添加的元素能够均匀分布在集合中不同的位置上，避免hash碰撞。 下面就来看一下HashMap的容量不是2的n次幂的情况，当容量为10时，二进制为01010，(n-1)的二进制是01001，向里面添加同样的元素，结果为： 可以看出，有三个不同的元素进过&amp;运算得出了同样的结果，严重的hash碰撞了。 https://blog.csdn.net/apeopl/article/details/88935422 总结:HashMap的初始化容量必须是2的幂次方是为了使元素在hashmap上均匀分布，尽量避免hash碰撞 HashMap的负载因子为什么为0.75？首先我们要明白负载因子如何影响HashMap 负载因子高的话，链表会增多，数组的长度会变小（空间变小），又因为链表是一个查询慢的数据结构，多了自然会影响整个hash表的查找性能。小则反之。 所以负载因子如果高的话，减少了空间的浪费但是增加了查找的消耗。如果负载因子小的话增加了空间的浪费但是减少了查找的消耗。 总结：提高空间利用率和减少查询成本的折中，通过泊松分布分布分析，0.75的话hash碰撞最小， JDK1.7中的HashMap有什么安全隐患？ 可能会形成循环链表，从而引发死锁 可以通过精心构造的恶意请求引发dos攻击（就是通过大量的hash值相同的值，将hash表退化为链表，这样服务器查询性能会大大降低） JDK1.8中的HashMap与JDK1.7中的HashMap有啥不同？ JDK1.8中的HashMap JDK1.7中的HashMap 数组+链表/红黑书 数组+链表 插入元素链表尾插 插入元素链表头插 节点是Node 节点是Entry hash算法相对简化 hash算法相对复杂","categories":[],"tags":[{"name":"javaee","slug":"javaee","permalink":"http://kayuyu1.github.io/tags/javaee/"}]},{"title":"常见的4种线程池","slug":"常见的4种线程池","date":"2020-05-23T08:46:00.000Z","updated":"2020-05-23T08:50:49.497Z","comments":true,"path":"2020/05/23/常见的4种线程池/","link":"","permalink":"http://kayuyu1.github.io/2020/05/23/%E5%B8%B8%E8%A7%81%E7%9A%844%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"1、newFixedThreadPool 定长线程池一个有指定的线程数的线程池，有核心的线程，里面有固定的线程数量，响应的速度快。正规的并发线程，多用于服务器。固定的线程数由系统资源设置。核心线程是没有超时机制的，队列大小没有限制，除非线程池关闭了核心线程才会被回收。","text":"1、newFixedThreadPool 定长线程池一个有指定的线程数的线程池，有核心的线程，里面有固定的线程数量，响应的速度快。正规的并发线程，多用于服务器。固定的线程数由系统资源设置。核心线程是没有超时机制的，队列大小没有限制，除非线程池关闭了核心线程才会被回收。 2、newCachedThreadPool 可缓冲线程池只有非核心线程，最大线程数很大，每新来一个任务，当没有空余线程的时候就会重新创建一个线程，这边有一个超时机制，当空闲的线程超过60s内没有用到的话，就会被回收，它可以一定程序减少频繁创建/销毁线程,减少系统开销，适用于执行时间短并且数量多的任务场景。 3、ScheduledThreadPool 周期线程池创建一个定长线程池，支持定时及周期性任务执行，通过过schedule方法可以设置任务的周期执行 4、newSingleThreadExecutor 单任务线程池创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行，每次任务到来后都会进入阻塞队列，然后按指定顺序执行。 作者：维特无忧堡链接：https://www.jianshu.com/p/6eb9217a2af9来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"javase","slug":"javase","permalink":"http://kayuyu1.github.io/tags/javase/"}]},{"title":"什么是RPC","slug":"什么是RPC","date":"2020-05-22T04:04:15.000Z","updated":"2020-05-22T04:09:29.805Z","comments":true,"path":"2020/05/22/什么是RPC/","link":"","permalink":"http://kayuyu1.github.io/2020/05/22/%E4%BB%80%E4%B9%88%E6%98%AFRPC/","excerpt":"借用别人的文章《如何给老婆解释RPC》 文章后续看的不是明白，但这个故事，我笑着笑着就哭了！ 一个阳光明媚的早晨，老婆又在翻看我订阅的技术杂志。 “老公，什么是RPC呀，为什么你们程序员那么多黑话！”，老婆还是一如既往的好奇。","text":"借用别人的文章《如何给老婆解释RPC》 文章后续看的不是明白，但这个故事，我笑着笑着就哭了！ 一个阳光明媚的早晨，老婆又在翻看我订阅的技术杂志。 “老公，什么是RPC呀，为什么你们程序员那么多黑话！”，老婆还是一如既往的好奇。 “RPC，就是Remote Procedure Call的简称呀，翻译成中文就是远程过程调用嘛”，我一边看着书，一边漫不经心的回答着。“啥？你在说啥？谁不知道翻译成中文是什么意思？你个废柴，快给我滚去洗碗！”“我去。。。”，我如梦初醒，我对面坐着的可不是一个程序员，为了不去洗碗，我瞬间调动起全部脑细胞，星辰大海在我脑中汇聚，灵感涌现…… “是这样，远程过程调用，自然是相对于本地过程调用来说的嘛。”“嗯哼，那先给老娘讲讲，本地过程调用是啥子？”“本地过程调用，就好比你现在在家里，你要想洗碗，那你直接把碗放进洗碗机，打开洗碗机开关就可以洗了。这就叫本地过程调用。” “哎呦，我可不干，那啥是远程过程调用？”“远程嘛，那就是你现在不在家，跟姐妹们浪去了，突然发现碗还没洗，打了个电话过来，叫我去洗碗，这就是远程过程调用啦”，多么通俗易懂的解释，我真是天才！ “哦！我明白了”，说着，老婆开始收拾包包。“你这是干啥去哦”“我？我要出门浪去呀，待会记得接收我的远程调用哦，哦不，咱们要专业点，应该说，待会记得接收我的RPC哦！” 后续：https://zhuanlan.zhihu.com/p/36427583","categories":[],"tags":[{"name":"分布式","slug":"分布式","permalink":"http://kayuyu1.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"SpringBoot自动装配原理","slug":"SpringBoot自动装配原理","date":"2020-05-16T01:48:50.000Z","updated":"2020-05-16T01:49:17.165Z","comments":true,"path":"2020/05/16/SpringBoot自动装配原理/","link":"","permalink":"http://kayuyu1.github.io/2020/05/16/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/","excerpt":"","text":"","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://kayuyu1.github.io/tags/SpringBoot/"}]},{"title":"JVM初探","slug":"JVM初探","date":"2020-05-16T01:45:05.000Z","updated":"2020-05-26T01:51:00.793Z","comments":true,"path":"2020/05/16/JVM初探/","link":"","permalink":"http://kayuyu1.github.io/2020/05/16/JVM%E5%88%9D%E6%8E%A2/","excerpt":"面试提问 什么是OOM，什么是栈溢出StackOverFlowError？怎么分析？ JVM的常用调优参数有哪些？ 内存的快照如何抓取，怎么分析Dump文件？知道吗？ 谈谈JVM中，类加载器？","text":"面试提问 什么是OOM，什么是栈溢出StackOverFlowError？怎么分析？ JVM的常用调优参数有哪些？ 内存的快照如何抓取，怎么分析Dump文件？知道吗？ 谈谈JVM中，类加载器？ JVM探究JVM的位置 jvm是运行class文件的虚拟进程 JVM的体系结构 类加载器作用：加载Class文件生产Class模板 12345678910111213141516171819202122public class Car &#123; public static void main(String[] args) &#123; Car car1 = new Car(); Car car2 = new Car(); Car car3 = new Car(); System.out.println(car1.hashCode()); System.out.println(car2.hashCode()); System.out.println(car3.hashCode()); Class&lt;? extends Car&gt; aClass1 = car1.getClass(); Class&lt;? extends Car&gt; aClass2 = car2.getClass(); Class&lt;? extends Car&gt; aClass3 = car3.getClass(); System.out.println(aClass1.hashCode()); System.out.println(aClass2.hashCode()); System.out.println(aClass3.hashCode()); &#125;&#125; 有以上代码可知道，car1，car2，car3虽然是不同对象，但用的模板相同 java默认的三种类加载器 启动类加载器(Bootstrap classLoader):又称为引导类加载器，由C++编写，无法通过程序得到。主要负责加载JAVA中的 一些核心类库，主要是位于/lib/rt.jar中。 拓展类加载器(Extension classLoader):主要加载JAVA中的一些拓展类，位于/lib/ext中,是启动类加载器的子类。 系统类加载器(AppClassLoader)：加载当前应用的classpath的所有类 双亲委派机制什么是双亲委派机制： 当一个类向自己的类加载器发送加载请求的时候，这个类加载器会先去委托上一级类加载器加载类，依次递归，直到委托启动类加载器(Bootstrap classLoader)，如果上一级没有这个类，便会允许下一级加载，直到找能加载这个类的加载器未知。 这种机制就好比：一个普通百姓打一个大官司，当地官员觉得事情大，先请示上级，上级又觉得事情大，要先请示上级，直到请示到皇上，但是皇上说，我不管，你们看着办，就又扔给下级，下级也不管，依次递归，直到一个想管的官员出现。 双亲委派机制的作用和好处：防止重复加载同一个.class，保证核心.class不能被篡改。 Native1private native void start0(); 当方法被native修饰的时候，意味着调用本地方法（本地方法可能是c，或者其他语言写的，java程序不能直接调用）。 过程： 将方法压入本地方法栈 本地方法栈调用本地方法接口JNI JNI调用本地方法库 为什么会有这种机制： 在java刚出来的时候，流行的是C和C++，为了抢夺市场就不得不融合其他语言，扩展功能。所以就出现了这种机制。 好处：可融合其他语言，增强了java的功能扩展 趋势：现在用Native的越来越少了，除了硬件功能的调用如java程序驱动打印机还在使用，在企业级应用中都很少见了 因为现在异构领域的通信都很发达，如Socket等。 PC寄存器每个线程都有一个程序计数器，是线程私有的,就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。 方法区方法区被所有线程共享，它存放了类的字节码，静态方法，静态变量，和常量池，但是实例变量任然存在堆中，与类无关 12345678public class Student &#123; private String name=\"ky\"; public static void main(String[] args) &#123; Student student = new Student(); &#125;&#125; 123456789public static void main(String[] args) &#123; String s1=\"abc\"; String s2=new String(\"abc\"); String s3=s2.intern(); System.out.println(s1==s2);//false System.out.println(s1==s3);//true&#125; intern方法，这个方法首先在常量池中查找是否存在一份equal相等的字符串如果有的话就返回该字符串的引用，没有的话就将它加入到字符串常量池中。 栈在java中，栈主管程序的运行，一个栈对应一个线程，栈生命周期与程序的线程相同。对于栈来说，不存在垃圾回收。栈中存放了基本数据类型，和引用数据类型的引用地址，以及方法的引用 堆堆主要存放类实例化的真实对象。堆里面又分为新生代，老年代，和永久代（jdk1.8后改为元空间），垃圾回收主要发生在新生代和老年代。 新生代，老年代，永久代（元空间）新生代：一般对象的诞生的地方 老年代：对象躲过15次GC（一般默认15次，可以自己设置）之后进入的地方 永久代（元空间）：java8后用元空间替代了永久代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 GC在jvm中一般将GC分为三种类：新生代 GC（Minor GC），老年代 GC（Major GC），全局 Full GC Minor GC指新生代GC，即发生在新生代（包括Eden区和Survivor区）的垃圾回收操作，当新生代无法为新生对象分配内存空间的时候，会触发Minor GC。因为新生代中大多数对象的生命周期都很短，所以发生Minor GC的频率很高，虽然它会触发stop-the-world，但是它的回收速度很快。 Major GC清理Tenured区，用于回收老年代，出现Major GC通常会出现至少一次Minor GC。 Full GC是针对整个新生代、老生代、元空间（metaspace，java8以上版本取代perm gen）的全局范围的GC 常用算法 引用计数法 标记清除法 复制算法 标记压缩算法 https://www.bilibili.com/video/BV1iJ411d7jS?p=13具体的算法讲解在p10-p13 JMM浅谈 什么是JMM ​ JMM是Java Memory Model（java内存模型）的缩写 为什么需要它，它的作用是什么 首先我们要明白在java中只有一个主内存，线程要从主内存中复制一份当作工作内存使用。 如图所示。当其他线程中的数据改变的时候，导致了数据的不一致性 而JMM就是为了解决这个问题，它类似缓存一致性协议，是用于定义数据读写的规则 深究JVMhttps://www.bilibili.com/video/BV1PJ411n7xZ?from=search&amp;seid=7159976456518541220","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://kayuyu1.github.io/tags/JVM/"}]},{"title":"Vue组件事件绑定Vue实例事件","slug":"Vue组件事件绑定Vue实例组件","date":"2020-05-12T11:13:13.000Z","updated":"2020-05-12T14:50:18.433Z","comments":true,"path":"2020/05/12/Vue组件事件绑定Vue实例组件/","link":"","permalink":"http://kayuyu1.github.io/2020/05/12/Vue%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9AVue%E5%AE%9E%E4%BE%8B%E7%BB%84%E4%BB%B6/","excerpt":"首先，我们要知道Vue中的组件不能直接绑定Vue实例的事件，只能间接的绑定","text":"首先，我们要知道Vue中的组件不能直接绑定Vue实例的事件，只能间接的绑定 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;vue9&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;todiv&gt; &lt;totitle slot=\"totitle\" :title=\"tilte\"&gt;&lt;/totitle&gt; &lt;todata slot=\"todata\" v-for=\"(item,index) in items\" :item=\"item\" :index=\"index\" v-on:remove=\"removeItem(index)\" &gt;&lt;/todata&gt; &lt;/todiv&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; Vue.component(\"todiv\", &#123; template: '&lt;div&gt;' + '&lt;slot name=\"totitle\"&gt;&lt;/slot&gt;' + '&lt;ul&gt;' + '&lt;slot name=\"todata\"&gt;&lt;/slot&gt;' + '&lt;/ul&gt;' + '&lt;/div&gt;' &#125;); Vue.component(\"totitle\", &#123; props: ['tilte'], template: '&lt;div&gt;&#123;&#123;tilte&#125;&#125;&lt;/div&gt;' &#125;); Vue.component(\"todata\", &#123; props: ['item','index'], template: '&lt;li&gt;&#123;&#123;item&#125;&#125;&lt;button @click=\"remove\"&gt;删除&lt;/button&gt;&lt;/li&gt;', methods:&#123; remove:function () &#123; this.$emit('remove')//触发自定义事件 &#125; &#125; &#125;); var vm = new Vue(&#123; el: \"#app\", data: &#123; tilte: \"ky写java\", items: [\"java\", \"运维\", \"linux\"] &#125;, methods:&#123; removeItem:function (index) &#123; console.log(\"删除了\"+index) this.items.splice(index,1) &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 组件布局 自定义事件分发绑定","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://kayuyu1.github.io/tags/Vue/"}]},{"title":"基本类型和引用类型传参区别","slug":"基本类型和引用类型传参区别","date":"2020-05-11T13:29:26.000Z","updated":"2020-05-11T14:14:48.740Z","comments":true,"path":"2020/05/11/基本类型和引用类型传参区别/","link":"","permalink":"http://kayuyu1.github.io/2020/05/11/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82%E5%8C%BA%E5%88%AB/","excerpt":"基本数据类型和引用数据类型作为参数的区别基本数据类型的变量中直接存放数据值本身，所以改的时候改的是数据值本身；但是引用类型不同的地方在于真正的数据并没有在栈区的变量中保存，而是在堆区里面保存着，所以虽然也拷贝了一份，也是副本，但是二者指向的是同一块堆区。","text":"基本数据类型和引用数据类型作为参数的区别基本数据类型的变量中直接存放数据值本身，所以改的时候改的是数据值本身；但是引用类型不同的地方在于真正的数据并没有在栈区的变量中保存，而是在堆区里面保存着，所以虽然也拷贝了一份，也是副本，但是二者指向的是同一块堆区。 引用数据类型就好比如说，两位同学使用的是同一份复习资料，其中一人把资料撕毁了，另一人当然也会受到影响。而基本数据类型就好比复印了一份，其中一人将自己的资料撕了，并不影响别人。 1、当使用基本类型作为方法的参数时候，在方法体中对形参的修改不会影响到实际参数1234567891011public class Test &#123; public static void main(String[] args) &#123; int a=1; doSomething(a); System.out.println(a); &#125; private static void doSomething(int b) &#123; b=200; &#125;&#125; 基本变量的传递就是复制了一份，操作复制的值并不会影响原来的值 2、当使用引用类型作为方法参数的时候，在方法体中对形参指向的内容修改，则会影响实际参数123456789101112public class Test &#123; public static void main(String[] args) &#123; int arr[]=new int[2]; arr[0]=100; doSomething(arr); System.out.println(arr[0]); &#125; private static void doSomething(int[] integer) &#123; integer[0]=200; &#125;&#125; 3、当使用引用类型作为方法参数的时候，在方法体中对形参指向修改，则不会影响实际参数12345678910111213public class Test &#123; public static void main(String[] args) &#123; int arr[]=new int[2]; arr[0]=100; doSomething(arr); System.out.println(arr[0]); &#125; private static void doSomething(int[] integer) &#123; integer=new int[2]; integer[0]=200; &#125;&#125;","categories":[],"tags":[{"name":"javase","slug":"javase","permalink":"http://kayuyu1.github.io/tags/javase/"}]},{"title":"文件上传和下载","slug":"文件上传和下载","date":"2020-05-10T14:14:58.000Z","updated":"2020-05-10T14:17:27.841Z","comments":true,"path":"2020/05/10/文件上传和下载/","link":"","permalink":"http://kayuyu1.github.io/2020/05/10/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/","excerpt":"准备工作 转载与：[狂神说] 文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。","text":"准备工作 转载与：[狂神说] 文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。 前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器； 对表单中的 enctype 属性做个详细的说明： application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。 multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。 text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。 1234&lt;form action=\"\" enctype=\"multipart/form-data\" method=\"post\"&gt; &lt;input type=\"file\" name=\"file\"/&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; 一旦设置了enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的HTTP响应。在2003年，Apache Software Foundation发布了开源的Commons FileUpload组件，其很快成为Servlet/JSP程序员上传文件的最佳选择。 Servlet3.0规范已经提供方法来处理文件上传，但这种上传需要在Servlet中完成。 而Spring MVC则提供了更简单的封装。 Spring MVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的。 Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类： CommonsMultipartResolver。因此，SpringMVC的文件上传还需要依赖Apache Commons FileUpload的组件。 文件上传 1、导入文件上传的jar包，commons-fileupload ， Maven会自动帮我们导入他的依赖包 commons-io包； 123456789101112&lt;!--文件上传--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--servlet-api导入高版本的--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt;&lt;/dependency&gt; 2、配置bean：multipartResolver 【注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！】 12345678&lt;!--文件上传配置--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt; &lt;property name=\"defaultEncoding\" value=\"utf-8\"/&gt; &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt; &lt;property name=\"maxUploadSize\" value=\"10485760\"/&gt; &lt;property name=\"maxInMemorySize\" value=\"40960\"/&gt;&lt;/bean&gt; CommonsMultipartFile 的 常用方法： String getOriginalFilename()：获取上传文件的原名 InputStream getInputStream()：获取文件流 void transferTo(File dest)：将上传文件保存到一个目录文件中 我们去实际测试一下 3、编写前端页面 1234&lt;form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\"&gt; &lt;input type=\"file\" name=\"file\"/&gt; &lt;input type=\"submit\" value=\"upload\"&gt;&lt;/form&gt; 4、Controller 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.kuang.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.commons.CommonsMultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.*;@Controllerpublic class FileController &#123; //@RequestParam(\"file\") 将name=file控件得到的文件封装成CommonsMultipartFile 对象 //批量上传CommonsMultipartFile则为数组即可 @RequestMapping(\"/upload\") public String fileUpload(@RequestParam(\"file\") CommonsMultipartFile file ,HttpServletRequest request) throws IOException &#123; //获取文件名 : file.getOriginalFilename(); String uploadFileName = file.getOriginalFilename(); //如果文件名为空，直接回到首页！ if (\"\".equals(uploadFileName))&#123; return \"redirect:/index.jsp\"; &#125; System.out.println(\"上传文件名 : \"+uploadFileName); //上传路径保存设置 String path = request.getServletContext().getRealPath(\"/upload\"); //如果路径不存在，创建一个 File realPath = new File(path); if (!realPath.exists())&#123; realPath.mkdir(); &#125; System.out.println(\"上传文件保存地址：\"+realPath); InputStream is = file.getInputStream(); //文件输入流 OutputStream os = new FileOutputStream(new File(realPath,uploadFileName));//文件输出流 //读取写出 int len=0; byte[] buffer = new byte[1024]; while ((len=is.read(buffer))!=-1)&#123; os.write(buffer,0,len); os.flush(); &#125; os.close(); is.close(); return \"redirect:/index.jsp\"; &#125;&#125; 5、测试上传文件，OK！ 采用file.Transto 来保存上传的文件 1、编写Controller 1234567891011121314151617181920/** 采用file.Transto 来保存上传的文件*/@RequestMapping(\"/upload2\")public String fileUpload2(@RequestParam(\"file\") CommonsMultipartFile file,HttpServletRequest request) throws IOException &#123; //上传路径保存设置 String path = request.getServletContext().getRealPath(\"/upload\"); File realPath = new File(path); if (!realPath.exists())&#123; realPath.mkdir(); &#125; //上传文件地址 System.out.println(\"上传文件保存地址：\"+realPath); //通过CommonsMultipartFile的方法直接写文件（注意这个时候） file.transferTo(new File(realPath +\"/\"+ file.getOriginalFilename())); return \"redirect:/index.jsp\";&#125; 2、前端表单提交地址修改 3、访问提交测试，OK！ 文件下载 文件下载步骤： 1、设置 response 响应头 2、读取文件 – InputStream 3、写出文件 – OutputStream 4、执行操作 5、关闭流 （先开后关） 代码实现： 12345678910111213141516171819202122232425262728293031@RequestMapping(value=\"/download\")public String downloads(HttpServletResponse response ,HttpServletRequest request)throws Exception&#123; //要下载的图片地址 String path = request.getServletContext().getRealPath(\"/upload\"); String fileName = \"基础语法.jpg\"; //1、设置response 响应头 response.reset(); //设置页面不缓存,清空buffer response.setCharacterEncoding(\"UTF-8\"); //字符编码 response.setContentType(\"multipart/form-data\"); //二进制传输数据 //设置响应头 response.setHeader(\"Content-Disposition\", \"attachment;fileName=\"+URLEncoder.encode(fileName, \"UTF-8\")); File file = new File(path,fileName); //2、 读取文件--输入流 InputStream input=new FileInputStream(file); //3、 写出文件--输出流 OutputStream out = response.getOutputStream(); byte[] buff =new byte[1024]; int index=0; //4、执行 写出操作 while((index= input.read(buff))!= -1)&#123; out.write(buff, 0, index); out.flush(); &#125; out.close(); input.close(); return null;&#125; 前端 1&lt;a href=\"/download\"&gt;点击下载&lt;/a&gt; 测试，文件下载OK，大家可以和我们之前学习的JavaWeb原生的方式对比一下，就可以知道这个便捷多了!","categories":[],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://kayuyu1.github.io/tags/SSM/"}]},{"title":"有关流的细节","slug":"有关流的细节","date":"2020-05-08T16:31:10.000Z","updated":"2020-05-09T01:11:15.189Z","comments":true,"path":"2020/05/09/有关流的细节/","link":"","permalink":"http://kayuyu1.github.io/2020/05/09/%E6%9C%89%E5%85%B3%E6%B5%81%E7%9A%84%E7%BB%86%E8%8A%82/","excerpt":"1.flush()与close的区别因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush 方法了。","text":"1.flush()与close的区别因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush 方法了。 flush ：刷新缓冲区到目的文件，流对象可以继续使用。 close:先刷新缓冲区到目的文件，然后通知系统释放资源。流对象不可以再被使用了。 2.流体系 2.1 .缓冲流概述缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类： 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。 2.3.转换流 转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。 2.4.序列化Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。看图理解序列化 2.5.补充java转义 为什么需要转义：避免二义性，因为java不认识你这个是字符串，还是特殊字符 转义符号:\\ 在Java中，不管是String.split()，还是正则表达式，有一些特殊字符需要转义， 这些字符是 \\( [ { / ^ - $ ¦ } ] ) ? * + .** 2.6.排序练习1234562.这次指导，意义绝不局限在内蒙古一地，对于各地区各部门深入开展主题教育、抓好落实抓出成效都具有十分重要的示范效应，可以说是一堂生动的“公开课”&amp;4.所谓抓“四个到位”，一是抓思想认识到位，二是抓检视问题到位，三是抓整改落实到位，四是抓组织领导到位。主题教育要取得实际效果，解决实质问题，习近平强调的抓“四个到位”至关重要&amp;3.不忘初心、牢记使命，思想认识到位是重要前提，思想不深刻认识不到位，就不能直抵灵魂、触及根源；检视问题到位是重要基础，如果搞不清问题是什么、症结在哪里，就拿不出实招、硬招；整改落实到位是成效保障，做不到立查立改、即知即改、盯住不放地改，就成了讲空话、务虚功；组织领导到位是责任保障，各级党委（党组）、主要领导同志组织领导作用发挥得好不好，结果大不一样。只有四个方面都抓到位，主题教育才能取得实效&amp;1.习近平对如何抓“四个到位”一一作出深入阐述：&amp;6.抓思想认识到位——把学习贯穿始终，不断深化对主题教育重大意义的认识，深化对党的初心和使命的认识，深化对党面临的风险考验的认识&amp;5.抓检视问题到位——深入调查研究，把问题找到找准，把根源挖深，明确努力方向和改进措施&amp; 2.6.1仅使用FileReader和FileWriter分析： 先将读取的数据接受 根据&amp;分段 根据.分割 写入hashmap 再排序写出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * @program: workspace_idea * @description: * @author: Mr.Kuang * @create: 2020-05-08 22:17 **/public class IoDemo10 &#123; public static void main(String[] args) throws IOException &#123; File file1 = new File(\"ky\\\\1.txt\"); File file2 = new File(\"ky\\\\2.txt\"); FileReader fileReader = new FileReader(file1); FileWriter fileWriter = new FileWriter(file2); //创建一个StringBuffer接受读取 StringBuffer stringBuffer = new StringBuffer(); //用hashMap存储 HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;(); int len=0; char buf[]=new char[1]; while ((len=fileReader.read(buf))!=-1) &#123; stringBuffer=stringBuffer.append(buf); //一行结束 if (stringBuffer.toString().endsWith(\"&amp;\")) &#123; //System.out.println(stringBuffer.toString()); //分割一行的序号和段子 String[] split = stringBuffer.toString().split(\"\\\\.\"); //操，为啥分割第一个会有换行符号？测试代码不用管 System.out.print(split[0].toString().replaceAll(\"\\r\\n\",\"\")+\".\"); System.out.println(split[1]); hashMap.put(split[0].toString().replaceAll(\"\\r\\n\",\"\"),split[1]); //清空 stringBuffer.delete(0,stringBuffer.length()); &#125; &#125; Set&lt;String&gt; keySet = hashMap.keySet(); for (int i=1;i&lt;=hashMap.size();i++) &#123; String key=String.valueOf(i); fileWriter.write(key+\".\"+hashMap.get(key)+\"\\r\\n\"); &#125; //写数据 fileReader.close(); fileWriter.close(); &#125;&#125; 我擦，我要骂娘，为啥split[0]会带一个换行符号，搞了半天，头都晕了，我估计是StringBuffer的原因。 2.6.2使用BufferedReader和BufferedWriter分析： 使用BufferedReader的readLine方法读取一行 根据.分割每一行 用hashmap存储 再排序写出 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @program: workspace_idea * @description: * @author: Mr.Kuang * @create: 2020-05-08 21:05 **/public class IoDemo09 &#123; public static void main(String[] args) throws IOException &#123; HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;(); File file1 = new File(\"ky\\\\1.txt\"); File file2 = new File(\"ky\\\\2.txt\"); FileReader fileReader = new FileReader(file1); FileWriter fileWriter = new FileWriter(file2); BufferedReader bufferedReader = new BufferedReader(fileReader); BufferedWriter bufferedWriter = new BufferedWriter(fileWriter); String s=null; //读取 while ((s=bufferedReader.readLine())!=null) &#123; //每读取一行，分割一行 String[] split = s.split(\"\\\\.\"); hashMap.put(split[0],split[1]); &#125; //写数据 for (int i = 1; i &lt;=hashMap.size() ; i++) &#123; String key=String.valueOf(i); String value = hashMap.get(key); bufferedWriter.write(key+\".\"+value); bufferedWriter.newLine(); &#125; bufferedReader.close(); bufferedWriter.close(); &#125;&#125;","categories":[],"tags":[{"name":"javase","slug":"javase","permalink":"http://kayuyu1.github.io/tags/javase/"}]},{"title":"SSM配置文件整合","slug":"SSM配置文件整合","date":"2020-05-08T07:49:11.000Z","updated":"2020-05-09T10:09:46.532Z","comments":true,"path":"2020/05/08/SSM配置文件整合/","link":"","permalink":"http://kayuyu1.github.io/2020/05/08/SSM%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%95%B4%E5%90%88/","excerpt":"代码贴多了也累，这次就画一个图吧","text":"代码贴多了也累，这次就画一个图吧","categories":[],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://kayuyu1.github.io/tags/SSM/"}]},{"title":"out中的lib没有jar包的问题","slug":"out中的lib没有jar包的问题","date":"2020-05-07T09:05:16.000Z","updated":"2020-05-07T09:35:41.365Z","comments":true,"path":"2020/05/07/out中的lib没有jar包的问题/","link":"","permalink":"http://kayuyu1.github.io/2020/05/07/out%E4%B8%AD%E7%9A%84lib%E6%B2%A1%E6%9C%89jar%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"在idea中的out目录中我们可以看到部署到tomcat的web项目","text":"在idea中的out目录中我们可以看到部署到tomcat的web项目 有时候我们明明通过maven配置了相关的jar包，但部署到tomcat的项目的lib下却没有 如下： 甚至连lib都没有 这时候我们就要打开Project Settings-&gt;Artifacts 选择没有lib的项目点击创建 导入jar包 再次启动tomcat或者idea就能看到lib和里面的jar包了","categories":[],"tags":[{"name":"bug","slug":"bug","permalink":"http://kayuyu1.github.io/tags/bug/"}]},{"title":"为什么web-inf下的资源不能重定向","slug":"为什么web-inf下的资源不能重定向","date":"2020-05-06T07:26:16.000Z","updated":"2020-05-06T10:02:41.280Z","comments":true,"path":"2020/05/06/为什么web-inf下的资源不能重定向/","link":"","permalink":"http://kayuyu1.github.io/2020/05/06/%E4%B8%BA%E4%BB%80%E4%B9%88web-inf%E4%B8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E4%B8%8D%E8%83%BD%E9%87%8D%E5%AE%9A%E5%90%91/","excerpt":"为什么web-inf下的资源不能重定向? 最近学springmvc，突然记起这个问题，但一直没知道原理，今天就在网上查了一下","text":"为什么web-inf下的资源不能重定向? 最近学springmvc，突然记起这个问题，但一直没知道原理，今天就在网上查了一下 首先web-inf下的内容只能服务器级别才能访问,而客户端级别是不能访问的。 然后我们再来解释一下请求转发和重定向 请求转发 就比如：我们设计好了一个项目，然后找A公司实现，A公司不会做，但他偷偷找外包B公司来做。到最后，我们以为是A公司做的，就对外宣传这是A公司做的。（所以我们就相当于只对A发 送了一次请求，URL地址栏里依然是A公司）。 简单来说请求转发是在服务器内部转发，这是属于服务器的行为。 重定向： 同样是找A公司，但他不会偷偷找外包了而是接着告诉我们去找B公司。（所以我们就发送了两次请求，URL地址栏里就变成了B公司） 重定向就是通过客户端转发，是属于客户端行为 总结： 因为重定向属于客户端行为，而web-inf下的内容只能服务器级别才能访问，所以web-inf下的资源不能重定向 补充：有关form表单的action属性开头加/与不加/的区别设置tomcat的url： 第一种开头不加： 1&lt;form action=\"user/test1\" method=\"post\"&gt; ​ 请求的地址栏为： ​ 第二种加/ 1&lt;form action=\"/user/test1\" method=\"post\"&gt; ​ 请求的地址栏为： ​ 分析总结：第一种不加/会在当前部署好的项目下查找资源，第二种加/则会在tomcat根路径下查找资源","categories":[],"tags":[{"name":"javaee","slug":"javaee","permalink":"http://kayuyu1.github.io/tags/javaee/"}]},{"title":"SpringMVC的原理","slug":"SpringMVC的原理","date":"2020-05-06T01:13:48.000Z","updated":"2020-05-06T03:31:04.206Z","comments":true,"path":"2020/05/06/SpringMVC的原理/","link":"","permalink":"http://kayuyu1.github.io/2020/05/06/SpringMVC%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"1、SpringMVC演示 导入包","text":"1、SpringMVC演示 导入包 123456789101112131415161718192021222324&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建Controller 12345678910111213141516171819202122import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;//注意：这里我们先导入Controller接口public class HelloController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //ModelAndView 模型和视图 ModelAndView mv = new ModelAndView(); //封装对象，放在ModelAndView中。Model mv.addObject(\"msg\",\"HelloSpringMVC!\"); //封装要跳转的视图，放在ModelAndView中 mv.setViewName(\"hello\"); //: /WEB-INF/jsp/hello.jsp return mv; &#125;&#125; 创建spring-servlet-xml 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--注册HandlerMapping和HandlerAdapter--&gt; &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/&gt; &lt;!--视图解析器--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\"&gt; &lt;!--前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!--后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!--Handler--&gt; &lt;bean id=\"/hello\" class=\"com.ky.controller.HelloController\"/&gt;&lt;/beans&gt; 注册DispatcherServlet 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动级别-1 跟随服务器启动--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt; &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 创建jsp 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;ky&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 2、图解原理 1.DispatcherServlet拦截用户请求 2.3.4.HandlerMapping作用是根据当前请求的找到对应的Handler处理器 5.6.HandlerAdapter找到具体的Controller并让其执行 7.8.Controller将具体的执行信息返回给DispatcherServlet,如ModelAndView 9.10.DispatcherServlet调用视图解析器处理传过来的逻辑视图名后，调用具体视图返回 11.最终视图呈现给用户 对于HandlerMapping和HandlerAdapter个人理解是：HandlerMapping是根据url找到对应的处理器名字， 比如：http://localhost:8080/SpringMVCDemo02/hello 找的就是/hello。 HandlerAdapter则是找到具体的处理器。 3、补充/*与/的区别/ 匹配所有的请求；（不包括.jsp） /* 匹配所有的请求；（包括.jsp） 在SpringMVC中最好用/，因为有一个视图解析器，当jsp被拦截的时候，会被拼接从而出现404错误。","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://kayuyu1.github.io/tags/SpringMVC/"}]},{"title":"设计模式之适配","slug":"设计模式之适配","date":"2020-05-05T07:02:20.000Z","updated":"2020-05-05T08:55:42.936Z","comments":true,"path":"2020/05/05/设计模式之适配/","link":"","permalink":"http://kayuyu1.github.io/2020/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D/","excerpt":"1、什么是适配器模式定义：将一个类的接口转换成客户希望的另外一个接口。Adapter\\模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 角色分析： 目标接口：客户所期待的接口，目标可以是具体类或抽象类，也可以是接口 需要适配的类：需要适配的类或者适配的类 适配器：通过包装一个需要适配的对象，吧原接口转换成目标对象","text":"1、什么是适配器模式定义：将一个类的接口转换成客户希望的另外一个接口。Adapter\\模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 角色分析： 目标接口：客户所期待的接口，目标可以是具体类或抽象类，也可以是接口 需要适配的类：需要适配的类或者适配的类 适配器：通过包装一个需要适配的对象，吧原接口转换成目标对象 2、实例演示 苹果充电功能接口： 12345package com.ky.adapter;public interface ChargeIphone &#123; //给Iphone充电 void chargeIphone();&#125; 安卓充电线： 1234567891011121314/** * @program: Design_pattern * @description: 安卓充电线 * @author: Mr.Kuang * @create: 2020-05-05 15:44 **/public class ChargingLine &#123; public void charge() &#123; System.out.println(\"开始充电\"); &#125;&#125; 苹果手机： 1234567891011121314/** * @program: Design_pattern * @description: 苹果手机 * @author: Mr.Kuang * @create: 2020-05-05 15:43 **/public class Iphone &#123; //插入适配器开始充电 public void StartCharging(ChargeIphone adapter) &#123; adapter.chargeIphone(); &#125;&#125; 适配器： 123456789101112131415161718192021/** * @program: Design_pattern * @description: 适配器 * @author: Mr.Kuang * @create: 2020-05-05 15:44 **/public class Adapter implements ChargeIphone &#123; private ChargingLine chargingLine; //连接充电线 public void setChargingLine(ChargingLine chargingLine) &#123; this.chargingLine = chargingLine; &#125; @Override public void chargeIphone() &#123; System.out.println(\"能给Iphone充电了\"); chargingLine.charge(); &#125;&#125; 测试： 12345678910111213141516171819202122/** * @program: Design_pattern * @description: * @author: Mr.Kuang * @create: 2020-05-05 15:50 **/public class MyTest &#123; public static void main(String[] args) &#123; ChargingLine chargingLine = new ChargingLine(); Adapter adapter = new Adapter(); //连接充电线 adapter.setChargingLine(chargingLine); Iphone iphone = new Iphone(); //插入适配器开始充电 iphone.StartCharging(adapter); &#125;&#125; 上面这一种适配器叫做组合适配器 还有一种类适配器： 1234567891011121314/** * @program: Design_pattern * @description: 适配器 * @author: Mr.Kuang * @create: 2020-05-05 15:44 **/public class Adapter extends ChargingLine implements ChargeIphone &#123; @Override public void chargeIphone() &#123; System.out.println(\"能给Iphone充电了\"); super.charge(); &#125;&#125; 两者的区别就在于：组合适配器更加灵活，不必继承，只需设置要连接的另一个对象即可。 小结： 适配器的好处：提高了代码的复用，降低了耦合 缺点：过多使用适配器，可能会使代码变得复杂","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://kayuyu1.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"根据需求选集合","slug":"根据需求选集合","date":"2020-05-05T02:46:37.000Z","updated":"2020-05-05T02:51:23.877Z","comments":true,"path":"2020/05/05/根据需求选集合/","link":"","permalink":"http://kayuyu1.github.io/2020/05/05/%E6%A0%B9%E6%8D%AE%E9%9C%80%E6%B1%82%E9%80%89%E9%9B%86%E5%90%88/","excerpt":"根据需求选用合适的集合","text":"根据需求选用合适的集合","categories":[],"tags":[{"name":"javase","slug":"javase","permalink":"http://kayuyu1.github.io/tags/javase/"}]},{"title":"Spring整合MyBatis","slug":"Spring整合MyBatis","date":"2020-05-04T03:15:36.000Z","updated":"2020-05-04T11:40:11.831Z","comments":true,"path":"2020/05/04/Spring整合MyBatis/","link":"","permalink":"http://kayuyu1.github.io/2020/05/04/Spring%E6%95%B4%E5%90%88MyBatis/","excerpt":"1、原生的MyBatis1.1、回顾演示 导入包","text":"1、原生的MyBatis1.1、回顾演示 导入包 123456789101112131415161718192021&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; 编写配置文件 druid.properties: 1234username=rootpassword=123456jdbcUrl=jdbc:mysql:///mybatis?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8driverClass=com.mysql.jdbc.Driver mybatis-config.xml: 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--引入外部配置文件--&gt; &lt;properties resource=\"druid.properties\"/&gt; &lt;!--日志设置--&gt; &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;/settings&gt; &lt;!--别名扫描包下的实体类--&gt; &lt;typeAliases&gt; &lt;package name=\"com.ky.pojo\"/&gt; &lt;/typeAliases&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"com.ky.utils.DruidUtils\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;driverClass&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbcUrl&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt; &lt;mappers&gt; &lt;package name=\"com.ky.dao\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写工具类加载配置文件： 生产SqlSession的工具类： 123456789101112131415161718public class MyBatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; static &#123; try &#123; String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static SqlSession getSqlSession()&#123; //默认提交 return sqlSessionFactory.openSession(true); &#125;&#125; 创建数据源的工具类： 虽然Druid提供了一个同名的DruidDataSourceFactory类，但是不能在MyBatis中直接使用。 12345public class DruidUtils extends PooledDataSourceFactory &#123; public DruidUtils() &#123; this.dataSource = new DruidDataSource(); &#125;&#125; 编写dao 123public interface UserMapper &#123; List&lt;User&gt; getAll();&#125; 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.ky.dao.UserMapper\"&gt; &lt;select id=\"getAll\" resultType=\"user\"&gt; select *from mybatis.user_tab;&lt;/mapper&gt; 测试 123456789101112131415161718192021222324252627public class UserDaoTest &#123; //获取sqlsseion private SqlSession sqlSession=null; //getMapper; private UserMapper mapper =null; @Before public void before() &#123; sqlSession = MyBatisUtils.getSqlSession(); mapper = sqlSession.getMapper(UserMapper.class); &#125; @Test public void test()&#123; List&lt;User&gt; users = mapper.getAll(); for (User user : users) &#123; System.out.println(user); &#125; &#125; @After public void after() &#123; sqlSession.close(); &#125;&#125; 1.2、图解过程 2、Spring整合MyBatis2.1、演示 导入包： 1234567891011121314151617181920212223242526272829303132&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.26&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 注意：版本要一致 编写配置文件 druid.properties: 1234user=rootpassword=123456jdbcUrl=jdbc:mysql:///mybatis?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8driverClass=com.mysql.jdbc.Driver mybatis-config.xml: 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--日志设置--&gt; &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;/settings&gt; &lt;!--别名扫描包下的实体类--&gt; &lt;typeAliases&gt; &lt;package name=\"com.ky.pojo\"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; spring-dao.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--DateSource:使用Spring的数据源代替MyBatis的配置 c3p0 dbcp druid 我们这里使用阿里巴巴的duid--&gt; &lt;!--加载db.properties文件--&gt; &lt;context:property-placeholder location=\"classpath:druid.properties\"/&gt; &lt;!--注册数据源--&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;driverClass&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbcUrl&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;user&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/bean&gt; &lt;!--SqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!--绑定数据源--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!--绑定mybatis配置文件--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;!--绑定mapper.xml--&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/ky/dao/*.xml\"/&gt; &lt;/bean&gt; &lt;!--SqlSessionTemple:就是我们使用的sqlSeesion--&gt; &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;!--通过构造器注入SqlSessionFactory因为他没有set方法--&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/&gt; &lt;/bean&gt; &lt;!--注入实现类因为接口不能注入--&gt; &lt;bean id=\"userMapperImp\" class=\"com.ky.dao.UserMapperImp\"&gt; &lt;property name=\"sqlSession\" ref=\"sqlSession\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 注意： 1&lt;property name=\"username\" value=\"$&#123;user&#125;\"/&gt; 如果druid.配置文件中的用户的键尽量为username，以免出现 Access denied for user ‘Administrator’@‘localhost’ (using password: YES) 错误！！！！ 网上的原因是:properties 中不能用 username 作为变量，这种方式会注入自己的系统环境变量的 用户名，本来是 root ，不应是那个 windows 用户名 (但是我以前用username就没有没遇到这个问题) 编写dao 123public interface UserMapper &#123; List&lt;User&gt; getAll();&#125; 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.ky.dao.UserMapper\"&gt; &lt;select id=\"getAll\" resultType=\"user\"&gt; select *from mybatis.user_tab;&lt;/mapper&gt; 1234567891011121314public class UserMapperImp implements UserMapper &#123; //SqlSessionTemplate就是原先的SqlSession private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) &#123; this.sqlSession = sqlSession; &#125; @Override public List&lt;User&gt; findAll() &#123; UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.findAll(); &#125;&#125; 测试 1234567891011121314151617public class MyTest &#123; @Test public void test1()&#123; //获取ioc容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-dao.xml\"); //获取实现类 UserMapper userMapperImp = applicationContext.getBean(\"userMapperImp\", UserMapper.class); List&lt;User&gt; users = userMapperImp.findAll(); users.forEach(user -&gt; System.out.println(user)); &#125;&#125; 2.2、图解 通过对比分析我们发现： Spring将数据源，SqlSessionFactory，SqlSessionTemple（SqlSession）全都注入到IOC容器中了 Spring还比Myabtis原生方法多了一个Mapper实现类//也可以不注入直接获取SqlSessionTemple再获取Mapper实现类 2.3、简化（不注入SqlSessionTemple）修改实现类： 123456789public class UserMapperImp2 extends SqlSessionDaoSupport implements UserMapper &#123; @Override public List&lt;User&gt; findAll() &#123;// SqlSession sqlSession = getSqlSession();// UserMapper mapper = sqlSession.getMapper(UserMapper.class);// List&lt;User&gt; users = mapper.findAll(); return getSqlSession().getMapper(UserMapper.class).findAll(); &#125;&#125; 修改spring-dao.xml 123&lt;bean id=\"userMapperImp2\" class=\"com.ky.dao.UserMapperImp2\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/&gt;&lt;/bean&gt; 分析：这里我们就不用注入SqlSessionTemple，因为我们继承了SqlSessionDaoSupport，而SqlSessionDaoSupport有一个属性SqlSessionTemplate和一个setSqlSessionFactory方法， 1private SqlSessionTemplate sqlSessionTemplate; 12345public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) &#123; if (this.sqlSessionTemplate == null || sqlSessionFactory != this.sqlSessionTemplate.getSqlSessionFactory()) &#123; this.sqlSessionTemplate = this.createSqlSessionTemplate(sqlSessionFactory); &#125; &#125; SqlSessionTemple已经是实现类的一个属性了，只需要set一个sqlSessionFactory就可以赋值，然后调用getSqlSession就可以返回","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kayuyu1.github.io/tags/Spring/"}]},{"title":"设计模式之代理","slug":"设计模式之代理","date":"2020-05-03T04:52:35.000Z","updated":"2020-05-04T15:15:10.091Z","comments":true,"path":"2020/05/03/设计模式之代理/","link":"","permalink":"http://kayuyu1.github.io/2020/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86/","excerpt":"1、代理模式简介代理模式的定义：代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。","text":"1、代理模式简介代理模式的定义：代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。 代理模式分为两大类： 静态代理：由一个类文件描述代理 动态代理：在内存中形成代理类 2、静态代理： 实现以上场景 功能接口： 123public interface Rent &#123; void Rent();&#125; 真实对象： 1234567public class Host implements Rent &#123; @Override public void Rent() &#123; System.out.println(\"出租房子\"); &#125;&#125; 代理对象： 1234567891011121314151617181920212223public class Proxy implements Rent &#123; private Host host; public Proxy(Host host) &#123; this.host = host; &#125; public Proxy() &#123; &#125; @Override public void Rent() &#123; seeHouse(); host.Rent(); hetong(); &#125; public void seeHouse() &#123; System.out.println(\"看房\"); &#125; public void hetong() &#123; System.out.println(\"签合同\"); &#125;&#125; 用户租房子： 1234567public class Client &#123; public static void main(String[] args) &#123; Host host = new Host(); Proxy proxy = new Proxy(host); proxy.Rent(); &#125;&#125; 分析：在以上代码中，我们并没有直接接触房东，而是通过中介完成了租房工作，这就是代理模式。 优点： 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 缺点 : 类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 . 我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 ! 3、动态代理功能接口和真实对象与上面相同 获取代理对象的类： 123456789101112131415161718192021222324252627282930313233343536public class ProxyHost &#123; public static Rent getProxy(Host host) &#123; /* * 三个参数： * 1.真实类的类加载器 * 2.真实类实现的接口 * 3.处理器InvocationHandler * */ Rent proxy = (Rent) Proxy.newProxyInstance(host.getClass().getClassLoader(), host.getClass().getInterfaces(), new InvocationHandler() &#123; /** * 代理逻辑编写的代码部分，代理对象调用所有的方法都会触发改方法执行 * 参数： * 1.proxy 代理对象 * 2.代理对象调用的方法 * 3.代理对象调用方法所传参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (method.getName().equals(\"Rent\")) &#123; System.out.println(\"看房\"); method.invoke(host, args); System.out.println(\"签合同\"); &#125; return null; &#125; &#125;); return proxy; &#125;&#125; 用户： 12345678910111213public class Client &#123; public static void main(String[] args) &#123; Host host = new Host(); //获得代理对象 Rent proxy = ProxyHost.getProxy(host); proxy.Rent(); &#125;&#125; 优点： 静态代理有的它都有，静态代理没有的，它也有！ 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 一个动态代理 , 一般代理某一类业务 一个动态代理可以代理多个类，代理的是接口！ 4、编写一个动态代理类的模板12345678910111213141516171819202122232425262728293031/** * @program: SpringDemo * @description: 动态代理工具类 * @author: Mr.Kuang * @create: 2020-05-03 13:51 **/public class ProxyUtils implements InvocationHandler &#123; //需要被代理的接口 private Object target; public void setTarget(Object target) &#123; this.target = target; &#125; public Object getObjectProxy(Object target) &#123; Object proxy = Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); return proxy; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //填写要处理的的代码 Object invoke = method.invoke(target, args); return invoke; &#125;&#125; 分析：两个核心 Proxy.newProxyInstance 创建一个代理对象 Object invoke 处理代理对象如何代理","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://kayuyu1.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Spring的注解和xml配置bean那一个优先级更高","slug":"Spring的注解和xml配置bean那一个优先级更高","date":"2020-05-02T09:30:35.000Z","updated":"2020-05-02T09:43:23.238Z","comments":true,"path":"2020/05/02/Spring的注解和xml配置bean那一个优先级更高/","link":"","permalink":"http://kayuyu1.github.io/2020/05/02/Spring%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%92%8Cxml%E9%85%8D%E7%BD%AEbean%E9%82%A3%E4%B8%80%E4%B8%AA%E4%BC%98%E5%85%88%E7%BA%A7%E6%9B%B4%E9%AB%98/","excerpt":"思考： 刚复习了注解，我就在想Spring的注解和xml配置bean那一个优先级更高？","text":"思考： 刚复习了注解，我就在想Spring的注解和xml配置bean那一个优先级更高？ 测试： 实体类 12345678910111213@Component//将User注册到IOC容器public class User &#123; @Value(\"kyky\")//给name赋值 private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; xml配置 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--开启注解支持并且开启包扫描--&gt; &lt;context:component-scan base-package=\"com.ky.pojo\"/&gt; &lt;!--在xml注册一个同名的user对象但name不同--&gt; &lt;bean id=\"user\" class=\"com.ky.pojo.User\"&gt; &lt;property name=\"name\" value=\"kykyky\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试 123456789public class MyTest &#123; @Test public void test1()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); User user = applicationContext.getBean(\"user\", User.class); System.out.println(user.name); &#125;&#125; 结论：xml配置比注解配置bean的属性优先级高，原因是XML是可以随时修改的，即插即用，不用重新编译！！","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kayuyu1.github.io/tags/Spring/"}]},{"title":"Spring注解自动装配","slug":"Spring注解自动装配","date":"2020-05-02T04:10:09.000Z","updated":"2020-05-25T01:48:04.293Z","comments":true,"path":"2020/05/02/Spring注解自动装配/","link":"","permalink":"http://kayuyu1.github.io/2020/05/02/Spring%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/","excerpt":"1、Bean注解的自动装配简介 自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean","text":"1、Bean注解的自动装配简介 自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean 1.1、Spring中bean有三种装配机制分别是： 在xml中显式配置； 在java中显式配置； 隐式的bean发现机制和自动装配。 这里我们主要讲第三种：自动化的装配bean。 1.2、Spring的自动装配需要从两个角度来实现 组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI； 组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。 推荐不使用自动装配xml配置 , 而使用注解 . 2、测试2.1、创建三个实体类Cat，Dog，User，其中User有cat，dog属性12345public class Cat &#123; public void shout() &#123; System.out.println(\"miao~\"); &#125;&#125; 12345public class Dog &#123; public void shout() &#123; System.out.println(\"wang~\"); &#125;&#125; 12345public class User &#123; private Cat cat; private Dog dog; private String str;&#125; 2.2、编写配置文件123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"dog\" class=\"com.kuang.pojo.Dog\"/&gt; &lt;bean id=\"cat\" class=\"com.kuang.pojo.Cat\"/&gt; &lt;bean id=\"user\" class=\"com.kuang.pojo.User\"&gt; &lt;property name=\"cat\" ref=\"cat\"/&gt; &lt;property name=\"dog\" ref=\"dog\"/&gt; &lt;property name=\"str\" value=\"ky\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 2.3、测试123456789public class MyTest &#123; @Test public void testMethodAutowire() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) context.getBean(\"user\"); user.getCat().shout(); user.getDog().shout(); &#125;&#125; 2.4、byNameautowire byName (按名称自动装配) 使用byName要保证spring容器中id唯一 测试： 修改配置文件: 123&lt;bean id=\"user\" class=\"com.kuang.pojo.User\" autowire=\"byName\"&gt; &lt;property name=\"str\" value=\"ky\"/&gt; &lt;/bean&gt; 再次测试，输出成功 修改setDog的方法名为setPig ，再测试发现报空指针异常 小结： 当一个bean节点带有 autowire byName的属性时。 将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。 去spring容器中寻找是否有此字符串名称id的对象。 如果有，就取出注入；如果没有，就报空指针异常。 2.5、byTypeautowire byType (按类型自动装配) 使用byType 必须保证在spring容器中类型唯一，否则会报NoUniqueBeanDefinitionException 测试： 修改配置文件： 123&lt;bean id=\"user\" class=\"com.kuang.pojo.User\" autowire=\"byName\"&gt; &lt;property name=\"str\" value=\"ky\"/&gt; &lt;/bean&gt; 再次测试，输出成功 注册一个cat2对象 1&lt;bean id=\"cat2\" class=\"com.kuang.pojo.Cat\"/&gt; 测试，报错：NoUniqueBeanDefinitionException 删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。 这就是按照类型自动装配！ 2.6、@Autowired @Resource @Qualifier2.6.1、@Autowired @Autowired是按类型自动转配的，不支持id匹配。 需要导入 spring-aop的包！ 测试： 1、将User类中的set方法去掉，使用@Autowired注解 1234567891011121314151617public class User &#123; @Autowired private Cat cat; @Autowired private Dog dog; private String str; public Cat getCat() &#123; return cat; &#125; public Dog getDog() &#123; return dog; &#125; public String getStr() &#123; return str; &#125;&#125; 2、此时配置文件内容 12345&lt;context:annotation-config/&gt;&lt;bean id=\"dog\" class=\"com.kuang.pojo.Dog\"/&gt;&lt;bean id=\"cat\" class=\"com.kuang.pojo.Cat\"/&gt;&lt;bean id=\"user\" class=\"com.kuang.pojo.User\"/&gt; 3、测试，成功输出结果！ @Autowired(required=false) 说明：false，对象可以为null；true，对象必须存对象，不能为null。 123//如果允许对象为null，设置required = false,默认为true@Autowired(required = false)private Cat cat; 2.6.2、@Qualifier @Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配 @Qualifier不能单独使用。 测试实验步骤： 1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！ 1234&lt;bean id=\"dog1\" class=\"com.kuang.pojo.Dog\"/&gt;&lt;bean id=\"dog2\" class=\"com.kuang.pojo.Dog\"/&gt;&lt;bean id=\"cat1\" class=\"com.kuang.pojo.Cat\"/&gt;&lt;bean id=\"cat2\" class=\"com.kuang.pojo.Cat\"/&gt; 2、没有加Qualifier测试，直接报错 3、在属性上添加Qualifier注解 123456@Autowired@Qualifier(value = \"cat2\")private Cat cat;@Autowired@Qualifier(value = \"dog2\")private Dog dog; 测试，成功输出！ 2.6.3、@Resource @Resource如有指定的name属性，先按该属性进行byName方式查找装配； 其次再进行默认的byName方式进行装配； 如果以上都不成功，则按byType的方式自动装配。 都不成功，则报异常。 实体类： 12345678public class User &#123; //如果允许对象为null，设置required = false,默认为true @Resource(name = \"cat2\") private Cat cat; @Resource private Dog dog; private String str;&#125; beans.xml 12345&lt;bean id=\"dog\" class=\"com.kuang.pojo.Dog\"/&gt;&lt;bean id=\"cat1\" class=\"com.kuang.pojo.Cat\"/&gt;&lt;bean id=\"cat2\" class=\"com.kuang.pojo.Cat\"/&gt;&lt;bean id=\"user\" class=\"com.kuang.pojo.User\"/&gt; 测试：结果OK 配置文件2：beans.xml ， 删掉cat2 12&lt;bean id=\"dog\" class=\"com.kuang.pojo.Dog\"/&gt;&lt;bean id=\"cat1\" class=\"com.kuang.pojo.Cat\"/&gt; 实体类上只保留注解 1234@Resourceprivate Cat cat;@Resourceprivate Dog dog; 结果：OK 结论：先进行byName查找，失败；再进行byType查找，成功。 小结： @Autowired 根据类型注入， @Resource 默认根据名字注入，其次按照类型搜索 @Autowired @Qualifie(“userService”) 两个结合起来可以根据名字和类型注入 面试题 Spring 为啥把bean默认设计成单例？ 答案：为了提高性能！！！从几个方面， 少创建实例 减少垃圾回收 缓存快速获取 单例有啥劣势？ 如果是有状态的话在并发环境下线程不安全。","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kayuyu1.github.io/tags/Spring/"}]},{"title":"Spring简介与IOC思想","slug":"Spring简介与IOC思想","date":"2020-05-01T02:15:36.000Z","updated":"2020-05-22T05:44:54.287Z","comments":true,"path":"2020/05/01/Spring简介与IOC思想/","link":"","permalink":"http://kayuyu1.github.io/2020/05/01/Spring%E7%AE%80%E4%BB%8B%E4%B8%8EIOC%E6%80%9D%E6%83%B3/","excerpt":"1、简介1.1、什么是SpringSpring框架是一个开放源代码的J2EE应用程序框架，为了解决企业应用开发的复杂性而创建的，由[Rod Johnson](https://baike.baidu.com/item/Rod Johnson/1423612)发起。","text":"1、简介1.1、什么是SpringSpring框架是一个开放源代码的J2EE应用程序框架，为了解决企业应用开发的复杂性而创建的，由[Rod Johnson](https://baike.baidu.com/item/Rod Johnson/1423612)发起。 1.2、Spring的作用简化应用程序的开发。 1.3、Spring的特点 Spring是一个开源的免费框架 Spring是一个轻量级的、非入侵的框架 控制反转（IOC），面向切面编程（AOP） 总结：Spring是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的开源框架 1.4、Spring七大组件 1.4.1、核心容器（Spring Code）概念是Spring的核心容器，提供了Spring框架的基本功能； 此模块包含的BeanFactory类是Spring的核心类，负责产生和管理Bean，是工程模式的实现； 采用Factory(工厂模式)实现了IOC（控制反转）将应用的配置和依赖性规范与实际的应用程序代码分开； Spring以bean的方式组织和管理Java应用中发各个组件及其关系。 1.4.2、应用上下文（Spring Context）概念是一个配置文件，向Spring框架提供上下文信息； SpringContext模块继承BeanFactory类，添加了事件处理、国际化、资源装载、透明装载、以及数据校验等功能； 还提供了框架式的Bean的访问方式和企业级的功能，如JNDI访问，支持EJB、远程调用、继承模板框架、Email和定时任务调度等； 1.4.3、面向切面编程（Spring AOP）概念Spring AOP直接将面向方面的编程功能集成到了Spring框架中，所以很容易的使Spring框架管理的任何对象支持AOP（Spring集成了所有AOP功能。通过事务管理可以使任意Spring管理的对象AOP化）； Spring AOP为基于Spring的应用程序中的对象提供了事务管理服务； 通过使用Spring AOP，不用依赖EJB组件，就可以将声明性事务管集成到应用程序中。 1.4.4、JDBC和DAO模块（Spring DAO）概念DAO（DataAccessObject）模式思想是将业务逻辑代码与数据库交互代码分离，降低两者耦合； 通过DAO模式可以使结构变得更为清晰，代码更为简； DAO模块中的JDBC的抽象层，提供了有意义的异常层次结构，用该结构来管理异常处理，和不同数据库供应商所抛出的错误信息； 异常层次结构简化了数据库厂商的异常错误（不再从SQLException继承大批代码），极大的降低了需要编写的代码数量，并且提供了对声明式事务和编程式事务的支持； 1.4.5、对象实体映射（Spring ORM）概念：SpringORM模块提供了对现有ORM框架的支持；提供了ORM对象的关系工具，其中包括了Hibernate、JDO和 IBatis SQL Map等，所有的这些都遵从Spring的通用事务和DAO异常层次结构； 注意这里Spring是提供各类的接口（support），目前比较流行的下层数据库封闭映射框架，如ibatis,Hibernate等； 1.4.6、Web模块（Spring Web）概念：此模块建立在SpringContext基础之上，提供了Servlet监听器的Context和Web应用的上下文； 对现有的Web框架，如JSF、Tapestry、Structs等提供了集成； SpringWeb模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 1.4.7、MVC模块（Spring Web MVC）概念SpringWebMVC模块建立在Spring核心功能之上，拥有Spring框架的所有特性，能够适应多种多视图、模板技术、国际化和验证服务，实现控制逻辑和业务逻辑的清晰分离； 通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI; MVC模型: Servlet控制器为应用程序提供了一个进行前-后端处理的中枢。一方面为输入数据的验证、身份认证、日志及实现国际化编程提供了一个合适的切入点；另一方面也提供了将业务逻辑从JSP文件剥离的可能; 业务逻辑从JSP页面分离后，JSP文件蜕变成一个单纯完成显示任务的东西，这就是常说的View; 而独立出来的事务逻辑变成人们常说的Model，再加上控制器Control本身，就构成了MVC模式 2、IOC理论推导 UserDao 123public interface UserDao &#123; void getUser();&#125; 123456public class UserDaoMySql implements UserDao &#123; @Override public void getUser() &#123; System.out.println(\"实现了mysql\"); &#125;&#125; 123456public class UserDaoOracle implements UserDao &#123; @Override public void getUser() &#123; System.out.println(\"实现了Oracle\"); &#125;&#125; UserService 12345678public class UserServiceImpl implements UserService&#123; private UserDao userDao =new UserDaoOracle(); @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 测试： 123456public class MyTest &#123;public static void main(String[] args) &#123; UserService userService=new UserServiceImpl(); userService.getUser();&#125;&#125; 重点:如果我们此时想要实现MySql的功能,就需要修改UserServiceImpl的UserDao属性，如果涉及的代码量很大，修改的代价也就很大。但如果我们修改一下UserServiceImpl获取UserDao属性获取方式就能极大简化操作。 修改 12345678910111213public class UserServiceImpl implements UserService&#123; private UserDao userDao; //动态获取userDao public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 123456789public class MyTest &#123; public static void main(String[] args) &#123; UserService userService=new UserServiceImpl(); ((UserServiceImpl) userService).setUserDao(new UserDaoMySql()); userService.getUser(); &#125;&#125; 总结：第一种的方式的UserServiceImpl的UserDao属性是固定的，修改控制权在程序员，而第二种的UserDao属性是根据业务需求动态获取的，控制权在用户,降低了系统的耦合。这便是最简单的控制反转（IOC）; 3、ioc本质控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。 IoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。 Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。 4、一个Spring简单的使用创建实体类 12345678910111213141516171819202122232425public class HelloSpring &#123; private String str; public HelloSpring(String str) &#123; this.str = str; &#125; public HelloSpring() &#123; &#125; public String getStr() &#123; return str; &#125; public void setStr(String str) &#123; this.str = str; &#125; @Override public String toString() &#123; return \"HelloSpring&#123;\" + \"str='\" + str + '\\'' + '&#125;'; &#125;&#125; 创建beans.xml注册进HelloSpring的对象 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"hello\" class=\"com.ky.pojo.HelloSpring\"&gt; &lt;property name=\"str\" value=\"你好Spring\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试： 1234567891011public class MyTest &#123; @Test public void test()&#123; //获取Spring容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); //取出bean HelloSpring hello = (HelloSpring) applicationContext.getBean(\"hello\"); System.out.println(hello); &#125;&#125; 注意：你会发现，在以上代码中我们并没有出现new HelloSpring的代码，就能使用HelloSpring的实例化对象。这是因为我们将对象交给了Spring的IOC容器创建，管理，装配。这个过程就叫控制反转。 控制：传统应用程序的对象是由程序本身创建控制，使用Spring后，对象是Spring创建控制 反转：程序本身不创建对象，变成了被动接受对象 依赖：依赖于Spring创建bean对象 注入：就是利用set方法来进行对象bean的属性动态注入 总结：IOC是一种编程思想，由主动编程创建变成了被动的接受。Spring的IOC就是一句话：对象由Spring创建，管理，装配","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kayuyu1.github.io/tags/Spring/"}]},{"title":"MyBatis缓存","slug":"MyBatis缓存","date":"2020-04-30T04:26:08.000Z","updated":"2020-04-30T09:53:22.593Z","comments":true,"path":"2020/04/30/MyBatis缓存/","link":"","permalink":"http://kayuyu1.github.io/2020/04/30/MyBatis%E7%BC%93%E5%AD%98/","excerpt":"MyBatis的缓存机制 为什么需要缓存？ 原因：当访问数据量过大，多个用户读写数据库，会消耗读写资源，甚至可能出现并发问题。所以 引入缓存机制，将一些经常访问但不修改的信息存入缓存中，这样实现读写分离能一定减少性能的消耗","text":"MyBatis的缓存机制 为什么需要缓存？ 原因：当访问数据量过大，多个用户读写数据库，会消耗读写资源，甚至可能出现并发问题。所以 引入缓存机制，将一些经常访问但不修改的信息存入缓存中，这样实现读写分离能一定减少性能的消耗 1.一级缓存一级缓存默认开启，且只在SqlSession中有效，也就是从连接到关闭期间 测试： 查询相同的数据两次 123456789101112@Test public void test1()&#123; SqlSession sqlSession = MyBatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User userById1 = mapper.getUserById(2); System.out.println(userById1); System.out.println(\"=============\"); User userById2=mapper.getUserById(2); System.out.println(userById2); sqlSession.close(); &#125; 查询不同的数据 1234567891011@Test public void test1()&#123; SqlSession sqlSession = MyBatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User userById1 = mapper.getUserById(2); System.out.println(userById1); System.out.println(\"=============\"); User userById2=mapper.getUserById(3); System.out.println(userById2); sqlSession.close(); &#125; 查询相同的数据两次，但在当中执行更新或者插入操作 123456789101112131415161718@Test public void test2()&#123; SqlSession sqlSession = MyBatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User userById1 = mapper.getUserById(2); System.out.println(userById1); System.out.println(\"=============\"); HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"id\",3); map.put(\"name\",\"kyky\"); mapper.updateNameById(map); System.out.println(\"=============\"); User userById2=mapper.getUserById(2); System.out.println(userById2); sqlSession.close(); &#125; 总结： 一级缓存只在一次连接期间有效 一级缓存默认开启 当有增删改操作的时候，原有缓存会刷新 sqlSession.clearCache()方法;也会清理缓存 2.二级缓存 二级缓存也叫全局缓存，一级缓存作用域名太低了所以诞生了二级缓存 二级缓存是namespace级别的，一个名称空间对应一个缓存（一个mapper对应一个缓存） 工作机制 一个会话查询一条数据，这个数据会被存在一级缓存 会话结束后，一级缓存消失，但数据会保存到二级缓存中 新的会话，可以从二级缓存中获取内容 步骤： 开启全局缓存 12&lt;!--显式开启二级缓存，默认隐式开启--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; 在需要二级缓存mapper开启 12&lt;!--在当前mapper开启二级缓存--&gt; &lt;cache/&gt; 也可以自定义缓存。 12345&lt;cache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/&gt; 测试：在不同的sqlsess查询相同的数据 123456789101112@Testpublic void test4()&#123; SqlSession sqlSession1 = MyBatisUtils.getSqlSession(); SqlSession sqlSession2 = MyBatisUtils.getSqlSession(); User userById1= sqlSession1.getMapper(UserMapper.class).getUserById(2); System.out.println(\"===============\"); User userById2= sqlSession2.getMapper(UserMapper.class).getUserById(2); sqlSession1.close(); sqlSession2.close();&#125; 注意： 这里二级缓存并没有生效。原因是因为二级缓存是在一级缓存消失的时候才生效，sqlSession1和sqlSession2几乎同时关闭就没法使二级缓存生效. 修改代码： 123456789101112public void test4()&#123; SqlSession sqlSession1 = MyBatisUtils.getSqlSession(); SqlSession sqlSession2 = MyBatisUtils.getSqlSession(); User userById1= sqlSession1.getMapper(UserMapper.class).getUserById(2); System.out.println(userById1); sqlSession1.close(); System.out.println(\"===============\"); User userById2= sqlSession2.getMapper(UserMapper.class).getUserById(2); System.out.println(userById2); sqlSession2.close(); &#125; 3.缓存原理 注意：当当二级缓存和一级缓存同时存在的时候，会先查二级缓存，没有再查一级缓存，没有再查数据库","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://kayuyu1.github.io/tags/MyBatis/"}]},{"title":"MyBatis一对多与多对一","slug":"MyBatis一对多与多对一","date":"2020-04-29T03:32:52.000Z","updated":"2020-04-29T06:38:46.324Z","comments":true,"path":"2020/04/29/MyBatis一对多与多对一/","link":"","permalink":"http://kayuyu1.github.io/2020/04/29/MyBatis%E4%B8%80%E5%AF%B9%E5%A4%9A%E4%B8%8E%E5%A4%9A%E5%AF%B9%E4%B8%80/","excerpt":"1.多对一基本表一个老师多个学生","text":"1.多对一基本表一个老师多个学生 （1）第一种按照查询嵌套，子查询12345678910111213 &lt;!--按照查询嵌套，子查询--&gt;&lt;select id=\"getStudentTeacher\" resultMap=\"StudentMap\"&gt; select *from mybatis.student;&lt;/select&gt; &lt;resultMap id=\"StudentMap\" type=\"Student\"&gt; &lt;result column=\"id\" property=\"id\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;!--根据tid查询teacher--&gt; &lt;association property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"/&gt; &lt;/resultMap&gt;&lt;select id=\"getTeacher\" resultType=\"Teacher\"&gt; select *from mybatis.teacher where #&#123;id&#125;;&lt;/select&gt; 相当于以下sql： 1select *from mybatis.student where tid in (select id from mybatis.teacher); 注意：getTeacher中的#{id}是从getStudentTeacher中查询得到的tid （2）第二种按照结果嵌套查询，关联查询1234567891011121314&lt;!--按照结果嵌套,关联查询--&gt;&lt;select id=\"getStudentTeacher2\" resultMap=\"StudentMap2\"&gt; select s.id sid,s.name sname,t.name tname,t.id tid from mybatis.student s ,mybatis.teacher t where s.tid=t.id;&lt;/select&gt;&lt;resultMap id=\"StudentMap2\" type=\"Student\"&gt; &lt;result column=\"sid\" property=\"id\"/&gt; &lt;result column=\"sname\" property=\"name\"/&gt; &lt;association property=\"teacher\" javaType=\"Teacher\"&gt; &lt;result column=\"tid\" property=\"id\"/&gt; &lt;result column=\"tname\" property=\"name\"/&gt; &lt;/association&gt;&lt;/resultMap&gt; 123select s.id sid,s.name sname,t.name tname,t.id tid from mybatis.student s ,mybatis.teacher t where s.tid=t.id; 2.一对多（1）第一种按照查询嵌套，子查询1234567891011&lt;select id=\"getTeacherAndStudent2\" resultMap=\"TeacherAndStudent2\" parameterType=\"_int\"&gt;select *from mybatis.teacher where id=#&#123;tid&#125;;&lt;/select&gt;&lt;resultMap id=\"TeacherAndStudent2\" type=\"Teacher\"&gt; &lt;result property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;collection property=\"students\" javaType=\"ArrayList\" ofType=\"Student\" column=\"id\" select=\"getStudent\"/&gt;&lt;/resultMap&gt;&lt;select id=\"getStudent\" resultType=\"Student\"&gt; select *from mybatis.student where tid=#&#123;id&#125;;&lt;/select&gt; 注意：getStudent中的#{id}是从getTeacherAndStudent2中查询得到的tid并不是从方法传过来的参数 （2）第二种按照结果嵌套查询，关联查询123456789101112131415&lt;select id=\"getTeacherAndStudent\" resultMap=\"TeacherAndStudent\" parameterType=\"_int\"&gt;select t.name tname,t.id,s.name sname,s.id sidfrom mybatis.teacher t ,mybatis.student swhere s.tid=t.id and t.id=#&#123;tid&#125;;&lt;/select&gt;&lt;resultMap id=\"TeacherAndStudent\" type=\"Teacher\"&gt; &lt;result property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"tname\"/&gt; &lt;!--泛型用ofType--&gt; &lt;collection property=\"students\" ofType=\"Student\"&gt; &lt;result property=\"id\" column=\"sid\"/&gt; &lt;result property=\"name\" column=\"sname\"/&gt; &lt;result property=\"tid\" column=\"tid\"/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 小结：关联：association【多对一使用关键字】 集合：collection【一对多关键字】 javaType:用来指定实体类的指定类型 ofType：用来指定集合中的约束类型，例如：List, ofType就该等于”Student”","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://kayuyu1.github.io/tags/MyBatis/"}]},{"title":"mybatis生命周期","slug":"mybatis生命周期","date":"2020-04-28T04:00:17.000Z","updated":"2020-04-28T08:35:47.889Z","comments":true,"path":"2020/04/28/mybatis生命周期/","link":"","permalink":"http://kayuyu1.github.io/2020/04/28/mybatis%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"MyBatis生命周期1.SqlSessionFactoryBuilder这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。","text":"MyBatis生命周期1.SqlSessionFactoryBuilder这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 2.SqlSessionFactorySqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。 （类似连接池） 3.SqlSession可以想象成连接池的一次连接请求 SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它最好用完就关闭 4.Mapper代表具体的业务实现，底层实现是动态代理 5.图示","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://kayuyu1.github.io/tags/MyBatis/"}]},{"title":"MyBatis配置druid","slug":"MyBatis配置druid","date":"2020-04-27T11:47:29.000Z","updated":"2020-04-28T07:48:17.443Z","comments":true,"path":"2020/04/27/MyBatis配置druid/","link":"","permalink":"http://kayuyu1.github.io/2020/04/27/MyBatis%E9%85%8D%E7%BD%AEdruid/","excerpt":"MyBatis配置druid步骤1.导入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt;&lt;/dependency&gt;","text":"MyBatis配置druid步骤1.导入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt;&lt;/dependency&gt; 2.创建druid工厂类虽然Druid提供了一个同名的DruidDataSourceFactory类，但是不能在MyBatis中直接使用。 123456public class DruidUtils extends PooledDataSourceFactory &#123; public DruidUtils() &#123; this.dataSource = new DruidDataSource(); &#125;&#125; 3.创建druid配置文件druid.properties1234username=rootpassword=123456jdbcUrl=jdbc:mysql:///mybatis?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8driverClass=com.mysql.jdbc.Driver 4.设置mybatis-config.xml(1)引入外部文件12&lt;!--引入外部配置文件--&gt;&lt;properties resource=\"druid.properties\"/&gt; (2)修改属性配置123456&lt;dataSource type=\"com.ky.utils.DruidUtils\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;driverClass&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbcUrl&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt;&lt;/dataSource&gt; 注意：因为在DruidAbstractDataSource的源码为 12protected volatile String jdbcUrl;protected volatile String driverClass; 所以设置property的时候尽量以driverClass和jdbcUrl命名，如果以默认driver命名（默认的url不改不会报错，不知道为啥）否则会报错 Caused by: org.apache.ibatis.reflection.ReflectionException: Could not set property ‘driver’ of ‘class com.alibaba.druid.pool.DruidDataSource’ with value ‘com.mysql.jdbc.Driver’ Cause: java.lang.IllegalArgumentException: argument type mismatch","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://kayuyu1.github.io/tags/MyBatis/"}]},{"title":"关于update多个字段的某细节","slug":"关于update多个字段的某细节","date":"2020-04-26T15:50:14.000Z","updated":"2020-04-26T16:10:14.541Z","comments":true,"path":"2020/04/26/关于update多个字段的某细节/","link":"","permalink":"http://kayuyu1.github.io/2020/04/26/%E5%85%B3%E4%BA%8Eupdate%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84%E6%9F%90%E7%BB%86%E8%8A%82/","excerpt":"在使用update更新多条语句的时候不能使用and连接","text":"在使用update更新多条语句的时候不能使用and连接 首先先来看一个现象 这是表的原始数据： 这是执行语句： 1update test set id=2 and name='kyky' WHERE id=1; 可结果却和预期不同： 为什么吗？ 来看官方文档： assignment_list的格式是以逗号分隔的col_name=value列表 所以不能用and连接 1234update test set id=2 and name='kyky' WHERE id=1;--相当于以下语句update test set id= (2 and name='kyky') WHERE id=1;/*(2 and name='kyky')返回的是一个布尔值flase,子啊数据库中flase为0，所以原本改修改为2的id变成了0，而name不改变。*/","categories":[],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://kayuyu1.github.io/tags/Mysql/"}]},{"title":"为什么set不能存重复的值","slug":"为什么set不能存重复的值","date":"2020-04-25T06:34:54.000Z","updated":"2020-04-28T07:49:11.809Z","comments":true,"path":"2020/04/25/为什么set不能存重复的值/","link":"","permalink":"http://kayuyu1.github.io/2020/04/25/%E4%B8%BA%E4%BB%80%E4%B9%88set%E4%B8%8D%E8%83%BD%E5%AD%98%E9%87%8D%E5%A4%8D%E7%9A%84%E5%80%BC/","excerpt":"为什么set不能存储重复的值首先看一段代码","text":"为什么set不能存储重复的值首先看一段代码 123456789101112131415161718public class SetDemo &#123; public static void main(String[] args) &#123; Set set=new HashSet(); String str1=new String(\"abc\"); String str2=new String(\"abc\"); String str3=\"重地\"; String str4=\"通话\"; String str5=\"abc\"; set.add(str1); set.add(str2); set.add(str3); set.add(str4); set.add(str5); System.out.println(set); &#125; 原因： 补充：","categories":[],"tags":[{"name":"javase","slug":"javase","permalink":"http://kayuyu1.github.io/tags/javase/"}]},{"title":"线程与同步","slug":"线程与同步","date":"2020-04-25T02:27:35.000Z","updated":"2020-04-28T07:49:43.257Z","comments":true,"path":"2020/04/25/线程与同步/","link":"","permalink":"http://kayuyu1.github.io/2020/04/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5/","excerpt":"第一章 线程1. 1 多线程原理代码如下：","text":"第一章 线程1. 1 多线程原理代码如下： 自定义线程类：123456789101112131415161718public class MyThread extends Thread&#123;/** 利用继承中的特点* 将线程名称传递 进行设置*/public MyThread(String name)&#123;super(name);&#125;/** 重写run方法* 定义线程要执行的代码*/public void run()&#123;for (int i = 0 ; i &lt; 20 ; i++) &#123;//getName()方法 来自父亲 //getName()方法 来自父亲System.out.println(getName()+i);&#125;&#125;&#125; 测试类：12345678910public class Demo &#123;public static void main(String[] args) &#123;System.out.println(\"这里是main线程\");MyThread mt = new MyThread(\"小强\");mt.start();//开启了一个新的线程for (int i = 0 ; i &lt; 20 ; i++) &#123;System.out.println(\"旺财:\"+i);&#125;&#125;&#125; 流程图： 程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。 通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？我们再来讲一讲原理。 多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明： 多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。 当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。1. 2 Thread类在上一天内容中我们已经可以完成最基本的线程开启，那么在我们完成操作过程中用到了java.lang.Thread类，API中该类中定义了有关线程的一些方法，具体如下： 构造方法： 1234public Thread():分配一个新的线程对象。public Thread(String name):分配一个指定名字的新的线程对象。public Thread(Runnable target):分配一个带有指定目标新的线程对象。public Thread(Runnable target,String name):分配一个带有指定目标新的线程对象并指定名字。 常用方法： 12345public String getName():获取当前线程名称。public void start():导致此线程开始执行; Java虚拟机调用此线程的run方法。public void run():此线程要执行的任务在此处定义代码。public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。public static Thread currentThread():返回对当前正在执行的线程对象的引用。 翻阅API后得知创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式，方式一我们上一天已经完成，接下来讲解方式二实现的方式。 1. 3 创建线程方式二采用java.lang.Runnable也是非常常见的一种，我们只需要重写run方法即可。 步骤如下： 12341. 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。2. 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。3. 调用线程对象的start()方法来启动线程。 代码如下： 1234567891011121314151617181920public class MyRunnable implements Runnable&#123;@Overridepublic void run() &#123;for (int i = 0 ; i &lt; 20 ; i++) &#123;System.out.println(Thread.currentThread().getName()+\" \"+i);&#125;&#125;&#125;public class Demo &#123;public static void main(String[] args) &#123;//创建自定义类对象 线程任务对象MyRunnable mr = new MyRunnable();//创建线程对象Thread t = new Thread(mr, \"小强\");t.start();for (int i = 0 ; i &lt; 20 ; i++) &#123;System.out.println(\"旺财 \" + i);&#125;&#125;&#125; 通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。 在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。 实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。 12tips:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。 1. 4 Thread和Runnable的区别如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。 总结： 实现Runnable接口比继承Thread类所具有的优势： 12345671. 适合多个相同的程序代码的线程去共享同一个资源。2. 可以避免java中的单继承的局限性。3. 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。4. 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。扩充：在java中，每次程序运行至少启动 2 个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。 1. 5 匿名内部类方式实现线程的创建使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法： 1234567891011121314151617public^ class^ NoNameInnerClassThread^ &#123;public static void main(String[] args) &#123;// new Runnable()&#123;// public void run()&#123;// for (int i = 0 ; i &lt; 20 ; i++) &#123;// System.out.println(\"张宇:\"+i);// &#125;// &#125;// &#125;; //‐‐‐这个整体 相当于new MyRunnable()Runnable r = new Runnable()&#123;public void run()&#123;for (int i = 0 ; i &lt; 20 ; i++) &#123;System.out.println(\"张宇:\"+i);&#125;&#125;&#125;;new Thread(r).start(); 第二章 线程安全2. 1 线程安全如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。我们通过一个案例，演示线程的安全问题：电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “葫芦娃大战奥特曼”，本次电影的座位共 100 个(本场电影只能卖 100 张票)。我们来模拟电影院的售票窗口，实现多个窗口同时卖 “葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这 100 张票)需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟 模拟票： 12345678910111213141516171819202122232425262728293031for (int i = 0 ; i &lt; 20 ; i++) &#123;System.out.println(\"费玉清:\"+i);&#125;&#125;&#125;public class Ticket implements Runnable &#123;private int ticket = 100 ;/** 执行卖票操作*/@Overridepublic void run() &#123;//每个窗口卖票的操作//窗口 永远开启while (true) &#123;if (ticket &gt; 0 ) &#123;//有票 可以卖//出票操作//使用sleep模拟一下出票时间try &#123;Thread.sleep( 100 );&#125; catch (InterruptedException e) &#123;// TODO Auto‐generated catch blocke.printStackTrace();&#125;//获取当前线程对象的名字String name = Thread.currentThread().getName();System.out.println(name + \"正在卖:\" + ticket‐‐);&#125;&#125;&#125;&#125; 测试类：结果中有一部分这样现象： 发现程序出现了两个问题：1. 相同的票数,比如 5 这张票被卖了两回。2. 不存在的票，比如 0 票与- 1 票，是不存在的。这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。2. 2 线程同步当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制(synchronized)来解决。 根据案例简述： 为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。 那么怎么去使用呢？有三种方式完成同步操作： 1234567891011121314public class Demo &#123;public static void main(String[] args) &#123;//创建线程任务对象Ticket ticket = new Ticket();//创建三个窗口对象Thread t 1 = new Thread(ticket, \"窗口 1 \");Thread t 2 = new Thread(ticket, \"窗口 2 \");Thread t 3 = new Thread(ticket, \"窗口 3 \");//同时卖票t 1 .start();t 2 .start();t 3 .start();&#125;&#125; 窗口 1 线程进入操作的时候，窗口 2 和窗口 3 线程只能在外等着，窗口 1 操作结束，窗口 1 和窗口 2 和窗口 3 才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。1. 同步代码块。2. 同步方法。3. 锁机制。2. 3 同步代码块1同步代码块：synchronized关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 格式: 同步锁:对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.1. 锁对象 可以是任意类型。2. 多个线程对象 要使用同一把锁。注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。使用同步代码块解决代码：123456789101112131415161718192021222324252627282930synchronized(同步锁)&#123;需要同步操作的代码&#125;public class Ticket implements Runnable&#123;private int ticket = 100 ;Object lock = new Object();/** 执行卖票操作*/@Overridepublic void run() &#123;//每个窗口卖票的操作//窗口 永远开启while(true)&#123;synchronized (lock) &#123;if(ticket&gt; 0 )&#123;//有票 可以卖//出票操作//使用sleep模拟一下出票时间try &#123;Thread.sleep( 50 );&#125; catch (InterruptedException e) &#123;// TODO Auto‐generated catch blocke.printStackTrace();&#125;//获取当前线程对象的名字String name = Thread.currentThread().getName();System.out.println(name+\"正在卖:\"+ticket‐‐);&#125;&#125;&#125; 当使用了同步代码块后，上述的线程的安全问题，解决了。2. 4 同步方法12同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。 格式： 同步锁是谁?12对于非static方法,同步锁就是this。对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。 使用同步方法代码如下： 123456789101112131415161718192021222324252627282930public synchronized void method()&#123;可能会产生线程安全问题的代码&#125;public class Ticket implements Runnable&#123;private int ticket = 100 ;/** 执行卖票操作*/@Overridepublic void run() &#123;//每个窗口卖票的操作//窗口 永远开启while(true)&#123;sellTicket();&#125;&#125;/** 锁对象 是 谁调用这个方法 就是谁* 隐含 锁对象 就是 this**/public synchronized void sellTicket()&#123;if(ticket&gt; 0 )&#123;//有票 可以卖//出票操作//使用sleep模拟一下出票时间try &#123;Thread.sleep( 100 );&#125; catch (InterruptedException e) &#123;// TODO Auto‐generated catch blocke.printStackTrace(); 2. 5 Lock锁java.util.concurrent.locks.Lock机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。 Lock锁也称同步锁，加锁与释放锁方法化了，如下： 12public void lock():加同步锁。public void unlock():释放同步锁。 使用如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Ticket implements Runnable&#123; private int ticket = 100; Lock lock = new ReentrantLock(); /*\\* 执行卖票操作 */ @Override public void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while(true)&#123; lock.lock(); if(ticket&gt;0)&#123;//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123;Thread.sleep(50); &#125; catch (InterruptedException e) &#123; // TODO Auto‐generated catch block e.printStackTrace(); &#125;//获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name+\"正在卖:\"+ticket‐‐); &#125;lock.unlock(); &#125; &#125; &#125; 第三章 线程状态//获取当前线程对象的名字12345678910111213141516171819202122232425262728293031323334String name = Thread.currentThread().getName();System.out.println(name+\"正在卖:\"+ticket‐‐);&#125;&#125;&#125;public class Ticket implements Runnable&#123;private int ticket = 100 ;Lock lock = new ReentrantLock();/** 执行卖票操作*/@Overridepublic void run() &#123;//每个窗口卖票的操作//窗口 永远开启while(true)&#123;lock.lock();if(ticket&gt; 0 )&#123;//有票 可以卖//出票操作//使用sleep模拟一下出票时间try &#123;Thread.sleep( 50 );&#125; catch (InterruptedException e) &#123;// TODO Auto‐generated catch blocke.printStackTrace();&#125;//获取当前线程对象的名字String name = Thread.currentThread().getName();System.out.println(name+\"正在卖:\"+ticket‐‐);&#125;lock.unlock();&#125;&#125;&#125; 线程状态 导致状态发生条件123456789101112131415161718192021NEW(新建) 线程刚被创建，但是并未启动。还没调用start方法。Runnable(可运行)线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。Blocked(锁阻塞)当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。Waiting(无限等待)一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。TimedWaiting(计时等待)同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。Teminated(被终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。 3. 1 线程状态概述当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，有几种状态呢？在API中java.lang.Thread.State这个枚举中给出了六种线程状态： 这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析 我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几个状态呢，新建与被终止还是很容易理解的，我们就研究一下线程从Runnable（可运行）状态与非运行状态之间的转换问题。 3. 2 Timed Waiting（计时等待）Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？ 在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。 其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待)，那么我们通过一个案例加深对该状态的一个理解。 实现一个计数器，计数到 100 ，在每个数字之间暂停 1 秒，每隔 10 个数字输出一个字符串 代码： 12345678910111213141516171819public class MyThread extends Thread &#123;public void run() &#123;for (int i = 0 ; i &lt; 100 ; i++) &#123;if ((i) % 10 == 0 ) &#123;System.out.println(\"‐‐‐‐‐‐‐\" + i);&#125; System.out.print(i);try &#123;Thread.sleep( 1000 );System.out.print(\" 线程睡眠 1 秒！\\n\");&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;&#125;public static void main(String[] args) &#123;new MyThread().start();&#125;&#125; 通过案例可以发现，sleep方法的使用还是很简单的。我们需要记住下面几点： 12345671. 进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。2. 为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程中会睡眠3. sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。 Timed Waiting 线程状态图： 3. 3 BLOCKED（锁阻塞）Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。 我们已经学完同步机制，那么这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。 这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态，而这部分内容作为扩充知识点带领大家了解一下。 Blocked 线程状态图 3. 4 Waiting（无限等待）Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。 那么我们之前遇到过这种状态吗？答案是并没有，但并不妨碍我们进行一个简单深入的了解。我们通过一段代码来学习一下： 1234567891011public class WaitingTest &#123;public static Object obj = new Object();public static void main(String[] args) &#123;// 演示waitingnew Thread(new Runnable() &#123;@Overridepublic void run() &#123;while (true)&#123;synchronized (obj)&#123;try &#123;System.out.println( Thread.currentThread().getName() +\"=== 获取到锁对 通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的Object.notify()方法 或 Object.notifyAll()方法。 其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。 当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。 Waiting 线程状态图 1234567891011121314151617181920212223242526272829303132333435public class WaitingTest &#123; public static Object obj = new Object(); public static void main(String[] args) &#123; // 演示waiting new Thread(new Runnable() &#123; @Override public void run() &#123; while (true)&#123; synchronized (obj)&#123; try &#123;System.out.println( Thread.currentThread().getName() +\"=== 获取到锁对象，调用wait方法，进入waiting状态，释放锁对象\");obj.wait(); //无限等待//obj.wait( 5000 ); //计时等待, 5 秒 时间到，自动醒来&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;System.out.println( Thread.currentThread().getName() + \"=== 从waiting状态醒来，获取到锁对象，继续执行了\");&#125;&#125;&#125;&#125;,\"等待线程\").start();new Thread(new Runnable() &#123;@Overridepublic void run() &#123;// while (true)&#123; //每隔 3 秒 唤醒一次try &#123;System.out.println( Thread.currentThread().getName() +\"‐‐‐‐‐ 等待 3 秒钟\");Thread.sleep( 3000 );&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;synchronized (obj)&#123;System.out.println( Thread.currentThread().getName() +\"‐‐‐‐‐ 获取到锁对象,调用notify方法，释放锁对象\");obj.notify();&#125;&#125;// &#125;&#125;,\"唤醒线程\").start();&#125;&#125; 3. 5 补充知识点到此为止我们已经对线程状态有了基本的认识，想要有更多的了解，详情可以见下图： 一条有意思的tips: 我们在翻阅API的时候会发现Timed Waiting（计时等待） 与 Waiting（无限等待） 状态联系还是很紧密的，比如Waiting（无限等待） 状态中wait方法是空参的，而timed waiting（计时等待） 中wait方法是带参的。这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是如果提前得到（唤醒）通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两得。如果没有得到（唤醒）通知，那么线程就处于Timed Waiting状态,直到倒计时完毕自动醒来；如果在倒计时期间得到（唤醒）通知，那么线程从Timed Waiting状态立刻唤醒。","categories":[],"tags":[{"name":"javase","slug":"javase","permalink":"http://kayuyu1.github.io/tags/javase/"}]},{"title":"构造代码块与构造器执行顺序","slug":"构造代码块与构造器执行顺序","date":"2020-04-21T01:23:32.000Z","updated":"2020-04-28T07:50:05.120Z","comments":true,"path":"2020/04/21/构造代码块与构造器执行顺序/","link":"","permalink":"http://kayuyu1.github.io/2020/04/21/%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/","excerpt":"构造代码块与构造器执行顺序构造代码块：定义在类的成员位置，直接使用{ }，在{}中写代码内容。 位置：类中，方法外，和方法并列，和先后位置无关。 执行时机：创建对象的时候执行一次。在构造方法隐式3步的最后一步。当构造代码块执行结束之后，开始执行构造方法本身的代码内容","text":"构造代码块与构造器执行顺序构造代码块：定义在类的成员位置，直接使用{ }，在{}中写代码内容。 位置：类中，方法外，和方法并列，和先后位置无关。 执行时机：创建对象的时候执行一次。在构造方法隐式3步的最后一步。当构造代码块执行结束之后，开始执行构造方法本身的代码内容 格式： 123456public class ClassName&#123; // 构造代码块 &#123; // 执行语句 &#125;&#125; 构造代码块和构造方法执行顺序： 1234567891011121314151617181920212223242526272829303132333435363738class ConsCode&#123; // 成员变量 int a; int b;// 空参构造public ConsCode() &#123; //System.out.println(\"HelloWorld!\"); System.out.println(\"11我在构造代码块执行结束之后执行...\");&#125; // 给变量a赋值的构造public ConsCode(int a) &#123; this.a = a; System.out.println(\"22我在构造代码块执行结束之后执行...\"); //System.out.println(\"HelloWorld!\");&#125; // 给变量ab同时赋值的构造public ConsCode(int a , int b) &#123; this.a = a; this.b = b; //System.out.println(\"HelloWorld!\"); System.out.println(\"33我在构造代码块执行结束之后执行...\");&#125; // 构造代码块&#123; System.out.println(\"构造代码块!。。。。。。。。。。。。。。。\");&#125;&#125;public class ConstructorCodeDemo &#123; public static void main(String[] args) &#123; // 分别使用3个构造方法创建对象，并运行程序，显示执行3遍HelloWorld！ ConsCode c1 = new ConsCode(); ConsCode c2 = new ConsCode(10); ConsCode c3 = new ConsCode(10,20); &#125;&#125;","categories":[],"tags":[{"name":"javase","slug":"javase","permalink":"http://kayuyu1.github.io/tags/javase/"}]},{"title":"内部类","slug":"内部类","date":"2020-04-20T11:59:16.000Z","updated":"2020-05-22T04:27:56.552Z","comments":true,"path":"2020/04/20/内部类/","link":"","permalink":"http://kayuyu1.github.io/2020/04/20/%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"内部类总结1.普通内部类相当于外部类的一个成员变量，因此内部类可以直接访问外部类的成员，包括私有。","text":"内部类总结1.普通内部类相当于外部类的一个成员变量，因此内部类可以直接访问外部类的成员，包括私有。 12345678910111213141516 class Demo &#123; public static void main(String[] args) &#123; //外部类名.内部类名 = 外部类对象.内部类对象 Outer.Inner oi = new Outer().new Inner(); //创建内部类对象 oi.method(); &#125;&#125;class Outer &#123; private int num = 10; class Inner &#123; public void method() &#123; System.out.println(num); &#125; &#125;&#125; 2.内部类有静态方法那么内部类必须是静态的。 12345678910public class Outer &#123;private int num=10;class Inner&#123; public static void show()//报错原因 ：内部类不是静态的而方法是静态的 ，相当于盒子里有糖，但盒子却没有打开的方法（static的属性，从属于类） &#123; &#125;&#125;&#125; 3.局部变量必须加final修饰符。（随着方法运行完毕，局部变量会被释放，如果此时一个内部类还引用该变量则会报错。说到底就是变量的生命周期比内部类实例要短。而final保证这个变量始终指向一个对象，内部类就可以放心大胆地引用了。其实犯了和C++一样的毛病：返回了局部变量的引用）注意:在JDK8版本之中,方法内部类中调用方法中的局部变量,可以不需要修饰为 final,匿名内部类也是一样的，主要是JDK8之后增加了 Effectively final 功能\\ 123456789101112public class Outer &#123; public void show()&#123; int num =20; class Inner&#123; public void show() &#123; System.out.println(num); &#125; &#125;&#125;&#125; 4.面试题 1234567891011121314151617//要求：使用已知的变量，在控制台输出30，20，10。public class Outer &#123; private int num=10; public void show() &#123; public int num =20; class Inner&#123; int num=30; public void show() &#123; System.out.println(num); System.out.println(this.num); System.out.println(Outer.this.num); &#125; &#125;&#125;&#125;","categories":[],"tags":[{"name":"javase","slug":"javase","permalink":"http://kayuyu1.github.io/tags/javase/"}]},{"title":"Integer","slug":"Integer","date":"2020-04-19T08:27:36.000Z","updated":"2020-04-28T07:51:21.959Z","comments":true,"path":"2020/04/19/Integer/","link":"","permalink":"http://kayuyu1.github.io/2020/04/19/Integer/","excerpt":"Integer的某些特点","text":"Integer的某些特点 123456789101112131415161718192021222324@Testpublic void test6()&#123; int a=3; Integer b=3;//等于 Integer b=Integer.valueOf(3); Integer c=new Integer(3); Integer d=new Integer(3); //a在常量池 Integer会自动装箱拆箱 ==比较值 System.out.println(b.equals(a));//true System.out.println(a==b);//ture //两个new出来的对象不会拆箱，==比较的是地址值 System.out.println(c==d);//false System.out.println(\"============\"); Integer e=127; Integer f=127; Integer g=128; Integer h=128; System.out.println(e==f);//ture System.out.println(g==h);//flase&#125; 看一下源码大家都会明白，对于-128到127之间的数，会进行缓存，Integer e = 127时，会将127进行缓存，下次再写Integer f = 127时，就会直接从缓存中取，就不会new了。而大于127或者小于-128的值就会重新new。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;","categories":[],"tags":[{"name":"javase","slug":"javase","permalink":"http://kayuyu1.github.io/tags/javase/"}]},{"title":"jdk1.8不支持maven自带的tomcat6","slug":"jdk1-8不支持maven自带的tomcat6","date":"2020-04-17T09:51:57.000Z","updated":"2020-04-17T09:58:12.241Z","comments":true,"path":"2020/04/17/jdk1-8不支持maven自带的tomcat6/","link":"","permalink":"http://kayuyu1.github.io/2020/04/17/jdk1-8%E4%B8%8D%E6%94%AF%E6%8C%81maven%E8%87%AA%E5%B8%A6%E7%9A%84tomcat6/","excerpt":"又被坑了啊","text":"又被坑了啊 原因：我的maven所自带tomcat版本为6，jdk1.8不支持。 解决：在pom文件中加入以下代码 12345678910&lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;path&gt;/bos&lt;/path&gt; &lt;port&gt;8888&lt;/port&gt; &lt;/configuration&gt;&lt;/plugin&gt; 注意：这段代码是下载tomcat7插件，所以启动的时候要用tomcat7：run命令","categories":[],"tags":[{"name":"maven","slug":"maven","permalink":"http://kayuyu1.github.io/tags/maven/"}]},{"title":"redis","slug":"redis","date":"2020-04-17T04:07:10.000Z","updated":"2020-04-27T14:05:10.076Z","comments":true,"path":"2020/04/17/redis/","link":"","permalink":"http://kayuyu1.github.io/2020/04/17/redis/","excerpt":"Redis1.概念： redis是一款高性能的NOSQL系列的非关系型数据库","text":"Redis1.概念： redis是一款高性能的NOSQL系列的非关系型数据库 1.1.什么是NOSQL​ NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。​ 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1. NOSQL和关系型数据库比较​ 优点：​ 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。​ 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。​ 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。​ 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 ​ 缺点：​ 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。​ 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。​ 3）不提供关系型数据库对事务的处理。 1.1.2. 非关系型数据库的优势：​ 1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。​ 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 1.1.3. 关系型数据库的优势：​ 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。​ 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 1.1.4. 总结​ 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，​ 让NoSQL数据库对关系型数据库的不足进行弥补。​ 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 1.2.主流的NOSQL产品​ • 键值(Key-Value)存储数据库​ 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB​ 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。​ 数据模型： 一系列键值对​ 优势： 快速查询​ 劣势： 存储的数据缺少结构化​ • 列存储数据库​ 相关产品：Cassandra, HBase, Riak​ 典型应用：分布式的文件系统​ 数据模型：以列簇式存储，将同一列数据存在一起​ 优势：查找速度快，可扩展性强，更容易进行分布式扩展​ 劣势：功能相对局限​ • 文档型数据库​ 相关产品：CouchDB、MongoDB​ 典型应用：Web应用（与Key-Value类似，Value是结构化的）​ 数据模型： 一系列键值对​ 优势：数据结构要求不严格​ 劣势： 查询性能不高，而且缺乏统一的查询语法​ • 图形(Graph)数据库​ 相关数据库：Neo4J、InfoGrid、Infinite Graph​ 典型应用：社交网络​ 数据模型：图结构​ 优势：利用图结构相关算法。​ 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 1.3 什么是Redis​ Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：​ 1) 字符串类型 string​ 2) 哈希类型 hash​ 3) 列表类型 list​ 4) 集合类型 set​ 5) 有序集合类型 sortedset 1.3.1 redis的应用场景​ • 缓存（数据查询、短连接、新闻内容、商品内容等等）​ • 聊天室的在线好友列表​ • 任务队列。（秒杀、抢购、12306等等）​ • 应用排行榜​ • 网站访问统计​ • 数据过期处理（可以精确到毫秒​ • 分布式集群架构中的session分离 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869702. 下载安装 1. 官网：https://redis.io 2. 中文网：http://www.redis.net.cn/ 3. 解压直接可以使用： * redis.windows.conf：配置文件 * redis-cli.exe：redis的客户端 * redis-server.exe：redis服务器端 3. 命令操作 1. redis的数据结构： * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 * value的数据结构： 1) 字符串类型 string 2) 哈希类型 hash ： map格式 3) 列表类型 list ： linkedlist格式。支持重复元素 4) 集合类型 set ： 不允许重复元素 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 2. 字符串类型 string 1. 存储： set key value 127.0.0.1:6379&gt; set username zhangsan OK 2. 获取： get key 127.0.0.1:6379&gt; get username \"zhangsan\" 3. 删除： del key 127.0.0.1:6379&gt; del age (integer) 1 3. 哈希类型 hash 1. 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 2. 获取： * hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username \"lisi\" * hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) \"username\" 2) \"lisi\" 3) \"password\" 4) \"123\" 3. 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 1. 添加： 1. lpush key value: 将元素加入列表左表 2. rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： * lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) \"b\" 2) \"a\" 3) \"c\" 3. 删除： * lpop key： 删除列表最左边的元素，并将元素返回 * rpop key： 删除列表最右边的元素，并将元素返回 1234567891011121314151617181920212223242526272829303132333435363738394041425. 集合类型 set ： 不允许重复元素 1. 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) \"a\" 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 16. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 1. 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 2. 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) \"lisi\" 2) \"zhangsan\" 3) \"wangwu\" 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) \"zhangsan\" 2) \"60\" 3) \"wangwu\" 4) \"80\" 5) \"lisi\" 6) \"500\" 3. 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 17. 通用命令 1. keys * : 查询所有的键 2. type key ： 获取键对应的value的类型 3. del key：删除指定的key value 12345678910111213141516171819202122232425262728293031323334354. 持久化 1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 2. redis持久化机制： 1. RDB：默认方式，不需要进行配置，默认就使用这种机制 * 在一定的间隔时间中，检测key的变化情况，然后持久化数据 1. 编辑redis.windwos.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 2. 重新启动redis服务器，并指定配置文件名称 D:\\JavaWeb2018\\day23_redis\\资料\\redis\\windows-64\\redis-2.8.9&gt;redis-server.exe redis.windows.conf 2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化5. Java客户端 Jedis * Jedis: 一款java操作redis数据库的工具. * 使用步骤： 1. 下载jedis的jar包 2. 使用 //1. 获取连接 Jedis jedis = new Jedis(\"localhost\",6379); //2. 操作 jedis.set(\"username\",\"zhangsan\"); //3. 关闭连接 jedis.close(); 1234567891011121314151617181920212223242526272829303132333435* Jedis操作各种redis中的数据结构 1) 字符串类型 string set get //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 //存储 jedis.set(\"username\",\"zhangsan\"); //获取 String username = jedis.get(\"username\"); System.out.println(username); //可以使用setex()方法存储可以指定过期时间的 key value jedis.setex(\"activecode\",20,\"hehe\");//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对 //3. 关闭连接 jedis.close(); 2) 哈希类型 hash ： map格式 hset hget hgetAll //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 // 存储hash jedis.hset(\"user\",\"name\",\"lisi\"); jedis.hset(\"user\",\"age\",\"23\"); jedis.hset(\"user\",\"gender\",\"female\"); // 获取hash String name = jedis.hget(\"user\", \"name\"); System.out.println(name); 12345678910111213// 获取hash的所有map中的数据Map&lt;String, String&gt; user = jedis.hgetAll(\"user\"); // keysetSet&lt;String&gt; keySet = user.keySet();for (String key : keySet) &#123; //获取value String value = user.get(key); System.out.println(key + \":\" + value);&#125; //3. 关闭连接jedis.close(); 12345678910111213141516171819202122232425262728293) 列表类型 list ： linkedlist格式。支持重复元素 lpush / rpush lpop / rpop lrange start end : 范围获取 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 // list 存储 jedis.lpush(\"mylist\",\"a\",\"b\",\"c\");//从左边存 jedis.rpush(\"mylist\",\"a\",\"b\",\"c\");//从右边存 // list 范围获取 List&lt;String&gt; mylist = jedis.lrange(\"mylist\", 0, -1); System.out.println(mylist); // list 弹出 String element1 = jedis.lpop(\"mylist\");//c System.out.println(element1); String element2 = jedis.rpop(\"mylist\");//c System.out.println(element2); // list 范围获取 List&lt;String&gt; mylist2 = jedis.lrange(\"mylist\", 0, -1); System.out.println(mylist2); //3. 关闭连接 jedis.close(); 12345674) 集合类型 set ： 不允许重复元素 sadd smembers:获取所有元素 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 123456789101112131415161718192021222324252627 // set 存储 jedis.sadd(\"myset\",\"java\",\"php\",\"c++\"); // set 获取 Set&lt;String&gt; myset = jedis.smembers(\"myset\"); System.out.println(myset); //3. 关闭连接 jedis.close();5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 zadd zrange //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 // sortedset 存储 jedis.zadd(\"mysortedset\",3,\"亚瑟\"); jedis.zadd(\"mysortedset\",30,\"后裔\"); jedis.zadd(\"mysortedset\",55,\"孙悟空\"); // sortedset 获取 Set&lt;String&gt; mysortedset = jedis.zrange(\"mysortedset\", 0, -1); System.out.println(mysortedset); //3. 关闭连接 jedis.close(); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 * jedis连接池： JedisPool * 使用： 1. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 //0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,\"localhost\",6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set(\"hehe\",\"heihei\");//4. 关闭 归还到连接池中 jedis.close(); * 连接池工具类 public class JedisPoolUtils &#123; private static JedisPool jedisPool; static&#123; //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(\"jedis.properties\"); //创建Properties对象 Properties pro = new Properties(); //关联文件 try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(\"maxTotal\"))); config.setMaxIdle(Integer.parseInt(pro.getProperty(\"maxIdle\"))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty(\"host\"),Integer.parseInt(pro.getProperty(\"port\"))); &#125; /** * 获取连接方法 */ public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125; &#125; 注意：使用redis缓存一些不经常发生变化的数据。 数据库的数据一旦发生改变，则需要更新缓存。 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入 在service对应的增删改方法中，将redis数据删除。 ​","categories":[],"tags":[{"name":"reids","slug":"reids","permalink":"http://kayuyu1.github.io/tags/reids/"}]},{"title":"Jquery中.value与.val的区别","slug":"Jquery中-value与-val()的区别","date":"2020-04-16T02:58:46.000Z","updated":"2020-04-16T03:12:59.252Z","comments":true,"path":"2020/04/16/Jquery中-value与-val()的区别/","link":"","permalink":"http://kayuyu1.github.io/2020/04/16/Jquery%E4%B8%AD-value%E4%B8%8E-val()%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"今天被这个坑了一上午，人傻了Juqery中.val()与.value之间的区别","text":"今天被这个坑了一上午，人傻了Juqery中.val()与.value之间的区别 先说理论：.val()方法，一个是带参：给输入框赋值，一个是不参数的方法：获取输入框的值.value：获取Dom标签元素的value值，属于原生态JavaScript的写法 1&lt;input type=\"text\" id=\"username\" name=\"username\" placeholder=\"请输入用户名\" &gt; 1234567$(\"#username\").blur(function () &#123; var username = $(this).val(); alert(username) &#125;); 1234567$(\"#username\").blur(function () &#123; var username = $(this).value; alert(username)&#125;); 因为在input中没有定义value值所以获取出来的是undefined","categories":[],"tags":[{"name":"Jquery","slug":"Jquery","permalink":"http://kayuyu1.github.io/tags/Jquery/"}]},{"title":"Filter","slug":"Filter","date":"2020-04-14T01:16:39.000Z","updated":"2020-04-16T06:41:11.338Z","comments":true,"path":"2020/04/14/Filter/","link":"","permalink":"http://kayuyu1.github.io/2020/04/14/Filter/","excerpt":"内容1.Filter：过滤器 2.Listener：监听器","text":"内容1.Filter：过滤器 2.Listener：监听器 Filter：过滤器1234567891011121314151617181920212223241. 概念： * 生活中的过滤器：净水器,空气净化器，土匪、 * web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。 * 过滤器的作用： * 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤...2. 快速入门： 1. 步骤： 1. 定义一个类，实现接口Filter 2. 复写方法 3. 配置拦截路径 1. web.xml 2. 注解 2. 代码： @WebFilter(\"/*\")//访问所有资源之前，都会执行该过滤器 public class FilterDemo1 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(\"filterDemo1被执行了....\"); ​ 12345678910 //放行 filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253543. 过滤器细节： 1. web.xml配置 &lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2. 过滤器执行流程 1. 执行过滤器 2. 执行放行后的资源 3. 回来执行过滤器放行代码下边的代码 3. 过滤器生命周期方法 1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 2. doFilter:每一次请求被拦截资源时，会执行。执行多次 3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源 4. 过滤器配置详解 * 拦截路径配置： 1. 具体资源路径： /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 2. 拦截目录： /user/* /访问/user下的所有资源时，过滤器都会被执行 3. 后缀名拦截： *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 4. 拦截所有资源：/* 访问所有资源时，过滤器都会被执行 * 拦截方式配置：资源被访问的方式 * 注解配置： * 设置dispatcherTypes属性 1. REQUEST：默认值。浏览器直接请求资源 2. FORWARD：转发访问资源 3. INCLUDE：包含访问资源 4. ERROR：错误跳转资源 5. ASYNC：异步访问资源 * web.xml配置 * 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可 5. 过滤器链(配置多个过滤器) * 执行顺序：如果有两个过滤器：过滤器1和过滤器2 1. 过滤器1 2. 过滤器2 3. 资源执行 4. 过滤器2 5. 过滤器1 * 过滤器先后顺序问题： 1. 注解配置：按照类名的字符串比较规则比较，值小的先执行 * 如： AFilter 和 BFilter，AFilter就先执行了。 2. web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行4. 案例： 1. 案例1_登录验证 * 需求： 1. 访问day17_case案例的资源。验证其是否登录 2. 如果登录了，则直接放行。 3. 如果没有登录，则跳转到登录页面，提示\"您尚未登录，请先登录\"。 ​ 1234567892. 案例2_敏感词汇过滤 * 需求： 1. 对day17_case案例录入的数据进行敏感词汇过滤 2. 敏感词汇参考《敏感词汇.txt》 3. 如果是敏感词汇，替换为 *** * 分析： 1. 对request对象进行增强。增强获取参数相关方法 2. 放行。传递代理对象 123456789101112131415161718192021* 增强对象的功能： * 设计模式：一些通用的解决固定问题的方式 1. 装饰模式 2. 代理模式 * 概念： 1. 真实对象：被代理的对象 2. 代理对象： 3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的 * 实现方式： 1. 静态代理：有一个类文件描述代理模式 2. 动态代理：在内存中形成代理类 * 实现步骤： 1. 代理对象和真实对象实现相同的接口 2. 代理对象 = Proxy.newProxyInstance(); 3. 使用代理对象调用方法。 4. 增强方法 * 增强方式： 1. 增强参数列表 2. 增强返回值类型 3. 增强方法体执行逻辑 Listener：监听器123456* 概念：web的三大组件之一。 * 事件监听机制 * 事件 ：一件事情 * 事件源 ：事件发生的地方 * 监听器 ：一个对象 * 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码 1234567891011* ServletContextListener:监听ServletContext对象的创建和销毁 * 方法： * void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法 * void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法 * 步骤： 1. 定义一个类，实现ServletContextListener接口 2. 复写方法 3. 配置 1. web.xml &lt;listener&gt; &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;123 * 指定初始化参数&lt;context-param&gt;2. 注解： * @WebListener F","categories":[],"tags":[{"name":"javaee","slug":"javaee","permalink":"http://kayuyu1.github.io/tags/javaee/"}]},{"title":"异常与线程","slug":"异常与线程","date":"2020-04-12T01:12:25.000Z","updated":"2020-04-12T01:29:25.058Z","comments":true,"path":"2020/04/12/异常与线程/","link":"","permalink":"http://kayuyu1.github.io/2020/04/12/%E5%BC%82%E5%B8%B8%E4%B8%8E%E7%BA%BF%E7%A8%8B/","excerpt":"主要内容 异常、线程","text":"主要内容 异常、线程 教学目标 能够辨别程序中异常和错误的区别 说出异常的分类 说出虚拟机处理异常的方式 列举出常见的三个运行期异常 能够使用try…catch关键字处理异常 能够使用throws关键字处理异常 能够自定义异常类 能够处理自定义异常类 说出进程的概念 说出线程的概念 能够理解并发与并行的区别 能够开启新线程 第一章 异常1.1 异常概念异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是： 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 1.2 异常体系异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。 Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。 提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。 1.3 异常分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。 异常(Exception)的分类:根据在编译时期还是运行时期去检查异常? 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) ​ 1.4 异常的产生过程解析先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。 工具类 1234567public class ArrayTools &#123; // 对给定的数组通过给定的角标获取元素。 public static int getElement(int[] arr, int index) &#123; int element = arr[index]; return element; &#125;&#125; 测试类 12345678public class ExceptionDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123; 34, 12, 67 &#125;; intnum = ArrayTools.getElement(arr, 4) System.out.println(\"num=\" + num); System.out.println(\"over\"); &#125;&#125; 上述程序执行过程图解： 第二章 异常的处理Java异常处理的五个关键字：try、catch、finally、throw、throws 2.1 抛出异常throw在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。 在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？ 创建一个异常对象。封装一些提示信息(信息可以自己编写)。 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。 throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 使用格式： 1throw new 异常类名(参数); 例如： 123throw new NullPointerException(\"要访问的arr数组不存在\");throw new ArrayIndexOutOfBoundsException(\"该索引在数组中不存在，已超出范围\"); 学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。 123456789101112131415161718192021222324252627public class ThrowDemo &#123; public static void main(String[] args) &#123; //创建一个数组 int[] arr = &#123;2,4,52,2&#125;; //根据索引找对应的元素 int index = 4; int element = getElement(arr, index); System.out.println(element); System.out.println(\"over\"); &#125; /* * 根据 索引找到数组中对应的元素 */ public static int getElement(int[] arr,int index)&#123; //判断 索引是否越界 if(index&lt;0 || index&gt;arr.length-1)&#123; /* 判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。 这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 */ throw new ArrayIndexOutOfBoundsException(\"哥们，角标越界了~~~\"); &#125; int element = arr[index]; return element; &#125;&#125; 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。 2.2 Objects非空判断还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。 public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象不是null。 查看源码发现这里对为null的进行了抛出异常操作： 12345public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 2.3 声明异常throws声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。 关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常). 声明异常格式： 1修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125; 声明异常的代码演示： 12345678910111213public class ThrowsDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; read(\"a.txt\"); &#125; // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明 public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。 123456789101112131415public class ThrowsDemo2 &#123; public static void main(String[] args) throws IOException &#123; read(\"a.txt\"); &#125; public static void read(String path)throws FileNotFoundException, IOException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; if (!path.equals(\"b.txt\")) &#123; throw new IOException(); &#125; &#125;&#125; 2.4 捕获异常try…catch如果异常出现的话,会立刻终止程序,所以我们得处理异常: 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。 在方法中使用try-catch的语句块来处理异常。 try-catch的方式就是捕获异常。 捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 捕获异常语法如下： 123456try&#123; 编写可能会出现异常的代码&#125;catch(异常类型 e)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; try：该代码块中编写可能产生异常的代码。 catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。 注意:try和catch都不能单独使用,必须连用。 演示如下： 123456789101112131415161718192021public class TryCatchDemo &#123; public static void main(String[] args) &#123; try &#123;// 当产生异常时，必须有处理方式。要么捕获，要么声明。 read(\"b.txt\"); &#125; catch (FileNotFoundException e) &#123;// 括号中需要定义什么呢？ //try中抛出的是什么异常，在括号中就定义什么异常类型 System.out.println(e); &#125; System.out.println(\"over\"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; 如何获取异常信息： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。 ​ 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 2.4 finally 代码块finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。 什么时候的代码必须最终执行？ 当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。 finally的语法: try…catch….finally:自身需要处理异常,最终还得关闭资源。 注意:finally不能单独使用。 比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。 finally代码参考如下： 1234567891011121314151617181920212223public class TryCatchDemo4 &#123; public static void main(String[] args) &#123; try &#123; read(\"a.txt\"); &#125; catch (FileNotFoundException e) &#123; //抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); &#125; finally &#123; System.out.println(\"不管程序怎样，这里都将会被执行。\"); &#125; System.out.println(\"over\"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。 2.5 异常注意事项 多个异常使用捕获又该如何处理呢？ 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 一般我们是使用一次捕获多次处理方式，格式如下： 123456789try&#123; 编写可能会出现异常的代码&#125;catch(异常类型A e)&#123; 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125;catch(异常类型B e)&#123; 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果finally有return语句,永远返回finally中的结果,避免该情况. 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出 第三章 自定义异常3.1 概述为什么需要自定义异常类: 我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。 在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？ 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类. 自定义一个业务逻辑异常: RegisterException。一个注册异常类。 异常类如何定义: 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException。 3.2 自定义异常的练习要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 首先定义一个登陆异常类RegisterException： 12345678910111213141516// 业务逻辑异常public class RegisterException extends Exception &#123; /** * 空参构造 */ public RegisterException() &#123; &#125; /** * * @param message 表示异常提示 */ public RegisterException(String message) &#123; super(message); &#125;&#125; 模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。 123456789101112131415161718192021222324252627public class Demo &#123; // 模拟数据库中已存在账号 private static String[] names = &#123;\"bill\",\"hill\",\"jill\"&#125;; public static void main(String[] args) &#123; //调用方法 try&#123; // 可能出现异常的代码 checkUsername(\"nill\"); System.out.println(\"注册成功\");//如果没有异常就是注册成功 &#125;catch(RegisterException e)&#123; //处理异常 e.printStackTrace(); &#125; &#125; //判断当前注册账号是否存在 //因为是编译期异常，又想调用者去处理 所以声明该异常 public static boolean checkUsername(String uname) throws LoginException&#123; for (String name : names) &#123; if(name.equals(uname))&#123;//如果名字在这里面 就抛出登陆异常 throw new RegisterException(\"亲\"+name+\"已经被注册了！\"); &#125; &#125; return true; &#125;&#125; 第四章 多线程我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？ 要解决上述问题,咱们得使用多进程或者多线程来解决. 4.1 并发与并行 并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。 在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。 而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。 4.2 线程与进程 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程： 进程 线程 线程调度: 分时调度 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 抢占式调度 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 设置线程的优先级 抢占式调度详解 大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。 实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。 4.3 创建线程类Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来创建并启动多线程的步骤如下： 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程 代码如下： 测试类： 123456789101112public class Demo01 &#123; public static void main(String[] args) &#123; //创建自定义线程对象 MyThread mt = new MyThread(\"新的线程！\"); //开启新线程 mt.start(); //在主方法中执行for循环 for (int i = 0; i &lt; 10; i++) &#123; System.out.println(\"main线程！\"+i); &#125; &#125;&#125; 自定义线程类： 12345678910111213141516public class MyThread extends Thread &#123; //定义指定线程名称的构造方法 public MyThread(String name) &#123; //调用父类的String参数的构造方法，指定线程的名称 super(name); &#125; /** * 重写run方法，完成该线程执行的逻辑 */ @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(getName()+\"：正在执行！\"+i); &#125; &#125;&#125;","categories":[],"tags":[{"name":"javase","slug":"javase","permalink":"http://kayuyu1.github.io/tags/javase/"}]},{"title":"CookieSession","slug":"CookieSession","date":"2020-04-10T15:42:09.000Z","updated":"2020-04-10T15:58:00.388Z","comments":true,"path":"2020/04/10/CookieSession/","link":"","permalink":"http://kayuyu1.github.io/2020/04/10/CookieSession/","excerpt":"内容1.Cookie 2.Session","text":"内容1.Cookie 2.Session 会话技术1234561. 会话：一次会话中包含多次请求和响应。 * 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止2. 功能：在一次会话的范围内的多次请求间，共享数据3. 方式： 1. 客户端会话技术：Cookie 2. 服务器端会话技术：Session Cookie： 123456789101. 概念：客户端会话技术，将数据保存到客户端2. 快速入门： * 使用步骤： 1. 创建Cookie对象，绑定数据 * new Cookie(String name, String value) 2. 发送Cookie对象 * response.addCookie(Cookie cookie) 3. 获取Cookie，拿到数据 * Cookie[] request.getCookies() 1234567891011121314151617181920212223243. 实现原理 * 基于响应头set-cookie和请求头cookie实现4. cookie的细节 1. 一次可不可以发送多个cookie? * 可以 * 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 2. cookie在浏览器中保存多长时间？ 1. 默认情况下，当浏览器关闭后，Cookie数据被销毁 2. 持久化存储： * setMaxAge(int seconds) 1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 2. 负数：默认值 3. 零：删除cookie信息 3. cookie能不能存中文？ * 在tomcat 8 之前 cookie中不能直接存储中文数据。 * 需要将中文数据转码---一般采用URL编码(%E3) * 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 4. cookie共享问题？ 1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ * 默认情况下cookie不能共享 * setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录 * 如果要共享，则可以将path设置为\"/\" ​ 1232. 不同的tomcat服务器间cookie共享问题？ * setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 * setDomain(\".baidu.com\"),那么tieba.baidu.com和news.baidu.com中cookie可以共享 123456789101112131415161718192021222324252627282930313233343536375. Cookie的特点和作用 1. cookie存储数据在客户端浏览器 2. 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) * 作用： 1. cookie一般用于存出少量的不太敏感的数据 2. 在不登录的情况下，完成服务器对客户端的身份识别6. 案例：记住上一次访问时间 1. 需求： 1. 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。 2. 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串 2. 分析： 1. 可以采用Cookie来完成 2. 在服务器中的Servlet判断是否有一个名为lastTime的cookie 1. 有：不是第一次访问 1. 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20 2. 写回Cookie：lastTime=2018年6月10日11:50:01 2. 没有：是第一次访问 1. 响应数据：您好，欢迎您首次访问 2. 写回Cookie：lastTime=2018年6月10日11:50:01 3. 代码实现： package cn.itcast.cookie; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.net.URLDecoder; import java.net.URLEncoder; import java.text.SimpleDateFormat; import java.util.Date; 123456789101112131415161718192021222324252627282930313233@WebServlet(\"/cookieTest\")public class CookieTest extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //设置响应的消息体的数据格式以及编码 response.setContentType(\"text/html;charset=utf-8\"); //1.获取所有Cookie Cookie[] cookies = request.getCookies(); boolean flag = false;//没有cookie为lastTime //2.遍历cookie数组 if(cookies != null &amp;&amp; cookies.length &gt; 0)&#123; for (Cookie cookie : cookies) &#123; //3.获取cookie的名称 String name = cookie.getName(); //4.判断名称是否是：lastTime if(\"lastTime\".equals(name))&#123; //有该Cookie，不是第一次访问 flag = true;//有lastTime的cookie //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); String str_date = sdf.format(date); System.out.println(\"编码前：\"+str_date); //URL编码 str_date = URLEncoder.encode(str_date,\"utf-8\"); System.out.println(\"编码后：\"+str_date); cookie.setValue(str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); ​ 1234567891011121314 //响应数据 //获取Cookie的value，时间 String value = cookie.getValue(); System.out.println(\"解码前：\"+value); //URL解码： value = URLDecoder.decode(value,\"utf-8\"); System.out.println(\"解码后：\"+value); response.getWriter().write(\"&lt;h1&gt;欢迎回来，您上次访问时间为:\"+value+\"&lt;/h1&gt;\"); break; &#125; &#125;&#125; ​ 1234567891011121314151617181920if(cookies == null || cookies.length == 0 || flag == false)&#123; //没有，第一次访问 //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); String str_date = sdf.format(date); System.out.println(\"编码前：\"+str_date); //URL编码 str_date = URLEncoder.encode(str_date,\"utf-8\"); System.out.println(\"编码后：\"+str_date); Cookie cookie = new Cookie(\"lastTime\",str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); response.getWriter().write(\"&lt;h1&gt;您好，欢迎您首次访问&lt;/h1&gt;\");&#125; ​ 123456 &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; Cookie案例记住上次访问时间： Session：主菜 12345678910111. 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession2. 快速入门： 1. 获取HttpSession对象： HttpSession session = request.getSession(); 2. 使用HttpSession对象： Object getAttribute(String name) void setAttribute(String name, Object value) void removeAttribute(String name) 3. 原理 * Session的实现是依赖于Cookie的。 ​ 12345678910111213141516171819202122232425262728293031324. 细节： 1. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？ * 默认情况下。不是。 * 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 Cookie c = new Cookie(\"JSESSIONID\",session.getId()); c.setMaxAge(60*60); response.addCookie(c); 2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ * 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 * session的钝化： * 在服务器正常关闭之前，将session对象系列化到硬盘上 * session的活化： * 在服务器启动后，将session文件转化为内存中的session对象即可。 3. session什么时候被销毁？ 1. 服务器关闭 2. session对象调用invalidate() 。 3. session默认失效时间 30分钟 选择性配置修改 &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; 5. session的特点 1. session用于存储一次会话的多次请求的数据，存在服务器端 2. session可以存储任意类型，任意大小的数据 * session与Cookie的区别： 1. session存储数据在服务器端，Cookie在客户端 2. session没有数据大小限制，Cookie有 3. session数据安全，Cookie相对于不安全 案例：验证码1. 案例需求： 1. 访问带有验证码的登录页面login.jsp 2. 用户输入用户名，密码以及验证码。 * 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误 * 如果验证码输入有误，跳转登录页面，提示：验证码错误 * 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您 分析： ​","categories":[],"tags":[{"name":"javaee","slug":"javaee","permalink":"http://kayuyu1.github.io/tags/javaee/"}]},{"title":"Response介绍","slug":"Response介绍","date":"2020-04-10T01:30:16.000Z","updated":"2020-04-10T02:00:49.273Z","comments":true,"path":"2020/04/10/Response介绍/","link":"","permalink":"http://kayuyu1.github.io/2020/04/10/Response%E4%BB%8B%E7%BB%8D/","excerpt":"内容1.HTTP协议：响应消息 2.Response对象 3.ServletContext对象","text":"内容1.HTTP协议：响应消息 2.Response对象 3.ServletContext对象 HTTP协议：1234567891011121314151617181920211. 请求消息：客户端发送给服务器端的数据 * 数据格式： 1. 请求行 2. 请求头 3. 请求空行 4. 请求体2. 响应消息：服务器端发送给客户端的数据 * 数据格式： 1. 响应行 1. 组成：协议/版本 响应状态码 状态码描述 2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 1. 状态码都是3位数字 2. 分类： 1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2. 2xx：成功。代表：200 3. 3xx：重定向。代表：302(重定向)，304(访问缓存) 4. 4xx：客户端错误。 * 代表： * 404（请求路径没有对应的资源） * 405：请求方式没有对应的doXxx方法 5. 5xx：服务器端错误。代表：500(服务器内部出现异常) ​ 123456789102. 响应头： 1. 格式：头名称： 值 2. 常见的响应头： 1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据 * 值： * in-line:默认值,在当前页面内打开 * attachment;filename=xxx：以附件形式打开响应体。文件下载3. 响应空行4. 响应体:传输的数据 1234567891011121314* 响应字符串格式 HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 101 Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt; Response对象 1234567891011121314* 功能：设置响应消息 1. 设置响应行 1. 格式：HTTP/1.1 200 ok 2. 设置状态码：setStatus(int sc) 2. 设置响应头：setHeader(String name, String value) 3. 设置响应体： * 使用步骤： 1. 获取输出流 * 字符输出流：PrintWriter getWriter() * 字节输出流：ServletOutputStream getOutputStream() 2. 使用输出流，将数据输出到客户端浏览器 12345678* 案例： 1. 完成重定向 * 重定向：资源跳转的方式 * 代码实现： //1. 设置状态码为302 response.setStatus(302); //2.设置响应头location response.setHeader(\"location\",\"/day15/responseDemo2\"); 123456789101112131415161718192021222324252627282930313233 //简单的重定向方法 response.sendRedirect(\"/day15/responseDemo2\");* 重定向的特点:redirect 1. 地址栏发生变化 2. 重定向可以访问其他站点(服务器)的资源 3. 重定向是两次请求。不能使用request对象来共享数据* 转发的特点：forward 1. 转发地址栏路径不变 2. 转发只能访问当前服务器下的资源 3. 转发是一次请求，可以使用request对象来共享数据* forward 和 redirect 区别 * 路径写法： 1. 路径分类 1. 相对路径：通过相对路径不可以确定唯一资源 * 如：./index.html * 不以/开头，以.开头路径 * 规则：找到当前资源和目标资源之间的相对位置关系 * ./：当前目录 * ../:后退一级目录 2. 绝对路径：通过绝对路径可以确定唯一资源 * 如：http://localhost/day15/responseDemo2 /day15/responseDemo2 * 以/开头的路径 * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出 * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) * 建议虚拟目录动态获取：request.getContextPath() * &lt;a&gt; , &lt;form&gt; 重定向... * 给服务器使用：不需要加虚拟目录 * 转发路径 ​​ 1234567891011121314151617181920212. 服务器输出字符数据到浏览器 * 步骤： 1. 获取字符输出流 2. 输出数据 * 注意： * 乱码问题： 1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 2. 设置该流的默认编码 3. 告诉浏览器响应体使用的编码 //简单的形式，设置编码，是在获取流之前设置 response.setContentType(\"text/html;charset=utf-8\");3. 服务器输出字节数据到浏览器 * 步骤： 1. 获取字节输出流 2. 输出数据4. 验证码 1. 本质：图片 2. 目的：防止恶意表单注册 ServletContext对象：123456789101112131415161718192021222324252627281. 概念：代表整个web应用，可以和程序的容器(服务器)来通信2. 获取： 1. 通过request对象获取 request.getServletContext(); 2. 通过HttpServlet获取 this.getServletContext();3. 功能： 1. 获取MIME类型： * MIME类型:在互联网通信过程中定义的一种文件数据类型 * 格式： 大类型/小类型 text/html image/jpeg * 获取：String getMimeType(String file) 2. 域对象：共享数据 1. setAttribute(String name,Object value) 2. getAttribute(String name) 3. removeAttribute(String name) * ServletContext对象范围：所有用户所有请求的数据 3. 获取文件的真实(服务器)路径 1. 方法：String getRealPath(String path) String b = context.getRealPath(\"/b.txt\");//web目录下资源访问 System.out.println(b); String c = context.getRealPath(\"/WEB-INF/c.txt\");//WEB-INF目录下的资源访问 System.out.println(c); String a = context.getRealPath(\"/WEB-INF/classes/a.txt\");//src目录下的资源访问 System.out.println(a); 案例：* 文件下载需求： 1. 页面显示超链接 2. 点击超链接后弹出下载提示框 3. 完成图片文件下载 * 分析： 1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求 2. 任何资源都必须弹出下载提示框 3. 使用响应头设置资源的打开方式： * content-disposition:attachment;filename=xxx * 步骤： 1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename 2. 定义Servlet 1. 获取文件名称 2. 使用字节输入流加载文件进内存 3. 指定response的响应头： content-disposition:attachment;filename=xxx 4. 将数据写出到response输出流 * 问题： * 中文文件问题 * 解决思路： 1. 获取客户端使用的浏览器版本信息 2. 根据不同的版本信息，设置filename的编码方式不同","categories":[],"tags":[{"name":"javaee","slug":"javaee","permalink":"http://kayuyu1.github.io/tags/javaee/"}]},{"title":"Junit与反射","slug":"Junit与反射","date":"2020-04-07T16:16:08.000Z","updated":"2020-04-07T16:24:18.929Z","comments":true,"path":"2020/04/08/Junit与反射/","link":"","permalink":"http://kayuyu1.github.io/2020/04/08/Junit%E4%B8%8E%E5%8F%8D%E5%B0%84/","excerpt":"内容 Junit单元测试 反射 注解","text":"内容 Junit单元测试 反射 注解 Junit单元测试： 12345678910111213141516171819202122232425262728293031* 测试分类： 1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。 2. 白盒测试：需要写代码的。关注程序具体的执行流程。* Junit使用：白盒测试 * 步骤： 1. 定义一个测试类(测试用例) * 建议： * 测试类名：被测试的类名Test CalculatorTest * 包名：xxx.xxx.xx.test cn.itcast.test 2. 定义测试方法：可以独立运行 * 建议： * 方法名：test测试的方法名 testAdd() * 返回值：void * 参数列表：空参 3. 给方法加@Test 4. 导入junit依赖环境 * 判定结果： * 红色：失败 * 绿色：成功 * 一般我们会使用断言操作来处理结果 * Assert.assertEquals(期望的结果,运算的结果); * 补充： * @Before: * 修饰的方法会在测试方法之前被自动执行 * @After: * 修饰的方法会在测试方法执行之后自动被执行 反射：框架设计的灵魂代码的三个阶段 * 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码 * 反射：将类的各个组成部分封装为其他对象，这就是反射机制 * 好处： 1. 可以在程序运行过程中，操作这些对象。 2. 可以解耦，提高程序的可扩展性。12345678910* 获取Class对象的方式： 1. Class.forName(\"全类名\")：将字节码文件加载进内存，返回Class对象 * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 2. 类名.class：通过类名的属性class获取 * 多用于参数的传递 3. 对象.getClass()：getClass()方法在Object类中定义着。 * 多用于对象的获取字节码的方式 * 结论： 同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。 1234567891011121314151617181920212223* Class对象功能： * 获取功能： 1. 获取成员变量们 * Field[] getFields() ：获取所有public修饰的成员变量 * Field getField(String name) 获取指定名称的 public修饰的成员变量 * Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 * Field getDeclaredField(String name) 2. 获取构造方法们 * Constructor&lt;?&gt;[] getConstructors() * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;?&gt;[] getDeclaredConstructors() 3. 获取成员方法们： * Method[] getMethods() * Method getMethod(String name, 类&lt;?&gt;... parameterTypes) * Method[] getDeclaredMethods() * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) 4. 获取全类名 * String getName() 123456789* Field：成员变量 * 操作： 1. 设置值 * void set(Object obj, Object value) 2. 获取值 * get(Object obj) 3. 忽略访问权限修饰符的安全检查 * setAccessible(true):暴力反射 12345* Constructor:构造方法 * 创建对象： * T newInstance(Object... initargs) * 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 123456* Method：方法对象 * 执行方法： * Object invoke(Object obj, Object... args) * 获取方法名称： * String getName:获取方法名 1234567891011* 案例： * 需求：写一个\"框架\"，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法 * 实现： 1. 配置文件 2. 反射 * 步骤： 1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 2. 在程序中加载读取配置文件 3. 使用反射技术来加载类文件进内存 4. 创建对象 5. 执行方法 注解：12345678* 概念：说明程序的。给计算机看的* 注释：用文字描述程序的。给程序员看的* 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。* 概念描述： * JDK1.5之后的新特性 * 说明程序的 * 使用注解：@注解名称 ​ 1234* 作用分类： ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】 ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】 ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】 12345678910111213141516171819202122232425262728293031323334353637383940* JDK中预定义的一些注解 * @Override ：检测被该注解标注的方法是否是继承自父类(接口)的 * @Deprecated：该注解标注的内容，表示已过时 * @SuppressWarnings：压制警告 * 一般传递参数all @SuppressWarnings(\"all\")* 自定义注解 * 格式： 元注解 public @interface 注解名称&#123; 属性列表; &#125; * 本质：注解本质上就是一个接口，该接口默认继承Annotation接口 * public interface MyAnno extends java.lang.annotation.Annotation &#123;&#125; * 属性：接口中的抽象方法 * 要求： 1. 属性的返回值类型有下列取值 * 基本数据类型 * String * 枚举 * 注解 * 以上类型的数组 2. 定义了属性，在使用时需要给属性赋值 1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。 2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。 3. 数组赋值时，值使用&#123;&#125;包裹。如果数组中只有一个值，则&#123;&#125;可以省略 * 元注解：用于描述注解的注解 * @Target：描述注解能够作用的位置 * ElementType取值： * TYPE：可以作用于类上 * METHOD：可以作用于方法上 * FIELD：可以作用于成员变量上 * @Retention：描述注解被保留的阶段 * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到 * @Documented：描述注解是否被抽取到api文档中 * @Inherited：描述注解是否被子类继承 123456789101112131415* 在程序使用(解析)注解：获取注解中定义的属性值 1. 获取注解定义的位置的对象 （Class，Method,Field） 2. 获取指定的注解 * getAnnotation(Class) //其实就是在内存中生成了一个该注解接口的子类实现对象 public class ProImpl implements Pro&#123; public String className()&#123; return \"cn.itcast.annotation.Demo1\"; &#125; public String methodName()&#123; return \"show\"; &#125; &#125; 3. 调用注解中的抽象方法获取配置的属性值 1234567* 案例：简单的测试框架* 小结： 1. 以后大多数时候，我们会使用注解，而不是自定义注解 2. 注解给谁用？ 1. 编译器 2. 给解析程序用 3. 注解不是程序的一部分，可以理解为注解就是一个标签","categories":[],"tags":[{"name":"javase","slug":"javase","permalink":"http://kayuyu1.github.io/tags/javase/"}]},{"title":"java网络编程","slug":"java网络编程","date":"2020-04-07T01:42:55.000Z","updated":"2020-04-07T02:03:42.277Z","comments":true,"path":"2020/04/07/java网络编程/","link":"","permalink":"http://kayuyu1.github.io/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"主要内容 软件架构CS／BS 网络通信三要素 TCP通信 Socket套接字 ServerSocket","text":"主要内容 软件架构CS／BS 网络通信三要素 TCP通信 Socket套接字 ServerSocket 教学目标 能够辨别UDP和TCP协议特点 能够说出TCP协议下两个常用类名称 能够编写TCP协议下字符串数据传输程序 能够理解TCP协议下文件上传案例 能够理解TCP协议下案例2 第一章 网络编程入门1.1软件结构 C/S结构 ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。 B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。 两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序。 1.2 网络通信协议 网络通信协议：通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。 TCP/IP协议： 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。 上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。 1.3 协议分类通信的协议还是比较复杂的，java.net 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。 java.net 包中提供了两种常见的网络协议的支持： UDP：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。 由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。 但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。 特点:数据被限制在64kb以内，超出这个范围就不能发送了。 数据报(Datagram):网络传输的基本单位 TCP：传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。 在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。 第一次握手，客户端向服务器端发出连接请求，等待服务器确认。 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。 第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。 ​ 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。 1.4 网络编程三要素协议 协议：计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。 IP地址 IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。 IP地址分类 IPv4：是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d 的形式，例如192.168.65.100 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。 为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成ABCD:EF01:2345:6789:ABCD:EF01:2345:6789，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。 常用命令 查看本机IP地址，在控制台输入： 1ipconfig 检查网络是否连通，在控制台输入： 12ping 空格 IP地址ping 220.181.57.216 特殊的IP地址 本机IP地址：127.0.0.1、localhost 。 端口号网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？ 如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的进程（应用程序）了。 端口号：用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。 利用协议+IP地址+端口号 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。 第二章 TCP通信程序2.1 概述TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。 两端通信时步骤： 服务端程序，需要事先启动，等待客户端的连接。 客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。 在Java中，提供了两个类用于实现TCP通信程序： 客户端：java.net.Socket 类表示。创建Socket对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。 服务端：java.net.ServerSocket 类表示。创建ServerSocket对象，相当于开启一个服务，并等待客户端的连接。 2.2 Socket类Socket 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。 构造方法 public Socket(String host, int port) :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。 小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。 构造举例，代码如下： 1Socket client = new Socket(\"127.0.0.1\", 6666); 成员方法 public InputStream getInputStream() ： 返回此套接字的输入流。 如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。 关闭生成的InputStream也将关闭相关的Socket。 public OutputStream getOutputStream() ： 返回此套接字的输出流。 如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。 关闭生成的OutputStream也将关闭相关的Socket。 public void close() ：关闭此套接字。 一旦一个socket被关闭，它不可再使用。 关闭此socket也将关闭相关的InputStream和OutputStream 。 public void shutdownOutput() ： 禁用此套接字的输出流。 任何先前写出的数据将被发送，随后终止输出流。 2.3 ServerSocket类 ServerSocket类：这个类实现了服务器套接字，该对象等待通过网络的请求。 构造方法 public ServerSocket(int port) ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。 构造举例，代码如下： 1ServerSocket server = new ServerSocket(6666); 成员方法 public Socket accept() ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 2.4 简单的TCP网络程序TCP通信分析图解 【服务端】启动,创建ServerSocket对象，等待连接。 【客户端】启动,创建Socket对象，请求连接。 【服务端】接收连接,调用accept方法，并返回一个Socket对象。 【客户端】Socket对象，获取OutputStream，向服务端写出数据。 【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。 到此，客户端向服务端发送数据成功。 自此，服务端向客户端回写数据。 【服务端】Socket对象，获取OutputStream，向客户端回写数据。 【客户端】Scoket对象，获取InputStream，解析回写数据。 【客户端】释放资源，断开连接。 客户端向服务器发送数据服务端实现： 12345678910111213141516171819202122public class ServerTCP &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端启动 , 等待连接 .... \"); // 1.创建 ServerSocket对象，绑定端口，开始等待连接 ServerSocket ss = new ServerSocket(6666); // 2.接收连接 accept 方法, 返回 socket 对象. Socket server = ss.accept(); // 3.通过socket 获取输入流 InputStream is = server.getInputStream(); // 4.一次性读取数据 // 4.1 创建字节数组 byte[] b = new byte[1024]; // 4.2 据读取到字节数组中. int len = is.read(b)； // 4.3 解析数组,打印字符串信息 String msg = new String(b, 0, len); System.out.println(msg); //5.关闭资源. is.close(); server.close(); &#125;&#125; 客户端实现： 1234567891011121314public class ClientTCP &#123; public static void main(String[] args) throws Exception &#123; System.out.println(\"客户端 发送数据\"); // 1.创建 Socket ( ip , port ) , 确定连接到哪里. Socket client = new Socket(\"localhost\", 6666); // 2.获取流对象 . 输出流 OutputStream os = client.getOutputStream(); // 3.写出数据. os.write(\"你好么? tcp ,我来了\".getBytes()); // 4. 关闭资源 . os.close(); client.close(); &#125;&#125; 服务器向客户端回写数据服务端实现： 12345678910111213141516171819202122232425262728public class ServerTCP &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端启动 , 等待连接 .... \"); // 1.创建 ServerSocket对象，绑定端口，开始等待连接 ServerSocket ss = new ServerSocket(6666); // 2.接收连接 accept 方法, 返回 socket 对象. Socket server = ss.accept(); // 3.通过socket 获取输入流 InputStream is = server.getInputStream(); // 4.一次性读取数据 // 4.1 创建字节数组 byte[] b = new byte[1024]; // 4.2 据读取到字节数组中. int len = is.read(b)； // 4.3 解析数组,打印字符串信息 String msg = new String(b, 0, len); System.out.println(msg); // =================回写数据======================= // 5. 通过 socket 获取输出流 OutputStream out = server.getOutputStream(); // 6. 回写数据 out.write(\"我很好,谢谢你\".getBytes()); // 7.关闭资源. out.close(); is.close(); server.close(); &#125;&#125; 客户端实现： 12345678910111213141516171819202122public class ClientTCP &#123; public static void main(String[] args) throws Exception &#123; System.out.println(\"客户端 发送数据\"); // 1.创建 Socket ( ip , port ) , 确定连接到哪里. Socket client = new Socket(\"localhost\", 6666); // 2.通过Scoket,获取输出流对象 OutputStream os = client.getOutputStream(); // 3.写出数据. os.write(\"你好么? tcp ,我来了\".getBytes()); // ==============解析回写========================= // 4. 通过Scoket,获取 输入流对象 InputStream in = client.getInputStream(); // 5. 读取数据数据 byte[] b = new byte[100]; int len = in.read(b); System.out.println(new String(b, 0, len)); // 6. 关闭资源 . in.close(); os.close(); client.close(); &#125;&#125; 第三章 综合案例3.1 文件上传案例文件上传分析图解 【客户端】输入流，从硬盘读取文件数据到程序中。 【客户端】输出流，写出文件数据到服务端。 【服务端】输入流，读取文件数据到服务端程序。 【服务端】输出流，写出文件数据到服务器硬盘中。 基本实现服务端实现： 12345678910111213141516171819202122232425public class FileUpload_Server &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务器 启动..... \"); // 1. 创建服务端ServerSocket ServerSocket serverSocket = new ServerSocket(6666); // 2. 建立连接 Socket accept = serverSocket.accept(); // 3. 创建流对象 // 3.1 获取输入流,读取文件数据 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); // 3.2 创建输出流,保存到本地 . BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copy.jpg\")); // 4. 读写数据 byte[] b = new byte[1024 * 8]; int len; while ((len = bis.read(b)) != -1) &#123; bos.write(b, 0, len); &#125; //5. 关闭 资源 bos.close(); bis.close(); accept.close(); System.out.println(\"文件上传已保存\"); &#125;&#125; 客户端实现： 12345678910111213141516171819202122232425public class FileUPload_Client &#123; public static void main(String[] args) throws IOException &#123; // 1.创建流对象 // 1.1 创建输入流,读取本地文件 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"test.jpg\")); // 1.2 创建输出流,写到服务端 Socket socket = new Socket(\"localhost\", 6666); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); //2.写出数据. byte[] b = new byte[1024 * 8 ]; int len ; while (( len = bis.read(b))!=-1) &#123; bos.write(b, 0, len); bos.flush(); &#125; System.out.println(\"文件发送完毕\"); // 3.释放资源 bos.close(); socket.close(); bis.close(); System.out.println(\"文件上传完毕 \"); &#125;&#125; 文件上传优化分析 文件名称写死的问题 服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下： 12FileOutputStream fis = new FileOutputStream(System.currentTimeMillis()+\".jpg\") // 文件名称BufferedOutputStream bos = new BufferedOutputStream(fis); 循环接收的问题 服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下： 12345// 每次接收新的连接,创建一个Socketwhile（true）&#123; Socket accept = serverSocket.accept(); ......&#125; 效率问题 服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下： 123456789while（true）&#123; Socket accept = serverSocket.accept(); // accept 交给子线程处理. new Thread(() -&gt; &#123; ...... InputStream bis = accept.getInputStream(); ...... &#125;).start();&#125; 优化实现12345678910111213141516171819202122232425262728293031323334353637public class FileUpload_Server &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务器 启动..... \"); // 1. 创建服务端ServerSocket ServerSocket serverSocket = new ServerSocket(6666); // 2. 循环接收,建立连接 while (true) &#123; Socket accept = serverSocket.accept(); /* 3. socket对象交给子线程处理,进行读写操作 Runnable接口中,只有一个run方法,使用lambda表达式简化格式 */ new Thread(() -&gt; &#123; try ( //3.1 获取输入流对象 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //3.2 创建输出流对象, 保存到本地 . FileOutputStream fis = new FileOutputStream(System.currentTimeMillis() + \".jpg\"); BufferedOutputStream bos = new BufferedOutputStream(fis);) &#123; // 3.3 读写数据 byte[] b = new byte[1024 * 8]; int len; while ((len = bis.read(b)) != -1) &#123; bos.write(b, 0, len); &#125; //4. 关闭 资源 bos.close(); bis.close(); accept.close(); System.out.println(\"文件上传已保存\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 信息回写分析图解前四步与基本文件上传一致. 【服务端】获取输出流，回写数据。 【客户端】获取输入流，解析回写数据。 回写实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class FileUpload_Server &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务器 启动..... \"); // 1. 创建服务端ServerSocket ServerSocket serverSocket = new ServerSocket(6666); // 2. 循环接收,建立连接 while (true) &#123; Socket accept = serverSocket.accept(); /* 3. socket对象交给子线程处理,进行读写操作 Runnable接口中,只有一个run方法,使用lambda表达式简化格式 */ new Thread(() -&gt; &#123; try ( //3.1 获取输入流对象 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //3.2 创建输出流对象, 保存到本地 . FileOutputStream fis = new FileOutputStream(System.currentTimeMillis() + \".jpg\"); BufferedOutputStream bos = new BufferedOutputStream(fis); ) &#123; // 3.3 读写数据 byte[] b = new byte[1024 * 8]; int len; while ((len = bis.read(b)) != -1) &#123; bos.write(b, 0, len); &#125; // 4.=======信息回写=========================== System.out.println(\"back ........\"); OutputStream out = accept.getOutputStream(); out.write(\"上传成功\".getBytes()); out.close(); //================================ //5. 关闭 资源 bos.close(); bis.close(); accept.close(); System.out.println(\"文件上传已保存\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 客户端实现： 12345678910111213141516171819202122232425262728293031public class FileUpload_Client &#123; public static void main(String[] args) throws IOException &#123; // 1.创建流对象 // 1.1 创建输入流,读取本地文件 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"test.jpg\")); // 1.2 创建输出流,写到服务端 Socket socket = new Socket(\"localhost\", 6666); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); //2.写出数据. byte[] b = new byte[1024 * 8 ]; int len ; while (( len = bis.read(b))!=-1) &#123; bos.write(b, 0, len); &#125; // 关闭输出流,通知服务端,写出数据完毕 socket.shutdownOutput(); System.out.println(\"文件发送完毕\"); // 3. =====解析回写============ InputStream in = socket.getInputStream(); byte[] back = new byte[20]; in.read(back); System.out.println(new String(back)); in.close(); // ============================ // 4.释放资源 socket.close(); bis.close(); &#125;&#125; 3.2 模拟B\\S服务器(扩展知识点)模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。 案例分析 我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问 12345678910public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(8000); Socket socket = server.accept(); InputStream in = socket.getInputStream(); byte[] bytes = new byte[1024]; int len = in.read(bytes); System.out.println(new String(bytes,0,len)); socket.close(); server.close();&#125; 服务器程序中字节输入流可以读取到浏览器发来的请求信息 GET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。 12345678//转换流,读取浏览器请求第一行BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream()));String requst = readWb.readLine();//取出请求资源的路径String[] strArr = requst.split(\" \");//去掉web前面的/String path = strArr[1].substring(1);System.out.println(path); 案例实现服务端实现： 1234567891011121314151617181920212223242526272829303132333435public class SerDemo &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端 启动 , 等待连接 .... \"); // 创建ServerSocket 对象 ServerSocket server = new ServerSocket(8888); Socket socket = server.accept(); // 转换流读取浏览器的请求消息 BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream())); String requst = readWb.readLine(); // 取出请求资源的路径 String[] strArr = requst.split(\" \"); // 去掉web前面的/ String path = strArr[1].substring(1); // 读取客户端请求的资源文件 FileInputStream fis = new FileInputStream(path); byte[] bytes= new byte[1024]; int len = 0 ; // 字节输出流,将文件写会客户端 OutputStream out = socket.getOutputStream(); // 写入HTTP协议响应头,固定写法 out.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes()); out.write(\"Content-Type:text/html\\r\\n\".getBytes()); // 必须要写入空行,否则浏览器不解析 out.write(\"\\r\\n\".getBytes()); while((len = fis.read(bytes))!=-1)&#123; out.write(bytes,0,len); &#125; fis.close(); out.close(); readWb.close(); socket.close(); server.close(); &#125;&#125; 访问效果 火狐 小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。 发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。 浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(8888); while(true)&#123; Socket socket = server.accept(); new Thread(new Web(socket)).start(); &#125; &#125; static class Web implements Runnable&#123; private Socket socket; public Web(Socket socket)&#123; this.socket=socket; &#125; public void run() &#123; try&#123; //转换流,读取浏览器请求第一行 BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream())); String requst = readWb.readLine(); //取出请求资源的路径 String[] strArr = requst.split(\" \"); System.out.println(Arrays.toString(strArr)); String path = strArr[1].substring(1); System.out.println(path); FileInputStream fis = new FileInputStream(path); System.out.println(fis); byte[] bytes= new byte[1024]; int len = 0 ; //向浏览器 回写数据 OutputStream out = socket.getOutputStream(); out.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes()); out.write(\"Content-Type:text/html\\r\\n\".getBytes()); out.write(\"\\r\\n\".getBytes()); while((len = fis.read(bytes))!=-1)&#123; out.write(bytes,0,len); &#125; fis.close(); out.close(); readWb.close(); socket.close(); &#125;catch(Exception ex)&#123; &#125; &#125; &#125;&#125; 访问效果： 图解：","categories":[],"tags":[{"name":"javase","slug":"javase","permalink":"http://kayuyu1.github.io/tags/javase/"}]},{"title":"JDBC连接池","slug":"JDBC连接池","date":"2020-04-06T01:37:04.000Z","updated":"2020-04-06T01:45:14.038Z","comments":true,"path":"2020/04/06/JDBC连接池/","link":"","permalink":"http://kayuyu1.github.io/2020/04/06/JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/","excerpt":"内容1.数据库连接池 2.Spring JDBC : JDBC Template","text":"内容1.数据库连接池 2.Spring JDBC : JDBC Template 数据库连接池 123456789101112131415161. 概念：其实就是一个容器(集合)，存放数据库连接的容器。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。2. 好处： 1. 节约资源 2. 用户访问高效3. 实现： 1. 标准接口：DataSource javax.sql包下的 1. 方法： * 获取连接：getConnection() * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 2. 一般我们不去实现它，有数据库厂商来实现 1. C3P0：数据库连接池技术 2. Druid：数据库连接池实现技术，由阿里巴巴提供的 123456789101112131415161718192021222324252627282930313233343536373839404. C3P0：数据库连接池技术 * 步骤： 1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ， * 不要忘记导入数据库驱动jar包 2. 定义配置文件： * 名称： c3p0.properties 或者 c3p0-config.xml * 路径：直接将文件放在src目录下即可。 3. 创建核心对象 数据库连接池对象 ComboPooledDataSource 4. 获取连接： getConnection * 代码： //1.创建数据库连接池对象 DataSource ds = new ComboPooledDataSource(); //2. 获取连接对象 Connection conn = ds.getConnection();5. Druid：数据库连接池实现技术，由阿里巴巴提供的 1. 步骤： 1. 导入jar包 druid-1.0.9.jar 2. 定义配置文件： * 是properties形式的 * 可以叫任意名称，可以放在任意目录下 3. 加载配置文件。Properties 4. 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory 5. 获取连接：getConnection * 代码： //3.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(\"druid.properties\"); pro.load(is); //4.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //5.获取连接 Connection conn = ds.getConnection(); 2. 定义工具类 1. 定义一个类 JDBCUtils 2. 提供静态代码块加载配置文件，初始化连接池对象 3. 提供方法 1. 获取连接方法：通过数据库连接池获取连接 2. 释放资源 3. 获取连接池的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849* 代码： public class JDBCUtils &#123; //1.定义成员变量 DataSource private static DataSource ds ; static&#123; try &#123; //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\")); //2.获取DataSource ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; /** * 释放资源 */ public static void close(Statement stmt,Connection conn)&#123; /* if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close();//归还连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;*/ close(null,stmt,conn); &#125; ​ 1public static void close(ResultSet rs , Statement stmt, Connection conn)&#123; ​ 1234567if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; ​ 1234567891011121314151617181920212223242526 if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close();//归还连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 获取连接池方法 */ public static DataSource getDataSource()&#123; return ds; &#125;&#125; Spring JDBC1234567891011121314151617181920212223242526272829303132333435363738394041424344454647* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发* 步骤： 1. 导入jar包 2. 创建JdbcTemplate对象。依赖于数据源DataSource * JdbcTemplate template = new JdbcTemplate(ds); 3. 调用JdbcTemplate的方法来完成CRUD的操作 * update():执行DML语句。增、删、改语句 * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 * 注意：这个方法查询的结果集长度只能是1 * queryForList():查询结果将结果集封装为list集合 * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 * query():查询结果，将结果封装为JavaBean对象 * query的参数：RowMapper * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 * new BeanPropertyRowMapper&lt;类型&gt;(类型.class) * queryForObject：查询结果，将结果封装为对象 * 一般用于聚合函数的查询 4. 练习： * 需求： 1. 修改1号数据的 salary 为 10000 2. 添加一条记录 3. 删除刚才添加的记录 4. 查询id为1的记录，将其封装为Map集合 5. 查询所有记录，将其封装为List 6. 查询所有记录，将其封装为Emp对象的List集合 7. 查询总记录数 * 代码： import cn.itcast.domain.Emp; import cn.itcast.utils.JDBCUtils; import org.junit.Test; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.RowMapper; import java.sql.Date; import java.sql.ResultSet; import java.sql.SQLException; import java.util.List; import java.util.Map; public class JdbcTemplateDemo2 &#123; //Junit单元测试，可以让方法独立执行 ​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//1. 获取JDBCTemplate对象private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());/** * 1. 修改1号数据的 salary 为 10000 */@Testpublic void test1()&#123; //2. 定义sql String sql = \"update emp set salary = 10000 where id = 1001\"; //3. 执行sql int count = template.update(sql); System.out.println(count);&#125; /** * 2. 添加一条记录 */@Testpublic void test2()&#123; String sql = \"insert into emp(id,ename,dept_id) values(?,?,?)\"; int count = template.update(sql, 1015, \"郭靖\", 10); System.out.println(count); &#125; /** * 3.删除刚才添加的记录 */@Testpublic void test3()&#123; String sql = \"delete from emp where id = ?\"; int count = template.update(sql, 1015); System.out.println(count);&#125; /** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */@Testpublic void test4()&#123; String sql = \"select * from emp where id = ? or id = ?\"; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125; &#125; /** * 5. 查询所有记录，将其封装为List */@Testpublic void test5()&#123; String sql = \"select * from emp\"; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) &#123; System.out.println(stringObjectMap); &#125;&#125; /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Testpublic void test6()&#123; String sql = \"select * from emp\"; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123; @Override public Emp mapRow(ResultSet rs, int i) throws SQLException &#123; Emp emp = new Emp(); int id = rs.getInt(\"id\"); String ename = rs.getString(\"ename\"); int job_id = rs.getInt(\"job_id\"); int mgr = rs.getInt(\"mgr\"); Date joindate = rs.getDate(\"joindate\"); double salary = rs.getDouble(\"salary\"); double bonus = rs.getDouble(\"bonus\"); int dept_id = rs.getInt(\"dept_id\"); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; &#125; &#125;); ​ 123456789101112131415161718192021222324252627282930 for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6_2()&#123; String sql = \"select * from emp\"; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; /** * 7. 查询总记录数 */ @Test public void test7()&#123; String sql = \"select count(id) from emp\"; Long total = template.queryForObject(sql, Long.class); System.out.println(total); &#125;&#125;","categories":[],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://kayuyu1.github.io/tags/JDBC/"}]},{"title":"JDBC基础","slug":"JDBC基础","date":"2020-04-04T14:59:35.000Z","updated":"2020-04-04T15:35:26.349Z","comments":true,"path":"2020/04/04/JDBC基础/","link":"","permalink":"http://kayuyu1.github.io/2020/04/04/JDBC%E5%9F%BA%E7%A1%80/","excerpt":"今日内容 JDBC基本概念 快速入门 对JDBC中各个接口和类详解","text":"今日内容 JDBC基本概念 快速入门 对JDBC中各个接口和类详解 JDBC： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821. 概念：Java DataBase Connectivity Java 数据库连接， Java语言操作数据库 * JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。2. 快速入门： * 步骤： 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 2.右键--&gt;Add As Library 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql 5. 获取执行sql语句的对象 Statement 6. 执行sql，接受返回结果 7. 处理结果 8. 释放资源 * 代码实现： //1. 导入驱动jar包 //2.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //3.获取数据库连接对象 Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db3\", \"root\", \"root\"); //4.定义sql语句 String sql = \"update account set balance = 500 where id = 1\"; //5.获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //6.执行sql int count = stmt.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 stmt.close(); conn.close();3. 详解各个对象： 1. DriverManager：驱动管理对象 * 功能： 1. 注册驱动：告诉程序该使用哪一个数据库驱动jar static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 写代码使用： Class.forName(\"com.mysql.jdbc.Driver\"); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(\"Can't register driver!\"); &#125; &#125; 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。 2. 获取数据库连接： * 方法：static Connection getConnection(String url, String user, String password) * 参数： * url：指定连接的路径 * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 * 例子：jdbc:mysql://localhost:3306/db3 * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 * user：用户名 * password：密码 2. Connection：数据库连接对象 1. 功能： 1. 获取执行sql 的对象 * Statement createStatement() * PreparedStatement prepareStatement(String sql) 2. 管理事务： * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 * 提交事务：commit() * 回滚事务：rollback() 3. Statement：执行sql的对象 1. 执行sql 1. boolean execute(String sql) ：可以执行任意的sql 了解 2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。 3. ResultSet executeQuery(String sql) ：执行DQL（select)语句 2. 练习： 1. account表 添加一条记录 2. account表 修改记录 3. account表 删除一条记录 代码： Statement stmt = null; Connection conn = null; try &#123; //1. 注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2. 定义sql String sql = \"insert into account values(null,'王五',3000)\"; //3.获取Connection对象 conn = DriverManager.getConnection(\"jdbc:mysql:///db3\", \"root\", \"root\"); //4.获取执行sql的对象 Statement stmt = conn.createStatement(); //5.执行sql int count = stmt.executeUpdate(sql);//影响的行数 //6.处理结果 System.out.println(count); if(count &gt; 0)&#123; System.out.println(\"添加成功！\"); &#125;else&#123; System.out.println(\"添加失败！\"); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; //stmt.close(); //7. 释放资源 //避免空指针异常 if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 4. ResultSet：结果集对象,封装查询结果 * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true * getXxx(参数):获取数据 * Xxx：代表数据类型 如： int getInt() , String getString() * 参数： 1. int：代表列的编号,从1开始 如： getString(1) 2. String：代表列名称。 如： getDouble(\"balance\") * 注意： * 使用步骤： 1. 游标向下移动一行 2. 判断是否有数据 3. 获取数据 //循环判断游标是否是最后一行末尾。 while(rs.next())&#123; //获取数据 //6.2 获取数据 int id = rs.getInt(1); String name = rs.getString(\"name\"); double balance = rs.getDouble(3); System.out.println(id + \"---\" + name + \"---\" + balance); &#125; * 练习： * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。 1. 定义Emp类 2. 定义方法 public List&lt;Emp&gt; findAll()&#123;&#125; 3. 实现方法 select * from emp; 5. PreparedStatement：执行sql的对象 1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 1. 输入用户随便，输入密码：a' or 'a' = 'a 2. sql：select * from user where username = 'fhdsjkf' and password = 'a' or 'a' = 'a' 2. 解决sql注入问题：使用PreparedStatement对象来解决 3. 预编译的SQL：参数使用?作为占位符 4. 步骤： 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 5. 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 6. 给？赋值： * 方法： setXxx(参数1,参数2) * 参数1：？的位置编号 从1 开始 * 参数2：？的值 7. 执行sql，接受返回结果，不需要传递sql语句 8. 处理结果 9. 释放资源 5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作 1. 可以防止SQL注入 2. 效率更高 抽取JDBC工具类 ： JDBCUtils12345678910* 目的：简化书写* 分析： 1. 注册驱动也抽取 2. 抽取一个方法获取连接对象 * 需求：不想传递参数（麻烦），还得保证工具类的通用性。 * 解决：配置文件 jdbc.properties url= user= password= 12345678910111213141516171819202122232425262728293031323334353637383940 3. 抽取一个方法释放资源* 代码实现： public class JDBCUtils &#123; private static String url; private static String user; private static String password; private static String driver; /** * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块 */ static&#123; //读取资源文件，获取值。 try &#123; //1. 创建Properties集合类。 Properties pro = new Properties(); //获取src路径下的文件的方式---&gt;ClassLoader 类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource(\"jdbc.properties\"); String path = res.getPath(); System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties //2. 加载文件 // pro.load(new FileReader(\"D:\\\\IdeaProjects\\\\itcast\\\\day04_jdbc\\\\src\\\\jdbc.properties\")); pro.load(new FileReader(path)); //3. 获取数据，赋值 url = pro.getProperty(\"url\"); user = pro.getProperty(\"user\"); password = pro.getProperty(\"password\"); driver = pro.getProperty(\"driver\"); //4. 注册驱动 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; ​ 12345678910111213141516171819202122232425262728293031/** * 获取连接 * @return 连接对象 */public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, user, password);&#125;/** * 释放资源 * @param stmt * @param conn */public static void close(Statement stmt,Connection conn)&#123; if( stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if( conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 /** * 释放资源 * @param stmt * @param conn */ public static void close(ResultSet rs,Statement stmt, Connection conn)&#123; if( rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if( stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if( conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;* 练习： * 需求： 1. 通过键盘录入用户名和密码 2. 判断用户是否登录成功 * select * from user where username = \"\" and password = \"\"; * 如果这个sql有查询结果，则成功，反之，则失败 * 步骤： 1. 创建数据库表 user CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32), PASSWORD VARCHAR(32) ); INSERT INTO USER VALUES(NULL,'zhangsan','123'); INSERT INTO USER VALUES(NULL,'lisi','234'); 2. 代码实现： public class JDBCDemo9 &#123; public static void main(String[] args) &#123; //1.键盘录入，接受用户名和密码 Scanner sc = new Scanner(System.in); System.out.println(\"请输入用户名：\"); String username = sc.nextLine(); System.out.println(\"请输入密码：\"); String password = sc.nextLine(); //2.调用方法 boolean flag = new JDBCDemo9().login(username, password); //3.判断结果，输出不同语句 if(flag)&#123; //登录成功 System.out.println(\"登录成功！\"); &#125;else&#123; System.out.println(\"用户名或密码错误！\"); &#125; ​ }​​ 123456789101112131415161718192021222324252627282930313233/** * 登录方法 */public boolean login(String username ,String password)&#123; if(username == null || password == null)&#123; return false; &#125; //连接数据库判断是否登录成功 Connection conn = null; Statement stmt = null; ResultSet rs = null; //1.获取连接 try &#123; conn = JDBCUtils.getConnection(); //2.定义sql String sql = \"select * from user where username = '\"+username+\"' and password = '\"+password+\"' \"; //3.获取执行sql的对象 stmt = conn.createStatement(); //4.执行查询 rs = stmt.executeQuery(sql); //5.判断 /* if(rs.next())&#123;//如果有下一行，则返回true return true; &#125;else&#123; return false; &#125;*/ return rs.next();//如果有下一行，则返回true &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(rs,stmt,conn); &#125; ​ 123 return false; &#125;&#125; JDBC控制事务：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162631. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。2. 操作： 1. 开启事务 2. 提交事务 3. 回滚事务3. 使用Connection对象来管理事务 * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 * 在执行sql之前开启事务 * 提交事务：commit() * 当所有sql都执行完提交事务 * 回滚事务：rollback() * 在catch中回滚事务4. 代码： public class JDBCDemo10 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement pstmt1 = null; PreparedStatement pstmt2 = null; try &#123; //1.获取连接 conn = JDBCUtils.getConnection(); //开启事务 conn.setAutoCommit(false); //2.定义sql //2.1 张三 - 500 String sql1 = \"update account set balance = balance - ? where id = ?\"; //2.2 李四 + 500 String sql2 = \"update account set balance = balance + ? where id = ?\"; //3.获取执行sql对象 pstmt1 = conn.prepareStatement(sql1); pstmt2 = conn.prepareStatement(sql2); //4. 设置参数 pstmt1.setDouble(1,500); pstmt1.setInt(2,1); pstmt2.setDouble(1,500); pstmt2.setInt(2,2); //5.执行sql pstmt1.executeUpdate(); // 手动制造异常 int i = 3/0; pstmt2.executeUpdate(); //提交事务 conn.commit(); &#125; catch (Exception e) &#123; //事务回滚 try &#123; if(conn != null) &#123; conn.rollback(); &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(pstmt1,conn); JDBCUtils.close(pstmt2,null); &#125; ​ 123 &#125;&#125; ​","categories":[],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://kayuyu1.github.io/tags/JDBC/"}]},{"title":"day03-List,Set","slug":"day03-List-Set","date":"2020-04-04T05:27:35.000Z","updated":"2020-04-04T05:51:27.498Z","comments":true,"path":"2020/04/04/day03-List-Set/","link":"","permalink":"http://kayuyu1.github.io/2020/04/04/day03-List-Set/","excerpt":"day03 【List、Set、数据结构、Collections】","text":"day03 【List、Set、数据结构、Collections】 主要内容 数据结构 List集合 Set集合 Collections 教学目标 能够说出List集合特点 能够说出常见的数据结构 能够说出数组结构特点 能够说出栈结构特点 能够说出队列结构特点 能够说出单向链表结构特点 能够说出Set集合的特点 能够说出哈希表的特点 使用HashSet集合存储自定义元素 能够说出可变参数的格式 能够使用集合工具类 能够使用Comparator比较器进行排序 第一章 数据结构2.1 数据结构有什么用？当你用着java里面的容器类很爽的时候，你有没有想过，怎么ArrayList就像一个无限扩充的数组，也好像链表之类的。好用吗？好用，这就是数据结构的用处，只不过你在不知不觉中使用了。 现实世界的存储，我们使用的工具和建模。每种数据结构有自己的优点和缺点，想想如果Google的数据用的是数组的存储，我们还能方便地查询到所需要的数据吗？而算法，在这么多的数据中如何做到最快的插入，查找，删除，也是在追求更快。 我们java是面向对象的语言，就好似自动档轿车，C语言好似手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从 A点 开到 B点，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。当然了，数据结构内容比较多，细细的学起来也是相对费功夫的，不可能达到一蹴而就。我们将常见的数据结构：堆栈、队列、数组、链表和红黑树 这几种给大家介绍一下，作为数据结构的入门，了解一下它们的特点即可。 2.2 常见的数据结构数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下： 栈 栈：stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。 简单的说：采用该结构的集合，对元素的存取有如下的特点 先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。 栈的入口、出口的都是栈的顶端位置。 这里两个名词需要注意： 压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。 弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。 队列 队列：queue,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。 简单的说，采用该结构的集合，对元素的存取有如下的特点： 先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。 队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。 数组 数组:Array,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。 简单的说,采用该结构的集合，对元素的存取有如下的特点： 查找元素快：通过索引，可以快速访问指定位置的元素 增删元素慢 指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。 指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图 链表 链表:linked list,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是单向链表。 简单的说，采用该结构的集合，对元素的存取有如下的特点： 多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素 增删元素快： 增加元素：只需要修改连接下个元素的地址即可。 删除元素：只需要修改连接下个元素的地址即可。 红黑树 二叉树：binary tree ,是每个结点不超过2的有序树（tree） 。 简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。 二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。 如图： 我们要说的是二叉树的一种比较有意思的叫做红黑树，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。 红黑树的约束: 节点可以是红色的或者黑色的 根节点是黑色的 叶子节点(特指空节点)是黑色的 每个红色节点的子节点都是黑色的 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同 红黑树的特点: ​ 速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍 第二章 List集合我们掌握了Collection接口的使用后，再来看看Collection接口中的子类，他们都具备那些特性呢？ 接下来，我们一起学习Collection中的常用几个子类（java.util.List集合、java.util.Set集合）。 1.1 List接口介绍java.util.List接口继承自Collection接口，是单列集合的一个重要分支，习惯性地会将实现了List接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。 看完API，我们总结一下： List接口特点： 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。 tips:我们在基础班的时候已经学习过List接口的子类java.util.ArrayList类，该类中的方法都是来自List中定义。 1.2 List接口中常用方法List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下： public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 List集合特有的方法都是跟索引相关，我们在基础班都学习过，那么我们再来复习一遍吧： 12345678910111213141516171819202122232425262728293031323334353637383940public class ListDemo &#123; public static void main(String[] args) &#123; // 创建List集合对象 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // 往 尾部添加 指定元素 list.add(\"图图\"); list.add(\"小美\"); list.add(\"不高兴\"); System.out.println(list); // add(int index,String s) 往指定位置添加 list.add(1,\"没头脑\"); System.out.println(list); // String remove(int index) 删除指定位置元素 返回被删除元素 // 删除索引位置为2的元素 System.out.println(\"删除索引位置为2的元素\"); System.out.println(list.remove(2)); System.out.println(list); // String set(int index,String s) // 在指定位置 进行 元素替代（改） // 修改指定位置元素 list.set(0, \"三毛\"); System.out.println(list); // String get(int index) 获取指定位置元素 // 跟size() 方法一起用 来 遍历的 for(int i = 0;i&lt;list.size();i++)&#123; System.out.println(list.get(i)); &#125; //还可以使用增强for for (String string : list) &#123; System.out.println(string); &#125; &#125;&#125; 第三章 List的子类3.1 ArrayList集合java.util.ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。 许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。 3.2 LinkedList集合java.util.LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。 LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下 实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可： public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst():返回此列表的第一个元素。 public E getLast():返回此列表的最后一个元素。 public E removeFirst():移除并返回此列表的第一个元素。 public E removeLast():移除并返回此列表的最后一个元素。 public E pop():从此列表所表示的堆栈处弹出一个元素。 public void push(E e):将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回true。 LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可） 方法演示： 12345678910111213141516171819202122public class LinkedListDemo &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;(); //添加元素 link.addFirst(\"abc1\"); link.addFirst(\"abc2\"); link.addFirst(\"abc3\"); System.out.println(link); // 获取元素 System.out.println(link.getFirst()); System.out.println(link.getLast()); // 删除元素 System.out.println(link.removeFirst()); System.out.println(link.removeLast()); while (!link.isEmpty()) &#123; //判断集合是否为空 System.out.println(link.pop()); //弹出集合中的栈顶元素 &#125; System.out.println(link); &#125;&#125; 第四章 Set接口java.util.Set接口和java.util.List接口一样，同样继承自Collection接口，它与Collection接口中的方法基本一致，并没有对Collection接口进行功能上的扩充，只是比Collection接口更加严格了。与List接口不同的是，Set接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。 Set集合有多个子类，这里我们介绍其中的java.util.HashSet、java.util.LinkedHashSet这两个集合。 tips:Set集合取出元素的方式可以采用：迭代器、增强for。 3.1 HashSet集合介绍java.util.HashSet是Set接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。java.util.HashSet底层的实现其实是一个java.util.HashMap支持，由于我们暂时还未学习，先做了解。 HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：hashCode与equals方法。 我们先来使用一下Set集合存储，看下现象，再进行原理的讲解: 12345678910111213141516public class HashSetDemo &#123; public static void main(String[] args) &#123; //创建 Set集合 HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); //添加元素 set.add(new String(\"cba\")); set.add(\"abc\"); set.add(\"bac\"); set.add(\"cba\"); //遍历 for (String name : set) &#123; System.out.println(name); &#125; &#125;&#125; 输出结果如下，说明集合中不能存储重复元素： 123cbaabcbac tips:根据结果我们发现字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。 2.2 HashSet集合存储数据的结构（哈希表）什么是哈希表呢？ 在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。 简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。 看到这张图就有人要问了，这个是怎么存储的呢？ 为了方便大家的理解我们结合一个存储流程图来说明一下： 总而言之，JDK1.8引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。 2.3 HashSet存储自定义类型元素给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一 创建自定义Student类 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; 123456789101112131415161718192021public class HashSetDemo2 &#123; public static void main(String[] args) &#123; //创建集合对象 该集合中存储 Student类型对象 HashSet&lt;Student&gt; stuSet = new HashSet&lt;Student&gt;(); //存储 Student stu = new Student(\"于谦\", 43); stuSet.add(stu); stuSet.add(new Student(\"郭德纲\", 44)); stuSet.add(new Student(\"于谦\", 43)); stuSet.add(new Student(\"郭麒麟\", 23)); stuSet.add(stu); for (Student stu2 : stuSet) &#123; System.out.println(stu2); &#125; &#125;&#125;执行结果：Student [name=郭德纲, age=44]Student [name=于谦, age=43]Student [name=郭麒麟, age=23] 2.3 LinkedHashSet我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？ 在HashSet下面有一个子类java.util.LinkedHashSet，它是链表和哈希表组合的一个数据存储结构。 演示代码如下: 123456789101112131415161718public class LinkedHashSetDemo &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;(); set.add(\"bbb\"); set.add(\"aaa\"); set.add(\"abc\"); set.add(\"bbc\"); Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125;结果： bbb aaa abc bbc 1.9 可变参数在JDK1.5之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式： 1修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125; 其实这个书写完全等价与 1修饰符 返回值类型 方法名(参数类型[] 形参名)&#123; &#125; 只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。 JDK1.5以后。出现了简化操作。… 用在参数上，称之为可变参数。 同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。 代码演示： 1234567891011121314151617181920212223242526272829303132public class ChangeArgs &#123; public static void main(String[] args) &#123; int[] arr = &#123; 1, 4, 62, 431, 2 &#125;; int sum = getSum(arr); System.out.println(sum); // 6 7 2 12 2121 // 求 这几个元素和 6 7 2 12 2121 int sum2 = getSum(6, 7, 2, 12, 2121); System.out.println(sum2); &#125; /* * 完成数组 所有元素的求和 原始写法 public static int getSum(int[] arr)&#123; int sum = 0; for(int a : arr)&#123; sum += a; &#125; return sum; &#125; */ //可变参数写法 public static int getSum(int... arr) &#123; int sum = 0; for (int a : arr) &#123; sum += a; &#125; return sum; &#125;&#125; tips: 上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性 注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。 第五章 Collections2.1 常用功能 java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。 public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 代码演示： 12345678910111213141516171819public class CollectionsDemo &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); //原来写法 //list.add(12); //list.add(14); //list.add(15); //list.add(1000); //采用工具类 完成 往集合中添加元素 Collections.addAll(list, 5, 222, 1，2); System.out.println(list); //排序方法 Collections.sort(list); System.out.println(list); &#125;&#125;结果：[5, 222, 1, 2][1, 2, 5, 222] 代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？ 我们发现还有个方法没有讲，public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。 2.2 Comparator比较器我们还是先研究这个方法 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 不过这次存储的是字符串类型。 123456789101112public class CollectionsDemo2 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"cba\"); list.add(\"aba\"); list.add(\"sba\"); list.add(\"nba\"); //排序方法 Collections.sort(list); System.out.println(list); &#125;&#125; 结果： 1[aba, cba, nba, sba] 我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？ 说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用java.lang.Comparable接口去实现，一种是灵活的当我需要做排序的时候在去选择的java.util.Comparator接口完成。 那么我们采用的public static &lt;T&gt; void sort(List&lt;T&gt; list)这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下： 1public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是： public int compare(String o1, String o2)：比较其两个参数的顺序。 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序，则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）如果要按照降序排序则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数） 操作如下: 1234567891011121314151617public class CollectionsDemo3 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"cba\"); list.add(\"aba\"); list.add(\"sba\"); list.add(\"nba\"); //排序方法 按照第一个单词的降序 Collections.sort(list, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o2.charAt(0) - o1.charAt(0); &#125; &#125;); System.out.println(list); &#125;&#125; 结果如下： 1[sba, nba, cba, aba] 2.3 简述Comparable和Comparator两个接口的区别。Comparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 Comparator强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。 2.4 练习创建一个学生类，存储到ArrayList集合中完成指定排序操作。 Student 初始类 123456789101112131415161718192021222324252627282930313233343536public class Student&#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 测试类： 1234567891011121314151617181920212223242526public class Demo &#123; public static void main(String[] args) &#123; // 创建四个学生对象 存储到集合中 ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); list.add(new Student(\"rose\",18)); list.add(new Student(\"jack\",16)); list.add(new Student(\"abc\",16)); list.add(new Student(\"ace\",17)); list.add(new Student(\"mark\",16)); /* 让学生 按照年龄排序 升序 */// Collections.sort(list);//要求 该list中元素类型 必须实现比较器Comparable接口 for (Student student : list) &#123; System.out.println(student); &#125; &#125;&#125; 发现，当我们调用Collections.sort()方法的时候 程序报错了。 原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。 于是我们就完成了Student类的一个实现，如下： 1234567public class Student implements Comparable&lt;Student&gt;&#123; .... @Override public int compareTo(Student o) &#123; return this.age-o.age;//升序 &#125;&#125; 再次测试，代码就OK 了效果如下： 12345Student&#123;name='jack', age=16&#125;Student&#123;name='abc', age=16&#125;Student&#123;name='mark', age=16&#125;Student&#123;name='ace', age=17&#125;Student&#123;name='rose', age=18&#125; 2.5 扩展如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor c)方式，自己定义规则： 123456Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o2.getAge()-o1.getAge();//以学生的年龄降序 &#125;&#125;); 效果： 12345Student&#123;name&#x3D;&#39;rose&#39;, age&#x3D;18&#125;Student&#123;name&#x3D;&#39;ace&#39;, age&#x3D;17&#125;Student&#123;name&#x3D;&#39;jack&#39;, age&#x3D;16&#125;Student&#123;name&#x3D;&#39;abc&#39;, age&#x3D;16&#125;Student&#123;name&#x3D;&#39;mark&#39;, age&#x3D;16&#125; 如果想要规则更多一些，可以参考下面代码： 12345678910111213Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; // 年龄降序 int result = o2.getAge()-o1.getAge();//年龄降序 if(result==0)&#123;//第一个规则判断完了 下一个规则 姓名的首字母 升序 result = o1.getName().charAt(0)-o2.getName().charAt(0); &#125; return result; &#125; &#125;); 效果如下： 12345Student&#123;name&#x3D;&#39;rose&#39;, age&#x3D;18&#125;Student&#123;name&#x3D;&#39;ace&#39;, age&#x3D;17&#125;Student&#123;name&#x3D;&#39;abc&#39;, age&#x3D;16&#125;Student&#123;name&#x3D;&#39;jack&#39;, age&#x3D;16&#125;Student&#123;name&#x3D;&#39;mark&#39;, age&#x3D;16&#125;","categories":[],"tags":[{"name":"javase","slug":"javase","permalink":"http://kayuyu1.github.io/tags/javase/"}]},{"title":"day02[Collection.泛型]","slug":"day02-Collection-泛型","date":"2020-04-04T04:39:29.000Z","updated":"2020-04-04T05:22:46.221Z","comments":true,"path":"2020/04/04/day02-Collection-泛型/","link":"","permalink":"http://kayuyu1.github.io/2020/04/04/day02-Collection-%E6%B3%9B%E5%9E%8B/","excerpt":"day02【Collection、泛型】","text":"day02【Collection、泛型】 主要内容 Collection集合 迭代器 增强for 泛型 教学目标 能够说出集合与数组的区别 说出Collection集合的常用功能 能够使用迭代器对集合进行取元素 能够说出集合的使用细节 能够使用集合存储自定义类型 能够使用foreach循环遍历集合 能够使用泛型定义集合对象 能够理解泛型上下限 能够阐述泛型通配符的作用 第一章 Collection集合1.1 集合概述在前面基础班我们已经学习过并使用过集合ArrayList ,那么集合到底是什么呢? 集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组既然都是容器，它们有啥区别呢？ 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。 1.2 集合框架JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。 集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map，今天我们主要学习Collection集合，在day04时讲解Map集合。 Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是java.util.List和java.util.Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素无序，而且不可重复。List接口的主要实现类有java.util.ArrayList和java.util.LinkedList，Set接口的主要实现类有java.util.HashSet和java.util.TreeSet。 从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。 其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。 集合本身是一个工具，它存放在java.util包中。在Collection接口定义着单列集合框架中最最共性的内容。 1.3 Collection 常用功能Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 方法演示： 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.Collection;public class Demo1Collection &#123; public static void main(String[] args) &#123; // 创建集合对象 // 使用多态形式 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 使用方法 // 添加功能 boolean add(String s) coll.add(\"小李广\"); coll.add(\"扫地僧\"); coll.add(\"石破天\"); System.out.println(coll); // boolean contains(E e) 判断o是否在集合中存在 System.out.println(\"判断 扫地僧 是否在集合中\"+coll.contains(\"扫地僧\")); //boolean remove(E e) 删除在集合中的o元素 System.out.println(\"删除石破天：\"+coll.remove(\"石破天\")); System.out.println(\"操作之后集合中元素:\"+coll); // size() 集合中有几个元素 System.out.println(\"集合中有\"+coll.size()+\"个元素\"); // Object[] toArray()转换成一个Object数组 Object[] objects = coll.toArray(); // 遍历数组 for (int i = 0; i &lt; objects.length; i++) &#123; System.out.println(objects[i]); &#125; // void clear() 清空集合 coll.clear(); System.out.println(\"集合中内容为：\"+coll); // boolean isEmpty() 判断是否为空 System.out.println(coll.isEmpty()); &#125;&#125; tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。 第二章 Iterator迭代器2.1 Iterator接口在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口java.util.Iterator。Iterator接口也是Java集合中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用于存储元素，而Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被称为迭代器。 想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法： public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。 下面介绍一下迭代的概念： 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 Iterator接口的常用方法如下： public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 接下来我们通过案例学习如何使用Iterator迭代集合中元素： 12345678910111213141516171819public class IteratorDemo &#123; public static void main(String[] args) &#123; // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 添加元素到集合 coll.add(\"串串星人\"); coll.add(\"吐槽星人\"); coll.add(\"汪星人\"); //遍历 //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); &#125; &#125;&#125; tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。 2.2 迭代器的实现原理我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。 Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程： 在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 2.3 增强for增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。 格式： 123for(元素的数据类型 变量 : Collection集合or数组)&#123; //写操作代码&#125; 它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。 练习1：遍历数组123456789public class NBForDemo1 &#123; public static void main(String[] args) &#123; int[] arr = &#123;3,5,6,87&#125;; //使用增强for遍历数组 for(int a : arr)&#123;//a代表数组中的每个元素 System.out.println(a); &#125; &#125;&#125; 练习2:遍历集合123456789101112public class NBFor &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add(\"小河神\"); coll.add(\"老河神\"); coll.add(\"神婆\"); //使用增强for遍历 for(String s :coll)&#123;//接收变量s代表 代表被遍历到的集合元素 System.out.println(s); &#125; &#125;&#125; tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。 第三章 泛型3.1 泛型概述在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。 大家观察下面代码： 1234567891011121314public class GenericDemo &#123; public static void main(String[] args) &#123; Collection coll = new ArrayList(); coll.add(\"abc\"); coll.add(\"itcast\"); coll.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放 Iterator it = coll.iterator(); while(it.hasNext())&#123; //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型 String str = (String) it.next(); System.out.println(str.length()); &#125; &#125;&#125; 程序在运行时发生了问题java.lang.ClassCastException。 为什么会发生类型转换异常呢？ 我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。 怎么来解决这个问题呢？ Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了泛型(Generic)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。 泛型：可以在类或方法中预支地使用未知的类型。 tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。 3.2 使用泛型的好处上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？ 将运行时期的ClassCastException，转移到了编译时期变成了编译失败。 避免了类型强转的麻烦。 通过我们如下代码体验一下： 123456789101112131415public class GenericDemo2 &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"abc\"); list.add(\"itcast\"); // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错 // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String str = it.next(); //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 System.out.println(str.length()); &#125; &#125;&#125; tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。 3.3 泛型的定义与使用我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。 泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。 定义和使用含有泛型的类定义格式： 1修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125; 例如，API中的ArrayList集合： 123456class ArrayList&lt;E&gt;&#123; public boolean add(E e)&#123; &#125; public E get(int index)&#123; &#125; ....&#125; 使用泛型： 即什么时候确定泛型。 在创建对象的时候确定泛型 例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 此时，变量E的值就是String类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;String&gt;&#123; public boolean add(String e)&#123; &#125; public String get(int index)&#123; &#125; ...&#125; 再例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); 此时，变量E的值就是Integer类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;Integer&gt; &#123; public boolean add(Integer e) &#123; &#125; public Integer get(int index) &#123; &#125; ...&#125; 举例自定义泛型类 123456789101112public class MyGenericClass&lt;MVP&gt; &#123; //没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型 private MVP mvp; public void setMVP(MVP mvp) &#123; this.mvp = mvp; &#125; public MVP getMVP() &#123; return mvp; &#125;&#125; 使用: 123456789101112131415public class GenericClassDemo &#123; public static void main(String[] args) &#123; // 创建一个泛型为String的类 MyGenericClass&lt;String&gt; my = new MyGenericClass&lt;String&gt;(); // 调用setMVP my.setMVP(\"大胡子登登\"); // 调用getMVP String mvp = my.getMVP(); System.out.println(mvp); //创建一个泛型为Integer的类 MyGenericClass&lt;Integer&gt; my2 = new MyGenericClass&lt;Integer&gt;(); my2.setMVP(123); Integer mvp2 = my2.getMVP(); &#125;&#125; 含有泛型的方法定义格式： 1修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; &#125; 例如， 123456789public class MyGenericMethod &#123; public &lt;MVP&gt; void show(MVP mvp) &#123; System.out.println(mvp.getClass()); &#125; public &lt;MVP&gt; MVP show2(MVP mvp) &#123; return mvp; &#125;&#125; 使用格式：调用方法时，确定泛型的类型 12345678910public class GenericMethodDemo &#123; public static void main(String[] args) &#123; // 创建对象 MyGenericMethod mm = new MyGenericMethod(); // 演示看方法提示 mm.show(\"aaa\"); mm.show(123); mm.show(12.45); &#125;&#125; 含有泛型的接口定义格式： 1修饰符 interface接口名&lt;代表泛型的变量&gt; &#123; &#125; 例如， 12345public interface MyGenericInterface&lt;E&gt;&#123; public abstract void add(E e); public abstract E getE(); &#125; 使用格式： 1、定义类时确定泛型的类型 例如 1234567891011public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123; @Override public void add(String e) &#123; // 省略... &#125; @Override public String getE() &#123; return null; &#125;&#125; 此时，泛型E的值就是String类型。 2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型 例如 1234567891011public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123; @Override public void add(E e) &#123; // 省略... &#125; @Override public E getE() &#123; return null; &#125;&#125; 确定泛型： 123456789/* * 使用 */public class GenericInterface &#123; public static void main(String[] args) &#123; MyImp2&lt;String&gt; my = new MyImp2&lt;String&gt;(); my.add(\"aa\"); &#125;&#125; 3.4 泛型通配符当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。 此时只能接受数据,不能往该集合中存储数据。 举个例子大家理解使用即可： 12345678public static void main(String[] args) &#123; Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;(); getElement(list1); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); getElement(list2);&#125;public static void getElement(Collection&lt;?&gt; coll)&#123;&#125;//？代表可以接收任意类型 tips:泛型不存在继承关系 Collection list = new ArrayList();这种是错误的。 通配符高级使用—-受限泛型之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的上限和下限。 泛型的上限： 格式： 类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类 123456789101112131415161718192021public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement(list1); getElement(list2);//报错 getElement(list3); getElement(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); &#125;// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125; 第四章 集合综合案例4.1 案例介绍按照斗地主的规则，完成洗牌发牌的动作。具体规则： 使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。 4.2 案例分析 准备牌： 牌可以设计为一个ArrayList,每个字符串为一张牌。每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。牌由Collections类的shuffle方法进行随机排序。 发牌 将每个人以及底牌设计为ArrayList,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。 看牌 直接打印每个集合。 4.3 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import java.util.ArrayList;import java.util.Collections;public class Poker &#123; public static void main(String[] args) &#123; /* * 1: 准备牌操作 */ //1.1 创建牌盒 将来存储牌面的 ArrayList&lt;String&gt; pokerBox = new ArrayList&lt;String&gt;(); //1.2 创建花色集合 ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;(); //1.3 创建数字集合 ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;(); //1.4 分别给花色 以及 数字集合添加元素 colors.add(\"♥\"); colors.add(\"♦\"); colors.add(\"♠\"); colors.add(\"♣\"); for(int i = 2;i&lt;=10;i++)&#123; numbers.add(i+\"\"); &#125; numbers.add(\"J\"); numbers.add(\"Q\"); numbers.add(\"K\"); numbers.add(\"A\"); //1.5 创造牌 拼接牌操作 // 拿出每一个花色 然后跟每一个数字 进行结合 存储到牌盒中 for (String color : colors) &#123; //color每一个花色 //遍历数字集合 for(String number : numbers)&#123; //结合 String card = color+number; //存储到牌盒中 pokerBox.add(card); &#125; &#125; //1.6大王小王 pokerBox.add(\"小☺\"); pokerBox.add(\"大☠\"); // System.out.println(pokerBox); //洗牌 是不是就是将 牌盒中 牌的索引打乱 // Collections类 工具类 都是 静态方法 // shuffer方法 /* * static void shuffle(List&lt;?&gt; list) * 使用默认随机源对指定列表进行置换。 */ //2:洗牌 Collections.shuffle(pokerBox); //3 发牌 //3.1 创建 三个 玩家集合 创建一个底牌集合 ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;(); //遍历 牌盒 必须知道索引 for(int i = 0;i&lt;pokerBox.size();i++)&#123; //获取 牌面 String card = pokerBox.get(i); //留出三张底牌 存到 底牌集合中 if(i&gt;=51)&#123;//存到底牌集合中 dipai.add(card); &#125; else &#123; //玩家1 %3 ==0 if(i%3==0)&#123; player1.add(card); &#125;else if(i%3==1)&#123;//玩家2 player2.add(card); &#125;else&#123;//玩家3 player3.add(card); &#125; &#125; &#125; //看看 System.out.println(\"令狐冲：\"+player1); System.out.println(\"田伯光：\"+player2); System.out.println(\"绿竹翁：\"+player3); System.out.println(\"底牌：\"+dipai); &#125;&#125;","categories":[],"tags":[{"name":"javase","slug":"javase","permalink":"http://kayuyu1.github.io/tags/javase/"}]},{"title":"javaseObject类","slug":"day01【Object类、常用API】-笔记","date":"2020-04-03T13:19:16.715Z","updated":"2020-04-04T04:36:48.486Z","comments":true,"path":"2020/04/03/day01【Object类、常用API】-笔记/","link":"","permalink":"http://kayuyu1.github.io/2020/04/03/day01%E3%80%90Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%91-%E7%AC%94%E8%AE%B0/","excerpt":"day01【Object类、常用API】","text":"day01【Object类、常用API】 主要内容 Object类 Date类 DateFormat类 Calendar类 System类 StringBuilder类 包装类 教学目标-[ ] 能够说出Object类的特点-[ ] 能够重写Object类的toString方法-[ ] 能够重写Object类的equals方法-[ ] 能够使用日期类输出当前日期-[ ] 能够使用将日期格式化为字符串的方法-[ ] 能够使用将字符串转换成日期的方法-[ ] 能够使用System类的数组复制方法-[ ] 能够使用System类获取当前毫秒时刻值-[ ] 能够说出使用StringBuilder类可以解决的问题-[ ] 能够使用StringBuilder进行字符串拼接操作-[ ] 能够说出8种基本类型对应的包装类名称-[ ] 能够说出自动装箱、自动拆箱的概念-[ ] 能够将字符串转换为对应的基本类型-[ ] 能够将基本类型转换为对应的字符串 第一章 Object类1.1 概述java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。 如果一个类没有特别指定父类， 那么默认则继承自Object类。例如： 123public class MyClass /*extends Object*/ &#123; // ...&#125; 根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个： public String toString()：返回该对象的字符串表示。 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 1.2 toString方法方法摘要 public String toString()：返回该对象的字符串表示。 toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。 由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。 覆盖重写如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类： 1234567891011public class Person &#123; private String name; private int age; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; // 省略构造器与Getter Setter&#125; 在IntelliJ IDEA中，可以点击Code菜单中的Generate...，也可以使用快捷键alt+insert，点击toString()选项。选择需要包含的成员变量并确定。如下图所示： 小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。 1.3 equals方法方法摘要 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。 默认地址比较如果没有覆盖重写equals方法，那么Object类中默认进行==运算符的对象地址比较，只要不是同一个对象，结果必然为false。 对象内容比较如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如： 1234567891011121314151617181920import java.util.Objects;public class Person &#123; private String name; private int age; @Override public boolean equals(Object o) &#123; // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; // 转换为当前类型 Person person = (Person) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125;&#125; 这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用Code菜单中的Generate…选项，也可以使用快捷键alt+insert，并选择equals() and hashCode()进行自动代码生成。 tips：Object类当中的hashCode等其他方法，今后学习。 1.4 Objects类在刚才IDEA自动重写equals代码中，使用到了java.util.Objects类，那么这个类是什么呢？ 在JDK7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。 在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下： public static boolean equals(Object a, Object b):判断两个对象是否相等。 我们可以查看一下源码，学习一下： 123public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b)); &#125; 第二章 日期时间类2.1 Date类概述java.util.Date类 表示特定的瞬间，精确到毫秒。 继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。 public Date()：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 public Date(long date)：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。 简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如： 12345678910import java.util.Date;public class Demo01Date &#123; public static void main(String[] args) &#123; // 创建日期对象，把当前的时间 System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2018 // 创建日期对象，把当前的毫秒值转成日期对象 System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970 &#125;&#125; tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。 常用方法Date类中的多数方法已经过时，常用的方法有： public long getTime() 把日期对象转换成对应的时间毫秒值。 2.2 DateFormat类java.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。 格式化：按照指定的格式，从Date对象转换为String对象。 解析：按照指定的格式，从String对象转换为Date对象。 构造方法由于DateFormat为抽象类，不能直接使用，所以需要常用的子类java.text.SimpleDateFormat。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为： public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。 参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。 创建SimpleDateFormat对象的代码如： 123456789import java.text.DateFormat;import java.text.SimpleDateFormat;public class Demo02SimpleDateFormat &#123; public static void main(String[] args) &#123; // 对应的日期格式如：2018-01-16 15:06:38 DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); &#125; &#125; 常用方法DateFormat类的常用方法有： public String format(Date date)：将Date对象格式化为字符串。 public Date parse(String source)：将字符串解析为Date对象。 format方法使用format方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;/* 把Date对象转换成String*/public class Demo03DateFormatMethod &#123; public static void main(String[] args) &#123; Date date = new Date(); // 创建日期格式化对象,在获取格式化对象时可以指定风格 DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str = df.format(date); System.out.println(str); // 2008年1月23日 &#125;&#125; parse方法使用parse方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/* 把String转换成Date对象*/public class Demo04DateFormatMethod &#123; public static void main(String[] args) throws ParseException &#123; DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str = \"2018年12月11日\"; Date date = df.parse(str); System.out.println(date); // Tue Dec 11 00:00:00 CST 2018 &#125;&#125; 2.3 练习请使用日期时间相关的API，计算出一个人已经出生了多少天。 思路： 1.获取当前时间对应的毫秒值 2.获取自己出生日期对应的毫秒值 3.两个时间相减（当前时间– 出生日期） 代码实现： 123456789101112131415161718192021public static void function() throws Exception &#123; System.out.println(\"请输入出生日期 格式 YYYY-MM-dd\"); // 获取出生日期,键盘输入 String birthdayString = new Scanner(System.in).next(); // 将字符串日期,转成Date对象 // 创建SimpleDateFormat对象,写日期模式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); // 调用方法parse,字符串转成日期对象 Date birthdayDate = sdf.parse(birthdayString); // 获取今天的日期对象 Date todayDate = new Date(); // 将两个日期转成毫秒值,Date类的方法getTime long birthdaySecond = birthdayDate.getTime(); long todaySecond = todayDate.getTime(); long secone = todaySecond-birthdaySecond; if (secone &lt; 0)&#123; System.out.println(\"还没出生呢\"); &#125; else &#123; System.out.println(secone/1000/60/60/24); &#125;&#125; 2.4 Calendar类概念日历我们都见过 java.util.Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。 获取方式Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下： Calendar静态方法 public static Calendar getInstance()：使用默认时区和语言环境获得一个日历 例如： 1234567import java.util.Calendar;public class Demo06CalendarInit &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); &#125; &#125; 常用方法根据Calendar类的API文档，常用方法有： public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 Calendar类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（从0开始，可以+1使用） DAY_OF_MONTH 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为1，可以-1使用） get/set方法get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示： 123456789101112131415import java.util.Calendar;public class CalendarUtil &#123; public static void main(String[] args) &#123; // 创建Calendar对象 Calendar cal = Calendar.getInstance(); // 设置年 int year = cal.get(Calendar.YEAR); // 设置月 int month = cal.get(Calendar.MONTH) + 1; // 设置日 int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); &#125; &#125; 123456789import java.util.Calendar;public class Demo07CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, 2020); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2020年1月17日 &#125;&#125; add方法add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如： 123456789101112import java.util.Calendar;public class Demo08CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2018年1月17日 // 使用add方法 cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天 cal.add(Calendar.YEAR, -3); // 减3年 System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2015年1月18日; &#125;&#125; getTime方法Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。 12345678910import java.util.Calendar;import java.util.Date;public class Demo09CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); Date date = cal.getTime(); System.out.println(date); // Tue Jan 16 16:03:09 CST 2018 &#125;&#125; 小贴士： ​ 西方星期的开始为周日，中国为周一。 ​ 在Calendar类中，月份的表示是以0-11代表1-12月。 ​ 日期是有大小关系的，时间靠后，时间越大。 第三章 System类java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有： public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 3.1 currentTimeMillis方法实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值 12345678import java.util.Date;public class SystemDemo &#123; public static void main(String[] args) &#123; //获取当前时间毫秒值 System.out.println(System.currentTimeMillis()); // 1516090531144 &#125;&#125; 练习验证for循环打印数字1-9999所需要使用的时间（毫秒） 12345678910public class SystemTest1 &#123; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) &#123; System.out.println(i); &#125; long end = System.currentTimeMillis(); System.out.println(\"共耗时毫秒：\" + (end - start)); &#125;&#125; 3.2 arraycopy方法 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为： 参数序号 参数名称 参数类型 参数含义 1 src Object 源数组 2 srcPos int 源数组索引起始位置 3 dest Object 目标数组 4 destPos int 目标数组索引起始位置 5 length int 复制元素个数 练习将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10] 12345678910111213import java.util.Arrays;public class Demo11SystemArrayCopy &#123; public static void main(String[] args) &#123; int[] src = new int[]&#123;1,2,3,4,5&#125;; int[] dest = new int[]&#123;6,7,8,9,10&#125;; System.arraycopy( src, 0, dest, 0, 3); /*代码运行后：两个数组中的元素发生了变化 src数组元素[1,2,3,4,5] dest数组元素[1,2,3,9,10] */ &#125;&#125; 第四章 StringBuilder类4.1 字符串拼接问题由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如： 1234567public class StringDemo &#123; public static void main(String[] args) &#123; String s = \"Hello\"; s += \"World\"; System.out.println(s); &#125;&#125; 在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。 根据这句话分析我们的代码，其实总共产生了三个字符串，即&quot;Hello&quot;、&quot;World&quot;和&quot;HelloWorld&quot;。引用变量s首先指向Hello对象，最终指向拼接出来的新字符串对象，即HelloWord 。 由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用java.lang.StringBuilder类。 4.2 StringBuilder概述查阅java.lang.StringBuilder的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。 原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。 它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充) 4.3 构造方法根据StringBuilder的API文档，常用构造方法有2个： public StringBuilder()：构造一个空的StringBuilder容器。 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。 123456789public class StringBuilderDemo &#123; public static void main(String[] args) &#123; StringBuilder sb1 = new StringBuilder(); System.out.println(sb1); // (空白) // 使用带参构造 StringBuilder sb2 = new StringBuilder(\"itcast\"); System.out.println(sb2); // itcast &#125;&#125; 4.4 常用方法StringBuilder常用的方法有2个： public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 append方法append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如： 12345678910111213141516171819202122public class Demo02StringBuilder &#123; public static void main(String[] args) &#123; //创建对象 StringBuilder builder = new StringBuilder(); //public StringBuilder append(任意类型) StringBuilder builder2 = builder.append(\"hello\"); //对比一下 System.out.println(\"builder:\"+builder); System.out.println(\"builder2:\"+builder2); System.out.println(builder == builder2); //true // 可以添加 任何类型 builder.append(\"hello\"); builder.append(\"world\"); builder.append(true); builder.append(100); // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。 // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下 //链式编程 builder.append(\"hello\").append(\"world\").append(true).append(100); System.out.println(\"builder:\"+builder); &#125;&#125; 备注：StringBuilder已经覆盖重写了Object当中的toString方法。 toString方法通过toString方法，StringBuilder对象将会转换为不可变的String对象。如： 123456789public class Demo16StringBuilder &#123; public static void main(String[] args) &#123; // 链式创建 StringBuilder sb = new StringBuilder(\"Hello\").append(\"World\").append(\"Java\"); // 调用方法 String str = sb.toString(); System.out.println(str); // HelloWorldJava &#125;&#125; 第五章 包装类5.1 概述Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下： 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 5.2 装箱与拆箱基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“： 装箱：从基本类型转换为对应的包装类对象。 拆箱：从包装类对象转换为对应的基本类型。 用Integer与 int为例：（看懂代码即可） 基本数值—-&gt;包装对象 12Integer i = new Integer(4);//使用构造函数函数Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法 包装对象—-&gt;基本数值 1int num = i.intValue(); 5.3自动装箱与自动拆箱由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如： 123Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。 5.3 基本类型与字符串之间的转换基本类型转换为String 基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： 1基本类型直接与””相连接即可；如：34+&quot;&quot; String转换成对应的基本类型 除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型： public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。 代码使用（仅以Integer类的静态方法parseXxx为例）如： 12345public class Demo18WrapperParse &#123; public static void main(String[] args) &#123; int num = Integer.parseInt(\"100\"); &#125;&#125; 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。","categories":[],"tags":[{"name":"javase","slug":"javase","permalink":"http://kayuyu1.github.io/tags/javase/"}]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2020-04-03T08:48:34.000Z","updated":"2020-04-03T11:04:52.251Z","comments":true,"path":"2020/04/03/我的第一篇博客文章/","link":"","permalink":"http://kayuyu1.github.io/2020/04/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"我的博客编写","text":"我的博客编写 标题使用标题时需要# 段落这是第一段这是第二段 区块引用这是一段引用 超链接百度 图片 无序列表 无序列表 无序列表 有序列表1.有序12.尤须2 分割线","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-04-03T08:43:13.270Z","updated":"2020-04-03T13:20:24.082Z","comments":true,"path":"2020/04/03/hello-world/","link":"","permalink":"http://kayuyu1.github.io/2020/04/03/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://kayuyu1.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[],"tags":[{"name":"JUC","slug":"JUC","permalink":"http://kayuyu1.github.io/tags/JUC/"},{"name":"mysql","slug":"mysql","permalink":"http://kayuyu1.github.io/tags/mysql/"},{"name":"JVM","slug":"JVM","permalink":"http://kayuyu1.github.io/tags/JVM/"},{"name":"javaee","slug":"javaee","permalink":"http://kayuyu1.github.io/tags/javaee/"},{"name":"javase","slug":"javase","permalink":"http://kayuyu1.github.io/tags/javase/"},{"name":"分布式","slug":"分布式","permalink":"http://kayuyu1.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://kayuyu1.github.io/tags/SpringBoot/"},{"name":"Vue","slug":"Vue","permalink":"http://kayuyu1.github.io/tags/Vue/"},{"name":"SSM","slug":"SSM","permalink":"http://kayuyu1.github.io/tags/SSM/"},{"name":"bug","slug":"bug","permalink":"http://kayuyu1.github.io/tags/bug/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://kayuyu1.github.io/tags/SpringMVC/"},{"name":"设计模式","slug":"设计模式","permalink":"http://kayuyu1.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Spring","slug":"Spring","permalink":"http://kayuyu1.github.io/tags/Spring/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://kayuyu1.github.io/tags/MyBatis/"},{"name":"Mysql","slug":"Mysql","permalink":"http://kayuyu1.github.io/tags/Mysql/"},{"name":"maven","slug":"maven","permalink":"http://kayuyu1.github.io/tags/maven/"},{"name":"reids","slug":"reids","permalink":"http://kayuyu1.github.io/tags/reids/"},{"name":"Jquery","slug":"Jquery","permalink":"http://kayuyu1.github.io/tags/Jquery/"},{"name":"JDBC","slug":"JDBC","permalink":"http://kayuyu1.github.io/tags/JDBC/"},{"name":"随笔","slug":"随笔","permalink":"http://kayuyu1.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}