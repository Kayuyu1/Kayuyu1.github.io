<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MyBatis一对多与多对一</title>
    <url>/2020/04/29/MyBatis%E4%B8%80%E5%AF%B9%E5%A4%9A%E4%B8%8E%E5%A4%9A%E5%AF%B9%E4%B8%80/</url>
    <content><![CDATA[<h1 id="1-多对一"><a href="#1-多对一" class="headerlink" title="1.多对一"></a>1.多对一</h1><p>基本表一个老师多个学生</p>
<a id="more"></a>

<img src="/2020/04/29/MyBatis%E4%B8%80%E5%AF%B9%E5%A4%9A%E4%B8%8E%E5%A4%9A%E5%AF%B9%E4%B8%80/1.png" class="" title="表结构">

<h2 id="（1）第一种按照查询嵌套，子查询"><a href="#（1）第一种按照查询嵌套，子查询" class="headerlink" title="（1）第一种按照查询嵌套，子查询"></a>（1）第一种按照查询嵌套，子查询</h2><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">   &lt;!--按照查询嵌套，子查询--&gt;<br>&lt;select id=<span class="hljs-string">"getStudentTeacher"</span>  resultMap=<span class="hljs-string">"StudentMap"</span>&gt;<br>    select *from mybatis.student;<br>&lt;/select&gt;<br>    &lt;resultMap id=<span class="hljs-string">"StudentMap"</span> type=<span class="hljs-string">"Student"</span>&gt;<br>        &lt;result column=<span class="hljs-string">"id"</span> property=<span class="hljs-string">"id"</span>/&gt;<br>        &lt;result column=<span class="hljs-string">"name"</span> property=<span class="hljs-string">"name"</span>/&gt;<br>        &lt;!--根据tid查询teacher--&gt;<br>        &lt;association property=<span class="hljs-string">"teacher"</span> column=<span class="hljs-string">"tid"</span>  javaType=<span class="hljs-string">"Teacher"</span> select=<span class="hljs-string">"getTeacher"</span>/&gt;<br>    &lt;/resultMap&gt;<br>&lt;select id=<span class="hljs-string">"getTeacher"</span> resultType=<span class="hljs-string">"Teacher"</span>&gt;<br>    select *from mybatis.teacher where #&#123;id&#125;;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure>

<p>相当于以下sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> *<span class="hljs-keyword">from</span> mybatis.student <span class="hljs-keyword">where</span> tid <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> mybatis.teacher);<br></code></pre></td></tr></table></figure>

<p><u><strong>注意</strong>：getTeacher中的#{id}是从getStudentTeacher中查询得到的tid</u></p>
<h2 id="（2）第二种按照结果嵌套查询，关联查询"><a href="#（2）第二种按照结果嵌套查询，关联查询" class="headerlink" title="（2）第二种按照结果嵌套查询，关联查询"></a>（2）第二种按照结果嵌套查询，关联查询</h2><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">&lt;!--按照结果嵌套,关联查询--&gt;<br>&lt;select id=<span class="hljs-string">"getStudentTeacher2"</span> resultMap=<span class="hljs-string">"StudentMap2"</span>&gt;<br>    select s.id sid,s.name sname,t.name tname,t.id tid<br>    from mybatis.student s ,mybatis.teacher t<br>    where s.tid=t.id;<br>&lt;/select&gt;<br>&lt;resultMap id=<span class="hljs-string">"StudentMap2"</span> type=<span class="hljs-string">"Student"</span>&gt;<br>    &lt;result column=<span class="hljs-string">"sid"</span> property=<span class="hljs-string">"id"</span>/&gt;<br>    &lt;result column=<span class="hljs-string">"sname"</span> property=<span class="hljs-string">"name"</span>/&gt;<br>    &lt;association property=<span class="hljs-string">"teacher"</span> javaType=<span class="hljs-string">"Teacher"</span>&gt;<br>        &lt;result column=<span class="hljs-string">"tid"</span> property=<span class="hljs-string">"id"</span>/&gt;<br>        &lt;result column=<span class="hljs-string">"tname"</span> property=<span class="hljs-string">"name"</span>/&gt;<br>    &lt;/association&gt;<br>&lt;/resultMap&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> s.id <span class="hljs-keyword">sid</span>,s.name sname,t.name tname,t.id tid<br>  <span class="hljs-keyword">from</span> mybatis.student s ,mybatis.teacher t<br>  <span class="hljs-keyword">where</span> s.tid=t.id;<br></code></pre></td></tr></table></figure>

<h1 id="2-一对多"><a href="#2-一对多" class="headerlink" title="2.一对多"></a>2.一对多</h1><h2 id="（1）第一种按照查询嵌套，子查询-1"><a href="#（1）第一种按照查询嵌套，子查询-1" class="headerlink" title="（1）第一种按照查询嵌套，子查询"></a>（1）第一种按照查询嵌套，子查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">&lt;select id="getTeacherAndStudent2" resultMap="TeacherAndStudent2" parameterType="_int"&gt;<br><span class="hljs-keyword">select</span> *<span class="hljs-keyword">from</span> mybatis.teacher <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>=<span class="hljs-comment">#&#123;tid&#125;;</span><br>&lt;/<span class="hljs-keyword">select</span>&gt;<br>&lt;resultMap <span class="hljs-keyword">id</span>=<span class="hljs-string">"TeacherAndStudent2"</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"Teacher"</span>&gt;<br>    &lt;<span class="hljs-keyword">result</span> property=<span class="hljs-string">"id"</span> <span class="hljs-keyword">column</span>=<span class="hljs-string">"id"</span>/&gt;<br>    &lt;<span class="hljs-keyword">result</span> property=<span class="hljs-string">"name"</span> <span class="hljs-keyword">column</span>=<span class="hljs-string">"name"</span>/&gt;<br>    &lt;collection property=<span class="hljs-string">"students"</span> javaType=<span class="hljs-string">"ArrayList"</span> ofType=<span class="hljs-string">"Student"</span> <span class="hljs-keyword">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-keyword">select</span>=<span class="hljs-string">"getStudent"</span>/&gt;<br>&lt;/resultMap&gt;<br>&lt;<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>=<span class="hljs-string">"getStudent"</span> resultType=<span class="hljs-string">"Student"</span>&gt;<br>    <span class="hljs-keyword">select</span> *<span class="hljs-keyword">from</span> mybatis.student <span class="hljs-keyword">where</span> tid=<span class="hljs-comment">#&#123;id&#125;;</span><br>&lt;/<span class="hljs-keyword">select</span>&gt;<br></code></pre></td></tr></table></figure>

<p><u><strong>注意</strong>：getStudent中的#{id}是从getTeacherAndStudent2中查询得到的tid并不是从方法传过来的参数</u></p>
<h2 id="（2）第二种按照结果嵌套查询，关联查询-1"><a href="#（2）第二种按照结果嵌套查询，关联查询-1" class="headerlink" title="（2）第二种按照结果嵌套查询，关联查询"></a>（2）第二种按照结果嵌套查询，关联查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">&lt;select id="getTeacherAndStudent" resultMap="TeacherAndStudent" parameterType="_int"&gt;<br><span class="hljs-keyword">select</span> t.name tname,t.id,s.name sname,s.id <span class="hljs-keyword">sid</span><br><span class="hljs-keyword">from</span> mybatis.teacher t ,mybatis.student s<br><span class="hljs-keyword">where</span> s.tid=t.id <span class="hljs-keyword">and</span> t.id=<span class="hljs-comment">#&#123;tid&#125;;</span><br>&lt;/<span class="hljs-keyword">select</span>&gt;<br>&lt;resultMap <span class="hljs-keyword">id</span>=<span class="hljs-string">"TeacherAndStudent"</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"Teacher"</span>&gt;<br>    &lt;<span class="hljs-keyword">result</span> property=<span class="hljs-string">"id"</span> <span class="hljs-keyword">column</span>=<span class="hljs-string">"id"</span>/&gt;<br>    &lt;<span class="hljs-keyword">result</span> property=<span class="hljs-string">"name"</span> <span class="hljs-keyword">column</span>=<span class="hljs-string">"tname"</span>/&gt;<br>    &lt;!<span class="hljs-comment">--泛型用ofType--&gt;</span><br>    &lt;collection property=<span class="hljs-string">"students"</span> ofType=<span class="hljs-string">"Student"</span>&gt;<br>        &lt;<span class="hljs-keyword">result</span> property=<span class="hljs-string">"id"</span> <span class="hljs-keyword">column</span>=<span class="hljs-string">"sid"</span>/&gt;<br>        &lt;<span class="hljs-keyword">result</span> property=<span class="hljs-string">"name"</span> <span class="hljs-keyword">column</span>=<span class="hljs-string">"sname"</span>/&gt;<br>        &lt;<span class="hljs-keyword">result</span> property=<span class="hljs-string">"tid"</span> <span class="hljs-keyword">column</span>=<span class="hljs-string">"tid"</span>/&gt;<br>    &lt;/collection&gt;<br>&lt;/resultMap&gt;<br></code></pre></td></tr></table></figure>

<h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><p>关联：association【多对一使用关键字】</p>
<p>集合：collection【一对多关键字】</p>
<p>javaType:用来指定实体类的指定类型</p>
<p>ofType：用来指定集合中的约束类型，例如：List<Student>,  ofType就该等于”Student”</p>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis生命周期</title>
    <url>/2020/04/28/mybatis%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="MyBatis生命周期"><a href="#MyBatis生命周期" class="headerlink" title="MyBatis生命周期"></a>MyBatis生命周期</h1><h2 id="1-SqlSessionFactoryBuilder"><a href="#1-SqlSessionFactoryBuilder" class="headerlink" title="1.SqlSessionFactoryBuilder"></a>1.SqlSessionFactoryBuilder</h2><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 </p>
<a id="more"></a>

<h2 id="2-SqlSessionFactory"><a href="#2-SqlSessionFactory" class="headerlink" title="2.SqlSessionFactory"></a>2.SqlSessionFactory</h2><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
<p><strong>（类似连接池）</strong></p>
<h2 id="3-SqlSession"><a href="#3-SqlSession" class="headerlink" title="3.SqlSession"></a>3.SqlSession</h2><p><strong>可以想象成连接池的一次连接请求</strong></p>
<p><strong>SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它最好用完就关闭</strong></p>
<h2 id="4-Mapper"><a href="#4-Mapper" class="headerlink" title="4.Mapper"></a>4.Mapper</h2><p><strong>代表具体的业务实现</strong>，<strong>底层实现是动态代理</strong></p>
<h2 id="5-图示"><a href="#5-图示" class="headerlink" title="5.图示"></a>5.图示</h2><img src="/2020/04/28/mybatis%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/1.png" class="" title="生命周期">

<img src="/2020/04/28/mybatis%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/2.png" class="" title="层次">

]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis配置druid</title>
    <url>/2020/04/27/MyBatis%E9%85%8D%E7%BD%AEdruid/</url>
    <content><![CDATA[<h1 id="MyBatis配置druid步骤"><a href="#MyBatis配置druid步骤" class="headerlink" title="MyBatis配置druid步骤"></a>MyBatis配置druid步骤</h1><h2 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1.导入依赖"></a>1.导入依赖</h2><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;<br>    &lt;artifactId&gt;druid&lt;/artifactId&gt;<br>    &lt;version&gt;1.0.9&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="2-创建druid工厂类"><a href="#2-创建druid工厂类" class="headerlink" title="2.创建druid工厂类"></a>2.创建druid工厂类</h2><p>虽然Druid提供了一个同名的DruidDataSourceFactory类，但是不能在MyBatis中直接使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidUtils</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PooledDataSourceFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DruidUtils</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.dataSource = <span class="hljs-keyword">new</span> DruidDataSource();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-创建druid配置文件druid-properties"><a href="#3-创建druid配置文件druid-properties" class="headerlink" title="3.创建druid配置文件druid.properties"></a>3.创建druid配置文件druid.properties</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">username=root<br>password=<span class="hljs-number">123456</span><br>jdbcUrl=jdbc:mysql:<span class="hljs-comment">///mybatis?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8</span><br>driverClass=com.mysql.jdbc.Driver<br></code></pre></td></tr></table></figure>

<h2 id="4-设置mybatis-config-xml"><a href="#4-设置mybatis-config-xml" class="headerlink" title="4.设置mybatis-config.xml"></a>4.设置mybatis-config.xml</h2><h3 id="1-引入外部文件"><a href="#1-引入外部文件" class="headerlink" title="(1)引入外部文件"></a>(1)引入外部文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&lt;!--引入外部配置文件--&gt;<br>&lt;properties resource=<span class="hljs-string">"druid.properties"</span>/&gt;<br></code></pre></td></tr></table></figure>

<h3 id="2-修改属性配置"><a href="#2-修改属性配置" class="headerlink" title="(2)修改属性配置"></a>(2)修改属性配置</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">&lt;dataSource type=<span class="hljs-string">"com.ky.utils.DruidUtils"</span>&gt;<br>    &lt;property name=<span class="hljs-string">"driverClass"</span> value=<span class="hljs-string">"$&#123;driverClass&#125;"</span>/&gt;<br>    &lt;property name=<span class="hljs-string">"jdbcUrl"</span> value=<span class="hljs-string">"$&#123;jdbcUrl&#125;"</span>/&gt;<br>    &lt;property name=<span class="hljs-string">"username"</span> value=<span class="hljs-string">"$&#123;username&#125;"</span>/&gt;<br>    &lt;property name=<span class="hljs-string">"password"</span> value=<span class="hljs-string">"$&#123;password&#125;"</span>/&gt;<br>&lt;/dataSource&gt;<br></code></pre></td></tr></table></figure>

<p><strong>注意</strong>：因为在DruidAbstractDataSource的源码为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> String jdbcUrl;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> String driverClass;<br></code></pre></td></tr></table></figure>

<p>所以设置property的时候尽量以driverClass和jdbcUrl命名，如果以默认driver命名（默认的url不改不会报错，不知道为啥）否则会报错</p>
<p>Caused by: org.apache.ibatis.reflection.ReflectionException: Could not set property ‘driver’ of ‘class com.alibaba.druid.pool.DruidDataSource’ with value ‘com.mysql.jdbc.Driver’ Cause: java.lang.IllegalArgumentException: argument type mismatch </p>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>关于update多个字段的某细节</title>
    <url>/2020/04/26/%E5%85%B3%E4%BA%8Eupdate%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84%E6%9F%90%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<h1 id="在使用update更新多条语句的时候不能使用and连接"><a href="#在使用update更新多条语句的时候不能使用and连接" class="headerlink" title="在使用update更新多条语句的时候不能使用and连接"></a>在使用update更新多条语句的时候不能使用and连接</h1><a id="more"></a>

<p>首先先来看一个现象</p>
<p>这是表的原始数据：</p>
<img src="/2020/04/26/%E5%85%B3%E4%BA%8Eupdate%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84%E6%9F%90%E7%BB%86%E8%8A%82/1.png" class="" title="原始数据">

<p>这是执行语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> <span class="hljs-keyword">test</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">2</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'kyky'</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>可结果却和预期不同：</p>
{% asset_img 2.png 修改%}

<p>为什么吗？</p>
<p>来看官方文档：</p>
{% asset_img update官方文档.png  官方文档%}

<p>assignment_list的格式是以逗号分隔的col_name=value列表 所以不能用and连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> <span class="hljs-keyword">test</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">2</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'kyky'</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">1</span>;<br><span class="hljs-comment">--相当于以下语句</span><br><span class="hljs-keyword">update</span> <span class="hljs-keyword">test</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">id</span>= (<span class="hljs-number">2</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'kyky'</span>) <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">1</span>;<br><span class="hljs-comment">/*(2 and name='kyky')返回的是一个布尔值flase,子啊数据库中flase为0，所以原本改修改为2的id变成了0，而name不改变。*/</span><br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么set不能存重复的值</title>
    <url>/2020/04/25/%E4%B8%BA%E4%BB%80%E4%B9%88set%E4%B8%8D%E8%83%BD%E5%AD%98%E9%87%8D%E5%A4%8D%E7%9A%84%E5%80%BC/</url>
    <content><![CDATA[<h1 id="为什么set不能存储重复的值"><a href="#为什么set不能存储重复的值" class="headerlink" title="为什么set不能存储重复的值"></a>为什么set不能存储重复的值</h1><p>首先看一段代码<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SetDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Set set=<span class="hljs-keyword">new</span> HashSet();<br>        String str1=<span class="hljs-keyword">new</span> String(<span class="hljs-string">"abc"</span>);<br>        String str2=<span class="hljs-keyword">new</span> String(<span class="hljs-string">"abc"</span>);<br>        String str3=<span class="hljs-string">"重地"</span>;<br>        String str4=<span class="hljs-string">"通话"</span>;<br>        String str5=<span class="hljs-string">"abc"</span>;<br><br>        set.add(str1);<br>        set.add(str2);<br>        set.add(str3);<br>        set.add(str4);<br>        set.add(str5);<br><br>        System.out.println(set);<br>    &#125;<br></code></pre></td></tr></table></figure>

<img src="/2020/04/25/%E4%B8%BA%E4%BB%80%E4%B9%88set%E4%B8%8D%E8%83%BD%E5%AD%98%E9%87%8D%E5%A4%8D%E7%9A%84%E5%80%BC/%E6%8E%A7%E5%88%B6%E5%8F%B0.png" class="" title="输出">

<p>原因：</p>
<img src="/2020/04/25/%E4%B8%BA%E4%BB%80%E4%B9%88set%E4%B8%8D%E8%83%BD%E5%AD%98%E9%87%8D%E5%A4%8D%E7%9A%84%E5%80%BC/06_Set%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E5%85%83%E7%B4%A0%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%8E%9F%E7%90%86.bmp" class="" title="原理">

<p>补充：</p>
<img src="/2020/04/25/%E4%B8%BA%E4%BB%80%E4%B9%88set%E4%B8%8D%E8%83%BD%E5%AD%98%E9%87%8D%E5%A4%8D%E7%9A%84%E5%80%BC/05_HashSet%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89.bmp" class="" title="HashSet">]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>线程与同步</title>
    <url>/2020/04/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="第一章-线程"><a href="#第一章-线程" class="headerlink" title="第一章 线程"></a>第一章 线程</h1><h2 id="1-1-多线程原理"><a href="#1-1-多线程原理" class="headerlink" title="1. 1 多线程原理"></a>1. 1 多线程原理</h2><h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><a id="more"></a>

<h3 id="自定义线程类："><a href="#自定义线程类：" class="headerlink" title="自定义线程类："></a>自定义线程类：</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 利用继承中的特点</span><br><span class="hljs-comment">* 将线程名称传递 进行设置</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span></span>&#123;<br><span class="hljs-keyword">super</span>(name);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 重写run方法</span><br><span class="hljs-comment">* 定义线程要执行的代码</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =  <span class="hljs-number">0</span> ; i &lt;  <span class="hljs-number">20</span> ; i++) &#123;<br><span class="hljs-comment">//getName()方法 来自父亲</span><br>    <span class="hljs-comment">//getName()方法 来自父亲</span><br>System.out.println(getName()+i);<br>&#125;&#125;&#125;<br></code></pre></td></tr></table></figure>

<h3 id="测试类："><a href="#测试类：" class="headerlink" title="测试类："></a>测试类：</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">"这里是main线程"</span>);<br>MyThread mt = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">"小强"</span>);<br>mt.start();<span class="hljs-comment">//开启了一个新的线程</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =  <span class="hljs-number">0</span> ; i &lt;  <span class="hljs-number">20</span> ; i++) &#123;<br>System.out.println(<span class="hljs-string">"旺财:"</span>+i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h3><img src="/2020/04/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5/%E7%BA%BF%E7%A8%8B%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="" title="线程流程图">

<p>程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的<br>start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。</p>
<p>通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？我们再来讲一讲原理。</p>
<p>多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明：</p>
<img src="/2020/04/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5/%E6%A0%88%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86%E5%9B%BE.bmp" class="" title="栈内存图">

<p>多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。</p>
<h3 id="当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。"><a href="#当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。" class="headerlink" title="当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。"></a>当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。</h3><h2 id="1-2-Thread类"><a href="#1-2-Thread类" class="headerlink" title="1. 2 Thread类"></a>1. 2 Thread类</h2><p>在上一天内容中我们已经可以完成最基本的线程开启，那么在我们完成操作过程中用到了java.lang.Thread类，<br>API中该类中定义了有关线程的一些方法，具体如下：</p>
<p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">()</span>:分配一个新的线程对象。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(String name)</span>:分配一个指定名字的新的线程对象。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(Runnable target)</span>:分配一个带有指定目标新的线程对象。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(Runnable target,String name)</span>:分配一个带有指定目标新的线程对象并指定名字。</span><br></code></pre></td></tr></table></figure>

<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span>:获取当前线程名称。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span>:导致此线程开始执行</span>; Java虚拟机调用此线程的run方法。<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>:此线程要执行的任务在此处定义代码。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span>:使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Thread <span class="hljs-title">currentThread</span><span class="hljs-params">()</span>:返回对当前正在执行的线程对象的引用。</span><br></code></pre></td></tr></table></figure>

<p>翻阅API后得知创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式，方式一我<br>们上一天已经完成，接下来讲解方式二实现的方式。</p>
<h2 id="1-3-创建线程方式二"><a href="#1-3-创建线程方式二" class="headerlink" title="1. 3 创建线程方式二"></a>1. 3 创建线程方式二</h2><p>采用java.lang.Runnable也是非常常见的一种，我们只需要重写run方法即可。</p>
<p>步骤如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>. 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。<br><span class="hljs-number">2</span>. 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正<br>的线程对象。<br><span class="hljs-number">3</span>. 调用线程对象的start()方法来启动线程。<br></code></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =  <span class="hljs-number">0</span> ; i &lt;  <span class="hljs-number">20</span> ; i++) &#123;<br>System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" "</span>+i);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//创建自定义类对象 线程任务对象</span><br>MyRunnable mr = <span class="hljs-keyword">new</span> MyRunnable();<br><span class="hljs-comment">//创建线程对象</span><br>Thread t = <span class="hljs-keyword">new</span> Thread(mr, <span class="hljs-string">"小强"</span>);<br>t.start();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =  <span class="hljs-number">0</span> ; i &lt;  <span class="hljs-number">20</span> ; i++) &#123;<br>System.out.println(<span class="hljs-string">"旺财 "</span> + i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程<br>代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。</p>
<p>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread<br>对象的start()方法来运行多线程代码。</p>
<p>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现<br>Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程<br>编程的基础。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">tips:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。<br>而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。<br></code></pre></td></tr></table></figure>

<h2 id="1-4-Thread和Runnable的区别"><a href="#1-4-Thread和Runnable的区别" class="headerlink" title="1. 4 Thread和Runnable的区别"></a>1. 4 Thread和Runnable的区别</h2><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。</p>
<p>总结：</p>
<p>实现Runnable接口比继承Thread类所具有的优势：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>. 适合多个相同的程序代码的线程去共享同一个资源。<br><span class="hljs-number">2</span>. 可以避免java中的单继承的局限性。<br><span class="hljs-number">3</span>. 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。<br><span class="hljs-number">4</span>. 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。<br>扩充：在java中，每次程序运行至少启动 <span class="hljs-number">2</span> 个线程。一个是main线程，一个是垃圾收集线程。因为每当使用<br>java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进<br>程。<br></code></pre></td></tr></table></figure>

<h2 id="1-5-匿名内部类方式实现线程的创建"><a href="#1-5-匿名内部类方式实现线程的创建" class="headerlink" title="1. 5 匿名内部类方式实现线程的创建"></a>1. 5 匿名内部类方式实现线程的创建</h2><h3 id="使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。"><a href="#使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。" class="headerlink" title="使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。"></a>使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。</h3><p>使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>^ <span class="hljs-class"><span class="hljs-keyword">class</span>^ <span class="hljs-title">NoNameInnerClassThread</span>^ </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// new Runnable()&#123;</span><br><span class="hljs-comment">// public void run()&#123;</span><br><span class="hljs-comment">// for (int i =  0 ; i &lt;  20 ; i++) &#123;</span><br><span class="hljs-comment">// System.out.println("张宇:"+i);</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// &#125;; //‐‐‐这个整体 相当于new MyRunnable()</span><br>Runnable r = <span class="hljs-keyword">new</span> Runnable()&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =  <span class="hljs-number">0</span> ; i &lt;  <span class="hljs-number">20</span> ; i++) &#123;<br>System.out.println(<span class="hljs-string">"张宇:"</span>+i);<br>&#125;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">new</span> Thread(r).start();<br></code></pre></td></tr></table></figure>

<h1 id="第二章-线程安全"><a href="#第二章-线程安全" class="headerlink" title="第二章 线程安全"></a>第二章 线程安全</h1><h2 id="2-1-线程安全"><a href="#2-1-线程安全" class="headerlink" title="2. 1 线程安全"></a>2. 1 线程安全</h2><h3 id="如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样"><a href="#如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样" class="headerlink" title="如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样"></a>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样</h3><h3 id="的，而且其他的变量的值也和预期的是一样的，就是线程安全的。"><a href="#的，而且其他的变量的值也和预期的是一样的，就是线程安全的。" class="headerlink" title="的，而且其他的变量的值也和预期的是一样的，就是线程安全的。"></a>的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</h3><h3 id="我们通过一个案例，演示线程的安全问题："><a href="#我们通过一个案例，演示线程的安全问题：" class="headerlink" title="我们通过一个案例，演示线程的安全问题："></a>我们通过一个案例，演示线程的安全问题：</h3><h3 id="电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是-“葫芦娃大战奥特曼”，本次电影的座位共-100-个"><a href="#电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是-“葫芦娃大战奥特曼”，本次电影的座位共-100-个" class="headerlink" title="电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “葫芦娃大战奥特曼”，本次电影的座位共 100 个"></a>电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “葫芦娃大战奥特曼”，本次电影的座位共 100 个</h3><h3 id="本场电影只能卖-100-张票-。"><a href="#本场电影只能卖-100-张票-。" class="headerlink" title="(本场电影只能卖 100 张票)。"></a>(本场电影只能卖 100 张票)。</h3><h3 id="我们来模拟电影院的售票窗口，实现多个窗口同时卖-“葫芦娃大战奥特曼”这场电影票-多个窗口一起卖这-100-张票"><a href="#我们来模拟电影院的售票窗口，实现多个窗口同时卖-“葫芦娃大战奥特曼”这场电影票-多个窗口一起卖这-100-张票" class="headerlink" title="我们来模拟电影院的售票窗口，实现多个窗口同时卖 “葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这 100 张票)"></a>我们来模拟电影院的售票窗口，实现多个窗口同时卖 “葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这 100 张票)</h3><p>需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟</p>
<p>模拟票：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =  <span class="hljs-number">0</span> ; i &lt;  <span class="hljs-number">20</span> ; i++) &#123;<br>System.out.println(<span class="hljs-string">"费玉清:"</span>+i);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket =  <span class="hljs-number">100</span> ;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 执行卖票操作</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//每个窗口卖票的操作</span><br><span class="hljs-comment">//窗口 永远开启</span><br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-keyword">if</span> (ticket &gt;  <span class="hljs-number">0</span> ) &#123;<span class="hljs-comment">//有票 可以卖</span><br><span class="hljs-comment">//出票操作</span><br><span class="hljs-comment">//使用sleep模拟一下出票时间</span><br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep( <span class="hljs-number">100</span> );<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto‐generated catch block</span><br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//获取当前线程对象的名字</span><br>String name = Thread.currentThread().getName();<br>System.out.println(name + <span class="hljs-string">"正在卖:"</span> + ticket‐‐);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="测试类：-1"><a href="#测试类：-1" class="headerlink" title="测试类："></a>测试类：</h3><h3 id="结果中有一部分这样现象："><a href="#结果中有一部分这样现象：" class="headerlink" title="结果中有一部分这样现象："></a>结果中有一部分这样现象：</h3><img src="/2020/04/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.png" class="" title="线程安全问题">

<h3 id="发现程序出现了两个问题："><a href="#发现程序出现了两个问题：" class="headerlink" title="发现程序出现了两个问题："></a>发现程序出现了两个问题：</h3><h3 id="1-相同的票数-比如-5-这张票被卖了两回。"><a href="#1-相同的票数-比如-5-这张票被卖了两回。" class="headerlink" title="1. 相同的票数,比如 5 这张票被卖了两回。"></a>1. 相同的票数,比如 5 这张票被卖了两回。</h3><h3 id="2-不存在的票，比如-0-票与-1-票，是不存在的。"><a href="#2-不存在的票，比如-0-票与-1-票，是不存在的。" class="headerlink" title="2. 不存在的票，比如 0 票与- 1 票，是不存在的。"></a>2. 不存在的票，比如 0 票与- 1 票，是不存在的。</h3><h3 id="这种问题，几个窗口-线程-票数不同步了，这种问题称为线程不安全。"><a href="#这种问题，几个窗口-线程-票数不同步了，这种问题称为线程不安全。" class="headerlink" title="这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。"></a>这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。</h3><h3 id="线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写"><a href="#线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写" class="headerlink" title="线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写"></a>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写</h3><h3 id="操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，"><a href="#操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，" class="headerlink" title="操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，"></a>操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，</h3><h3 id="否则的话就可能影响线程安全。"><a href="#否则的话就可能影响线程安全。" class="headerlink" title="否则的话就可能影响线程安全。"></a>否则的话就可能影响线程安全。</h3><h2 id="2-2-线程同步"><a href="#2-2-线程同步" class="headerlink" title="2. 2 线程同步"></a>2. 2 线程同步</h2><h3 id="当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。"><a href="#当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。" class="headerlink" title="当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。"></a>当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。</h3><p>要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制<br>(synchronized)来解决。</p>
<p>根据案例简述：</p>
<p>为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。</p>
<p>那么怎么去使用呢？有三种方式完成同步操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//创建线程任务对象</span><br>Ticket ticket = <span class="hljs-keyword">new</span> Ticket();<br><span class="hljs-comment">//创建三个窗口对象</span><br>Thread t <span class="hljs-number">1</span>  = <span class="hljs-keyword">new</span> Thread(ticket, <span class="hljs-string">"窗口 1 "</span>);<br>Thread t <span class="hljs-number">2</span>  = <span class="hljs-keyword">new</span> Thread(ticket, <span class="hljs-string">"窗口 2 "</span>);<br>Thread t <span class="hljs-number">3</span>  = <span class="hljs-keyword">new</span> Thread(ticket, <span class="hljs-string">"窗口 3 "</span>);<br><span class="hljs-comment">//同时卖票</span><br>t <span class="hljs-number">1</span> .start();<br>t <span class="hljs-number">2</span> .start();<br>t <span class="hljs-number">3</span> .start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="窗口-1-线程进入操作的时候，窗口-2-和窗口-3-线程只能在外等着，窗口-1-操作结束，窗口-1-和窗口-2-和窗口-3-才有机会进入代码"><a href="#窗口-1-线程进入操作的时候，窗口-2-和窗口-3-线程只能在外等着，窗口-1-操作结束，窗口-1-和窗口-2-和窗口-3-才有机会进入代码" class="headerlink" title="窗口 1 线程进入操作的时候，窗口 2 和窗口 3 线程只能在外等着，窗口 1 操作结束，窗口 1 和窗口 2 和窗口 3 才有机会进入代码"></a>窗口 1 线程进入操作的时候，窗口 2 和窗口 3 线程只能在外等着，窗口 1 操作结束，窗口 1 和窗口 2 和窗口 3 才有机会进入代码</h3><h3 id="去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU"><a href="#去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU" class="headerlink" title="去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU"></a>去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU</h3><h3 id="资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。"><a href="#资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。" class="headerlink" title="资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。"></a>资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。</h3><h3 id="1-同步代码块。"><a href="#1-同步代码块。" class="headerlink" title="1. 同步代码块。"></a>1. 同步代码块。</h3><h3 id="2-同步方法。"><a href="#2-同步方法。" class="headerlink" title="2. 同步方法。"></a>2. 同步方法。</h3><h3 id="3-锁机制。"><a href="#3-锁机制。" class="headerlink" title="3. 锁机制。"></a>3. 锁机制。</h3><h2 id="2-3-同步代码块"><a href="#2-3-同步代码块" class="headerlink" title="2. 3 同步代码块"></a>2. 3 同步代码块</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">同步代码块：<span class="hljs-keyword">synchronized</span>关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。<br></code></pre></td></tr></table></figure>

<p>格式:</p>
<h3 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁:"></a>同步锁:</h3><h3 id="对象的同步锁只是一个概念-可以想象为在对象上标记了一个锁"><a href="#对象的同步锁只是一个概念-可以想象为在对象上标记了一个锁" class="headerlink" title="对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁."></a>对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.</h3><h3 id="1-锁对象-可以是任意类型。"><a href="#1-锁对象-可以是任意类型。" class="headerlink" title="1. 锁对象 可以是任意类型。"></a>1. 锁对象 可以是任意类型。</h3><h3 id="2-多个线程对象-要使用同一把锁。"><a href="#2-多个线程对象-要使用同一把锁。" class="headerlink" title="2. 多个线程对象 要使用同一把锁。"></a>2. 多个线程对象 要使用同一把锁。</h3><h3 id="注意-在任何时候-最多允许一个线程拥有同步锁-谁拿到锁就进入代码块-其他的线程只能在外等着"><a href="#注意-在任何时候-最多允许一个线程拥有同步锁-谁拿到锁就进入代码块-其他的线程只能在外等着" class="headerlink" title="注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着"></a>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着</h3><h3 id="BLOCKED-。"><a href="#BLOCKED-。" class="headerlink" title="(BLOCKED)。"></a>(BLOCKED)。</h3><h3 id="使用同步代码块解决代码："><a href="#使用同步代码块解决代码：" class="headerlink" title="使用同步代码块解决代码："></a>使用同步代码块解决代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(同步锁)&#123;<br>需要同步操作的代码<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket =  <span class="hljs-number">100</span> ;<br>Object lock = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 执行卖票操作</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//每个窗口卖票的操作</span><br><span class="hljs-comment">//窗口 永远开启</span><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br><span class="hljs-keyword">if</span>(ticket&gt; <span class="hljs-number">0</span> )&#123;<span class="hljs-comment">//有票 可以卖</span><br><span class="hljs-comment">//出票操作</span><br><span class="hljs-comment">//使用sleep模拟一下出票时间</span><br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep( <span class="hljs-number">50</span> );<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto‐generated catch block</span><br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//获取当前线程对象的名字</span><br>String name = Thread.currentThread().getName();<br>System.out.println(name+<span class="hljs-string">"正在卖:"</span>+ticket‐‐);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="当使用了同步代码块后，上述的线程的安全问题，解决了。"><a href="#当使用了同步代码块后，上述的线程的安全问题，解决了。" class="headerlink" title="当使用了同步代码块后，上述的线程的安全问题，解决了。"></a>当使用了同步代码块后，上述的线程的安全问题，解决了。</h3><h2 id="2-4-同步方法"><a href="#2-4-同步方法" class="headerlink" title="2. 4 同步方法"></a>2. 4 同步方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">同步方法:使用<span class="hljs-keyword">synchronized</span>修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外<br>等着。<br></code></pre></td></tr></table></figure>

<p>格式：</p>
<h3 id="同步锁是谁"><a href="#同步锁是谁" class="headerlink" title="同步锁是谁?"></a>同步锁是谁?</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">对于非<span class="hljs-keyword">static</span>方法,同步锁就是<span class="hljs-keyword">this</span>。<br>对于<span class="hljs-keyword">static</span>方法,我们使用当前方法所在类的字节码对象(类名<span class="hljs-class">.<span class="hljs-keyword">class</span>)。</span><br></code></pre></td></tr></table></figure>

<p>使用同步方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;<br>可能会产生线程安全问题的代码<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket =  <span class="hljs-number">100</span> ;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 执行卖票操作</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//每个窗口卖票的操作</span><br><span class="hljs-comment">//窗口 永远开启</span><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>sellTicket();<br>&#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 锁对象 是 谁调用这个方法 就是谁</span><br><span class="hljs-comment">* 隐含 锁对象 就是 this</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sellTicket</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(ticket&gt; <span class="hljs-number">0</span> )&#123;<span class="hljs-comment">//有票 可以卖</span><br><span class="hljs-comment">//出票操作</span><br><span class="hljs-comment">//使用sleep模拟一下出票时间</span><br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep( <span class="hljs-number">100</span> );<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto‐generated catch block</span><br>e.printStackTrace();<br></code></pre></td></tr></table></figure>

<h2 id="2-5-Lock锁"><a href="#2-5-Lock锁" class="headerlink" title="2. 5 Lock锁"></a>2. 5 Lock锁</h2><p>java.util.concurrent.locks.Lock机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,<br>同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。</p>
<p>Lock锁也称同步锁，加锁与释放锁方法化了，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span>:加同步锁。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span>:释放同步锁。</span><br></code></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123; <br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">100</span>; <br><br>Lock lock = <span class="hljs-keyword">new</span> ReentrantLock(); <br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">\* 执行卖票操作 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span> <br><br><span class="hljs-meta">@Override</span> <br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <br><br><span class="hljs-comment">//每个窗口卖票的操作 </span><br><br><span class="hljs-comment">//窗口 永远开启 </span><br><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123; <br><br>lock.lock(); <br><br><span class="hljs-keyword">if</span>(ticket&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//有票 可以卖 </span><br><br><span class="hljs-comment">//出票操作 </span><br><br><span class="hljs-comment">//使用sleep模拟一下出票时间 </span><br><br><span class="hljs-keyword">try</span> &#123;<br><br>Thread.sleep(<span class="hljs-number">50</span>); <br><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; <br><br><span class="hljs-comment">// TODO Auto‐generated catch block </span><br><br>e.printStackTrace(); <br><br>&#125;<br><br><span class="hljs-comment">//获取当前线程对象的名字 </span><br><br>String name = Thread.currentThread().getName(); <br><br>System.out.println(name+<span class="hljs-string">"正在卖:"</span>+ticket‐‐); <br><br>&#125;<br><br>lock.unlock(); <br><br>&#125; <br><br>&#125; <br><br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="第三章-线程状态"><a href="#第三章-线程状态" class="headerlink" title="第三章 线程状态"></a>第三章 线程状态</h1><h3 id="获取当前线程对象的名字"><a href="#获取当前线程对象的名字" class="headerlink" title="//获取当前线程对象的名字"></a>//获取当前线程对象的名字</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String name = Thread.currentThread().getName();<br>System.out.println(name+<span class="hljs-string">"正在卖:"</span>+ticket‐‐);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket =  <span class="hljs-number">100</span> ;<br>Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 执行卖票操作</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//每个窗口卖票的操作</span><br><span class="hljs-comment">//窗口 永远开启</span><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>lock.lock();<br><span class="hljs-keyword">if</span>(ticket&gt; <span class="hljs-number">0</span> )&#123;<span class="hljs-comment">//有票 可以卖</span><br><span class="hljs-comment">//出票操作</span><br><span class="hljs-comment">//使用sleep模拟一下出票时间</span><br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep( <span class="hljs-number">50</span> );<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto‐generated catch block</span><br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//获取当前线程对象的名字</span><br>String name = Thread.currentThread().getName();<br>System.out.println(name+<span class="hljs-string">"正在卖:"</span>+ticket‐‐);<br>&#125;<br>lock.unlock();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="线程状态-导致状态发生条件"><a href="#线程状态-导致状态发生条件" class="headerlink" title="线程状态 导致状态发生条件"></a>线程状态 导致状态发生条件</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">NEW(新建) 线程刚被创建，但是并未启动。还没调用start方法。<br>Runnable(可<br>运行)<br>线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操<br>作系统处理器。<br>Blocked(锁阻<br>塞)<br>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状<br>态；当该线程持有锁时，该线程将变成Runnable状态。<br>Waiting(无限<br>等待)<br>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个<br>状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。<br>Timed<br>Waiting(计时<br>等待)<br>同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态<br>将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、<br>Object.wait。<br>Teminated(被<br>终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。<br></code></pre></td></tr></table></figure>

<h2 id="3-1-线程状态概述"><a href="#3-1-线程状态概述" class="headerlink" title="3. 1 线程状态概述"></a>3. 1 线程状态概述</h2><h3 id="当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，"><a href="#当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，" class="headerlink" title="当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，"></a>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，</h3><p>有几种状态呢？在API中java.lang.Thread.State这个枚举中给出了六种线程状态：</p>
<img src="/2020/04/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5/%E7%8A%B6%E6%80%81.png" class="" title="六种状态">

<p>这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析</p>
<h3 id="我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几"><a href="#我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几" class="headerlink" title="我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几"></a>我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几</h3><p>个状态呢，新建与被终止还是很容易理解的，我们就研究一下线程从Runnable（可运行）状态与非运行状态之间<br>的转换问题。</p>
<h2 id="3-2-Timed-Waiting（计时等待）"><a href="#3-2-Timed-Waiting（计时等待）" class="headerlink" title="3. 2 Timed Waiting（计时等待）"></a>3. 2 Timed Waiting（计时等待）</h2><p>Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。单独<br>的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？</p>
<p>在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就<br>强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。</p>
<p>其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等<br>待)，那么我们通过一个案例加深对该状态的一个理解。</p>
<p>实现一个计数器，计数到 100 ，在每个数字之间暂停 1 秒，每隔 10 个数字输出一个字符串</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =  <span class="hljs-number">0</span> ; i &lt;  <span class="hljs-number">100</span> ; i++) &#123;<br><span class="hljs-keyword">if</span> ((i) %  <span class="hljs-number">10</span>  ==  <span class="hljs-number">0</span> ) &#123;<br>System.out.println(<span class="hljs-string">"‐‐‐‐‐‐‐"</span> + i);<br>&#125;<br>  System.out.print(i);<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep( <span class="hljs-number">1000</span> );<br>System.out.print(<span class="hljs-string">" 线程睡眠 1 秒！\n"</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">new</span> MyThread().start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过案例可以发现，sleep方法的使用还是很简单的。我们需要记住下面几点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>. 进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协<br>作关系。<br><span class="hljs-number">2</span>. 为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程<br>中会睡眠<br><span class="hljs-number">3</span>. sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。<br>小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就<br>开始立刻执行。<br></code></pre></td></tr></table></figure>

<p>Timed Waiting 线程状态图：</p>
<img src="/2020/04/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5/%E8%AE%A1%E6%97%B6%E7%AD%89%E5%BE%85.png" class="" title="计时等待">

<h2 id="3-3-BLOCKED（锁阻塞）"><a href="#3-3-BLOCKED（锁阻塞）" class="headerlink" title="3. 3 BLOCKED（锁阻塞）"></a>3. 3 BLOCKED（锁阻塞）</h2><p>Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。</p>
<p>我们已经学完同步机制，那么这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获<br>取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。</p>
<p>这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态，而<br>这部分内容作为扩充知识点带领大家了解一下。</p>
<p>Blocked 线程状态图</p>
<img src="/2020/04/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5/%E9%94%81%E9%98%BB%E5%A1%9E.png" class="" title="锁阻塞">



<h2 id="3-4-Waiting（无限等待）"><a href="#3-4-Waiting（无限等待）" class="headerlink" title="3. 4 Waiting（无限等待）"></a>3. 4 Waiting（无限等待）</h2><p>Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。</p>
<p>那么我们之前遇到过这种状态吗？答案是并没有，但并不妨碍我们进行一个简单深入的了解。我们通过一段代码来<br>学习一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitingTest</span> </span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 演示waiting</span><br><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br><span class="hljs-keyword">synchronized</span> (obj)&#123;<br><span class="hljs-keyword">try</span> &#123;<br>System.out.println( Thread.currentThread().getName() +<span class="hljs-string">"=== 获取到锁对</span><br></code></pre></td></tr></table></figure>

<p>通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的<br>Object.notify()方法 或 Object.notifyAll()方法。</p>
<p>其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，<br>多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞<br>争，但更多时候你们更多是一起合作以完成某些任务。</p>
<p>当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入<br>了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了<br>notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入<br>Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。</p>
<p>Waiting 线程状态图</p>
{% asset_img 无限等待.png 无限等待 %}

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitingTest</span> </span>&#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object(); <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 演示waiting new Thread(new Runnable() &#123; @Override public void run() &#123; while (true)&#123; synchronized (obj)&#123; try &#123;System.out.println( Thread.currentThread().getName() +"=== 获取到锁对</span><br>象，调用wait方法，进入waiting状态，释放锁对象<span class="hljs-string">");</span><br><span class="hljs-string">obj.wait(); //无限等待</span><br><span class="hljs-string">//obj.wait( 5000 ); //计时等待,  5 秒 时间到，自动醒来</span><br><span class="hljs-string">&#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-string">e.printStackTrace();</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">System.out.println( Thread.currentThread().getName() + "</span>=== 从waiting状<br>态醒来，获取到锁对象，继续执行了<span class="hljs-string">");</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;,"</span>等待线程<span class="hljs-string">").start();</span><br><span class="hljs-string">new Thread(new Runnable() &#123;</span><br><span class="hljs-string">@Override</span><br><span class="hljs-string">public void run() &#123;</span><br><span class="hljs-string">// while (true)&#123; //每隔 3 秒 唤醒一次</span><br><span class="hljs-string">try &#123;</span><br><span class="hljs-string">System.out.println( Thread.currentThread().getName() +"</span>‐‐‐‐‐ 等待 <span class="hljs-number">3</span> 秒钟<span class="hljs-string">");</span><br><span class="hljs-string">Thread.sleep( 3000 );</span><br><span class="hljs-string">&#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-string">e.printStackTrace();</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">synchronized (obj)&#123;</span><br><span class="hljs-string">System.out.println( Thread.currentThread().getName() +"</span>‐‐‐‐‐ 获取到锁对<br>象,调用notify方法，释放锁对象<span class="hljs-string">");</span><br><span class="hljs-string">obj.notify();</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">// &#125;</span><br><span class="hljs-string">&#125;,"</span>唤醒线程<span class="hljs-string">").start();</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<h2 id="3-5-补充知识点"><a href="#3-5-补充知识点" class="headerlink" title="3. 5 补充知识点"></a>3. 5 补充知识点</h2><h3 id="到此为止我们已经对线程状态有了基本的认识，想要有更多的了解，详情可以见下图："><a href="#到此为止我们已经对线程状态有了基本的认识，想要有更多的了解，详情可以见下图：" class="headerlink" title="到此为止我们已经对线程状态有了基本的认识，想要有更多的了解，详情可以见下图："></a>到此为止我们已经对线程状态有了基本的认识，想要有更多的了解，详情可以见下图：</h3><img src="/2020/04/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.png" class="" title="线程状态图">

<p>一条有意思的tips:</p>
<p>我们在翻阅API的时候会发现Timed Waiting（计时等待） 与 Waiting（无限等待） 状态联系还是很紧密的，<br>比如Waiting（无限等待） 状态中wait方法是空参的，而timed waiting（计时等待） 中wait方法是带参的。<br>这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是<br>如果提前得到（唤醒）通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两<br>得。如果没有得到（唤醒）通知，那么线程就处于Timed Waiting状态,直到倒计时完毕自动醒来；如果在倒<br>计时期间得到（唤醒）通知，那么线程从Timed Waiting状态立刻唤醒。</p>
]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>构造代码块与构造器执行顺序</title>
    <url>/2020/04/21/%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="构造代码块与构造器执行顺序"><a href="#构造代码块与构造器执行顺序" class="headerlink" title="构造代码块与构造器执行顺序"></a>构造代码块与构造器执行顺序</h1><p><strong>构造代码块：</strong>定义在类的成员位置，直接使用{ }，在{}中写代码内容。</p>
<p>位置：类中，方法外，和方法并列，和先后位置无关。</p>
<p>执行时机：创建对象的时候执行一次。在构造方法隐式3步的最后一步。当构造代码块执行结束之后，开始执行构造方法本身的代码内容</p>
<a id="more"></a>

<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span></span>&#123;<br>  <span class="hljs-comment">// 构造代码块</span><br>  &#123;<br>    <span class="hljs-comment">// 执行语句 </span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>构造代码块和构造方法执行顺序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsCode</span></span>&#123;<br>    <span class="hljs-comment">// 成员变量</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">int</span> b;<br><span class="hljs-comment">// 空参构造</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConsCode</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//System.out.println("HelloWorld!");</span><br>  	System.out.println(<span class="hljs-string">"11我在构造代码块执行结束之后执行..."</span>);<br>&#125;<br> <br><span class="hljs-comment">// 给变量a赋值的构造</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConsCode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.a = a;<br>  	System.out.println(<span class="hljs-string">"22我在构造代码块执行结束之后执行..."</span>);<br>    <span class="hljs-comment">//System.out.println("HelloWorld!");</span><br>&#125;<br> <br><span class="hljs-comment">// 给变量ab同时赋值的构造</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConsCode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a , <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.a = a;<br>    <span class="hljs-keyword">this</span>.b = b;<br>    <span class="hljs-comment">//System.out.println("HelloWorld!");</span><br>  	System.out.println(<span class="hljs-string">"33我在构造代码块执行结束之后执行..."</span>);<br>&#125;<br> <br><span class="hljs-comment">// 构造代码块</span><br>&#123;<br>    System.out.println(<span class="hljs-string">"构造代码块!。。。。。。。。。。。。。。。"</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstructorCodeDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 分别使用3个构造方法创建对象，并运行程序，显示执行3遍HelloWorld！</span><br>        ConsCode c1 = <span class="hljs-keyword">new</span> ConsCode();<br>        ConsCode c2 = <span class="hljs-keyword">new</span> ConsCode(<span class="hljs-number">10</span>);<br>        ConsCode c3 = <span class="hljs-keyword">new</span> ConsCode(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/2020/04/21/%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/1.png" class="" title="结果">]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2020/04/20/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="内部类总结"><a href="#内部类总结" class="headerlink" title="内部类总结"></a>内部类总结</h1><p>1.普通内部类相当于外部类的一个成员变量，因此内部类可以直接访问外部类的成员，<strong><em>\</em>包括私有**</strong>。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">   <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>	    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	        <span class="hljs-comment">//外部类名.内部类名 = 外部类对象.内部类对象</span><br>	        Outer.Inner oi = <span class="hljs-keyword">new</span> Outer().<span class="hljs-keyword">new</span> Inner();            <span class="hljs-comment">//创建内部类对象</span><br>	        oi.method();<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(num);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>2.内部类有静态方法那么内部类必须是静态的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num=<span class="hljs-number">10</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span><span class="hljs-comment">//报错原因 ：内部类不是静态的而方法是静态的 ，相当于盒子里有糖，但盒子却没有打开的方法（static的属性，从属于类）</span></span><br><span class="hljs-function">	</span>&#123;<br>		<br>	&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3.局部变量必须加final修饰符。（随着方法运行完毕，局部变量会被释放，如果此时一个内部类还引用该变量则会报错。说到底就是变量的生命周期比内部类实例要短。而final保证这个变量始终指向一个对象，内部类就可以放心大胆地引用了。其实犯了和C++一样的毛病：返回了局部变量的引用）<br><strong><em>注意:在JDK8版本之中,方法内部类中调用方法中的局部变量,可以不需要修饰为 final,匿名内部类也是一样的，主要是JDK8之后增加了 Effectively final 功能\</em></strong>    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;	<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> num =<span class="hljs-number">20</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;<br>		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">		</span>&#123;<br>			System.out.println(num);<br>		&#125;<br>	&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>4.面试题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//要求：使用已知的变量，在控制台输出30，20，10。</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;	<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num=<span class="hljs-number">10</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> num =<span class="hljs-number">20</span>;<br>		<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;<br>			<span class="hljs-keyword">int</span> num=<span class="hljs-number">30</span>;<br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">			</span>&#123;<br>			System.out.println(num);<br>			System.out.println(<span class="hljs-keyword">this</span>.num);<br>			System.out.println(Outer.<span class="hljs-keyword">this</span>.num);<br>		&#125;<br>	&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>Integer</title>
    <url>/2020/04/19/Integer/</url>
    <content><![CDATA[<h1 id="Integer的某些特点"><a href="#Integer的某些特点" class="headerlink" title="Integer的某些特点"></a>Integer的某些特点</h1><a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a=<span class="hljs-number">3</span>;<br>    Integer b=<span class="hljs-number">3</span>;<span class="hljs-comment">//等于 Integer b=Integer.valueOf(3);</span><br>    Integer c=<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">3</span>);<br>    Integer d=<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">3</span>);<br>    <span class="hljs-comment">//a在常量池 Integer会自动装箱拆箱 ==比较值</span><br>    System.out.println(b.equals(a));<span class="hljs-comment">//true</span><br>    System.out.println(a==b);<span class="hljs-comment">//ture</span><br>    <span class="hljs-comment">//两个new出来的对象不会拆箱，==比较的是地址值</span><br>    System.out.println(c==d);<span class="hljs-comment">//false</span><br><br>    System.out.println(<span class="hljs-string">"============"</span>);<br><br><br>    Integer e=<span class="hljs-number">127</span>;<br>    Integer f=<span class="hljs-number">127</span>;<br><br>    Integer g=<span class="hljs-number">128</span>;<br>    Integer h=<span class="hljs-number">128</span>;<br>    System.out.println(e==f);<span class="hljs-comment">//ture</span><br>    System.out.println(g==h);<span class="hljs-comment">//flase</span><br>&#125;<br></code></pre></td></tr></table></figure>

{% asset_img 1.png  结果%}

<p>看一下源码大家都会明白，对于-128到127之间的数，会进行缓存，Integer e = 127时，会将127进行缓存，下次再写Integer f = 127时，就会直接从缓存中取，就不会new了。而大于127或者小于-128的值就会重新new。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk1.8不支持maven自带的tomcat6</title>
    <url>/2020/04/17/jdk1-8%E4%B8%8D%E6%94%AF%E6%8C%81maven%E8%87%AA%E5%B8%A6%E7%9A%84tomcat6/</url>
    <content><![CDATA[<h1 id="又被坑了啊"><a href="#又被坑了啊" class="headerlink" title="又被坑了啊"></a>又被坑了啊</h1><a id="more"></a>

<img src="/2020/04/17/jdk1-8%E4%B8%8D%E6%94%AF%E6%8C%81maven%E8%87%AA%E5%B8%A6%E7%9A%84tomcat6/%E9%94%99%E8%AF%AF.png" class="" title="错误">

<p>原因：我的maven所自带tomcat版本为6，jdk1.8不支持。</p>
<p>解决：在pom文件中加入以下代码</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">&lt;plugin&gt;<br>  &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;<br>  &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;<br>  &lt;version&gt;2.2&lt;/version&gt;<br>  &lt;configuration&gt;<br>    &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt;<br>    &lt;path&gt;/bos&lt;/path&gt;<br>    &lt;port&gt;8888&lt;/port&gt;<br>  &lt;/configuration&gt;<br>&lt;/plugin&gt;<br></code></pre></td></tr></table></figure>

<p><strong>注意：这段代码是下载tomcat7插件，所以启动的时候要用tomcat7：run命令</strong></p>
]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2020/04/17/redis/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1-概念：-redis是一款高性能的NOSQL系列的非关系型数据库"><a href="#1-概念：-redis是一款高性能的NOSQL系列的非关系型数据库" class="headerlink" title="1.概念： redis是一款高性能的NOSQL系列的非关系型数据库"></a>1.概念： redis是一款高性能的NOSQL系列的非关系型数据库</h2><a id="more"></a>

<h3 id="1-1-什么是NOSQL"><a href="#1-1-什么是NOSQL" class="headerlink" title="1.1.什么是NOSQL"></a>1.1.什么是NOSQL</h3><p>​        NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。<br>​        随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</p>
<h3 id="1-1-1-NOSQL和关系型数据库比较"><a href="#1-1-1-NOSQL和关系型数据库比较" class="headerlink" title="1.1.1.    NOSQL和关系型数据库比较"></a>1.1.1.    NOSQL和关系型数据库比较</h3><p>​            优点：<br>​                1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。<br>​                2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。<br>​            3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。<br>​            4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。</p>
<p>​            缺点：<br>​            1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。<br>​            2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。<br>​            3）不提供关系型数据库对事务的处理。</p>
<h3 id="1-1-2-非关系型数据库的优势："><a href="#1-1-2-非关系型数据库的优势：" class="headerlink" title="1.1.2.    非关系型数据库的优势："></a>1.1.2.    非关系型数据库的优势：</h3><p>​            1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。<br>​            2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</p>
<h3 id="1-1-3-关系型数据库的优势："><a href="#1-1-3-关系型数据库的优势：" class="headerlink" title="1.1.3.    关系型数据库的优势："></a>1.1.3.    关系型数据库的优势：</h3><p>​            1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。<br>​            2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</p>
<h3 id="1-1-4-总结"><a href="#1-1-4-总结" class="headerlink" title="1.1.4.    总结"></a>1.1.4.    总结</h3><p>​            关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，<br>​            让NoSQL数据库对关系型数据库的不足进行弥补。<br>​            一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据</p>
<h2 id="1-2-主流的NOSQL产品"><a href="#1-2-主流的NOSQL产品" class="headerlink" title="1.2.主流的NOSQL产品"></a>1.2.主流的NOSQL产品</h2><p>​        •    键值(Key-Value)存储数据库<br>​                相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB<br>​                典型应用： 内容缓存，主要用于处理大量数据的高访问负载。<br>​                数据模型： 一系列键值对<br>​                优势： 快速查询<br>​                劣势： 存储的数据缺少结构化<br>​        •    列存储数据库<br>​                相关产品：Cassandra, HBase, Riak<br>​                典型应用：分布式的文件系统<br>​                数据模型：以列簇式存储，将同一列数据存在一起<br>​                优势：查找速度快，可扩展性强，更容易进行分布式扩展<br>​                劣势：功能相对局限<br>​        •    文档型数据库<br>​                相关产品：CouchDB、MongoDB<br>​                典型应用：Web应用（与Key-Value类似，Value是结构化的）<br>​                数据模型： 一系列键值对<br>​                优势：数据结构要求不严格<br>​                劣势： 查询性能不高，而且缺乏统一的查询语法<br>​        •    图形(Graph)数据库<br>​                相关数据库：Neo4J、InfoGrid、Infinite Graph<br>​                典型应用：社交网络<br>​                数据模型：图结构<br>​                优势：利用图结构相关算法。<br>​                劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</p>
<h2 id="1-3-什么是Redis"><a href="#1-3-什么是Redis" class="headerlink" title="1.3 什么是Redis"></a>1.3 什么是Redis</h2><p>​        Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：<br>​            1) 字符串类型 string<br>​            2) 哈希类型 hash<br>​            3) 列表类型 list<br>​            4) 集合类型 set<br>​            5) 有序集合类型 sortedset</p>
<h3 id="1-3-1-redis的应用场景"><a href="#1-3-1-redis的应用场景" class="headerlink" title="1.3.1 redis的应用场景"></a>1.3.1 redis的应用场景</h3><p>​            •    缓存（数据查询、短连接、新闻内容、商品内容等等）<br>​            •    聊天室的在线好友列表<br>​            •    任务队列。（秒杀、抢购、12306等等）<br>​            •    应用排行榜<br>​            •    网站访问统计<br>​            •    数据过期处理（可以精确到毫秒<br>​            •    分布式集群架构中的session分离</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">2</span>. 下载安装<br>	<span class="hljs-number">1</span>. 官网：https:<span class="hljs-comment">//redis.io</span><br>	<span class="hljs-number">2</span>. 中文网：http:<span class="hljs-comment">//www.redis.net.cn/</span><br>	<span class="hljs-number">3</span>. 解压直接可以使用：<br>		* redis.windows.conf：配置文件<br>		* redis-cli.exe：redis的客户端<br>		* redis-server.exe：redis服务器端<br>	<br><span class="hljs-number">3</span>. 命令操作<br>	<span class="hljs-number">1</span>. redis的数据结构：<br>		* redis存储的是：key,value格式的数据，其中key都是字符串，value有<span class="hljs-number">5</span>种不同的数据结构<br>			* value的数据结构：<br>				<span class="hljs-number">1</span>) 字符串类型 string<br>				<span class="hljs-number">2</span>) 哈希类型 hash ： map格式  <br>				<span class="hljs-number">3</span>) 列表类型 list ： linkedlist格式。支持重复元素<br>				<span class="hljs-number">4</span>) 集合类型 set  ： 不允许重复元素<br>				<span class="hljs-number">5</span>) 有序集合类型 sortedset：不允许重复元素，且元素有顺序<br>	<br>	<span class="hljs-number">2</span>. 字符串类型 string<br>		<span class="hljs-number">1</span>. 存储： set key value<br>			<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; set username zhangsan<br>			OK<br>		<span class="hljs-number">2</span>. 获取： get key<br>			<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; get username<br>			<span class="hljs-string">"zhangsan"</span><br>		<span class="hljs-number">3</span>. 删除： del key<br>			<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; del age<br>			(integer) <span class="hljs-number">1</span><br>	<span class="hljs-number">3</span>. 哈希类型 hash<br>		<span class="hljs-number">1</span>. 存储： hset key field value<br>			<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hset myhash username lisi<br>			(integer) <span class="hljs-number">1</span><br>			<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hset myhash password <span class="hljs-number">123</span><br>			(integer) <span class="hljs-number">1</span><br>		<span class="hljs-number">2</span>. 获取： <br>			* hget key field: 获取指定的field对应的值<br>				<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hget myhash username<br>				<span class="hljs-string">"lisi"</span><br>			* hgetall key：获取所有的field和value<br>				<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hgetall myhash<br>				<span class="hljs-number">1</span>) <span class="hljs-string">"username"</span><br>				<span class="hljs-number">2</span>) <span class="hljs-string">"lisi"</span><br>				<span class="hljs-number">3</span>) <span class="hljs-string">"password"</span><br>				<span class="hljs-number">4</span>) <span class="hljs-string">"123"</span><br>				<br>		<span class="hljs-number">3</span>. 删除： hdel key field<br>			<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hdel myhash username<br>			(integer) <span class="hljs-number">1</span><br>	<br>	<span class="hljs-number">4</span>. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）<br>		<span class="hljs-number">1</span>. 添加：<br>			<span class="hljs-number">1</span>. lpush key value: 将元素加入列表左表<br>				<br>			<span class="hljs-number">2</span>. rpush key value：将元素加入列表右边<br>				<br>				<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lpush myList a<br>				(integer) <span class="hljs-number">1</span><br>				<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lpush myList b<br>				(integer) <span class="hljs-number">2</span><br>				<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myList c<br>				(integer) <span class="hljs-number">3</span><br>		<span class="hljs-number">2</span>. 获取：<br>			* lrange key start end ：范围获取<br>				<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange myList <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br>				<span class="hljs-number">1</span>) <span class="hljs-string">"b"</span><br>				<span class="hljs-number">2</span>) <span class="hljs-string">"a"</span><br>				<span class="hljs-number">3</span>) <span class="hljs-string">"c"</span><br>		<span class="hljs-number">3</span>. 删除：<br>			* lpop key： 删除列表最左边的元素，并将元素返回<br>			* rpop key： 删除列表最右边的元素，并将元素返回<br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">5</span>. 集合类型 set ： 不允许重复元素<br>	<span class="hljs-number">1</span>. 存储：sadd key value<br>		<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd myset a<br>		(integer) <span class="hljs-number">1</span><br>		<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd myset a<br>		(integer) <span class="hljs-number">0</span><br>	<span class="hljs-number">2</span>. 获取：smembers key:获取set集合中所有元素<br>		<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; smembers myset<br>		<span class="hljs-number">1</span>) <span class="hljs-string">"a"</span><br>	<span class="hljs-number">3</span>. 删除：srem key value:删除set集合中的某个元素	<br>		<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; srem myset a<br>		(integer) <span class="hljs-number">1</span><br><span class="hljs-number">6</span>. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个<span class="hljs-keyword">double</span>类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。<br><br>	<span class="hljs-number">1</span>. 存储：zadd key score value<br>		<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zadd mysort <span class="hljs-number">60</span> zhangsan<br>		(integer) <span class="hljs-number">1</span><br>		<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zadd mysort <span class="hljs-number">50</span> lisi<br>		(integer) <span class="hljs-number">1</span><br>		<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zadd mysort <span class="hljs-number">80</span> wangwu<br>		(integer) <span class="hljs-number">1</span><br>	<span class="hljs-number">2</span>. 获取：zrange key start end [withscores]<br>		<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mysort <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br>		<span class="hljs-number">1</span>) <span class="hljs-string">"lisi"</span><br>		<span class="hljs-number">2</span>) <span class="hljs-string">"zhangsan"</span><br>		<span class="hljs-number">3</span>) <span class="hljs-string">"wangwu"</span><br><br>		<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mysort <span class="hljs-number">0</span> -<span class="hljs-number">1</span> withscores<br>		<span class="hljs-number">1</span>) <span class="hljs-string">"zhangsan"</span><br>		<span class="hljs-number">2</span>) <span class="hljs-string">"60"</span><br>		<span class="hljs-number">3</span>) <span class="hljs-string">"wangwu"</span><br>		<span class="hljs-number">4</span>) <span class="hljs-string">"80"</span><br>		<span class="hljs-number">5</span>) <span class="hljs-string">"lisi"</span><br>		<span class="hljs-number">6</span>) <span class="hljs-string">"500"</span><br>	<span class="hljs-number">3</span>. 删除：zrem key value<br>		<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrem mysort lisi<br>		(integer) <span class="hljs-number">1</span><br><br><span class="hljs-number">7</span>. 通用命令<br>	<span class="hljs-number">1</span>. keys * : 查询所有的键<br>	<span class="hljs-number">2</span>. type key ： 获取键对应的value的类型<br>	<span class="hljs-number">3</span>. del key：删除指定的key value<br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">4</span>. 持久化<br>	<span class="hljs-number">1</span>. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。<br>	<span class="hljs-number">2</span>. redis持久化机制：<br>		<span class="hljs-number">1</span>. RDB：默认方式，不需要进行配置，默认就使用这种机制<br>			* 在一定的间隔时间中，检测key的变化情况，然后持久化数据<br>			<span class="hljs-number">1</span>. 编辑redis.windwos.conf文件<br>				#   after 900 sec (15 min) if at least 1 key changed<br>				save <span class="hljs-number">900</span> <span class="hljs-number">1</span><br>				#   after 300 sec (5 min) if at least 10 keys changed<br>				save <span class="hljs-number">300</span> <span class="hljs-number">10</span><br>				#   after 60 sec if at least 10000 keys changed<br>				save <span class="hljs-number">60</span> <span class="hljs-number">10000</span><br>				<br>			<span class="hljs-number">2</span>. 重新启动redis服务器，并指定配置文件名称<br>				D:\JavaWeb2018\day23_redis\资料\redis\windows-<span class="hljs-number">64</span>\redis-<span class="hljs-number">2.8</span><span class="hljs-number">.9</span>&gt;redis-server.exe redis.windows.conf	<br>			<br>		<span class="hljs-number">2</span>. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据<br>			<span class="hljs-number">1</span>. 编辑redis.windwos.conf文件<br>				appendonly no（关闭aof） --&gt; appendonly yes （开启aof）<br>				<br>				# appendfsync always ： 每一次操作都进行持久化<br>				appendfsync everysec ： 每隔一秒进行一次持久化<br>				# appendfsync no	 ： 不进行持久化<br><br><span class="hljs-number">5</span>. Java客户端 Jedis<br>	* Jedis: 一款java操作redis数据库的工具.<br>	* 使用步骤：<br>		<span class="hljs-number">1</span>. 下载jedis的jar包<br>		<span class="hljs-number">2</span>. 使用<br>			<span class="hljs-comment">//1. 获取连接</span><br>    		Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"localhost"</span>,<span class="hljs-number">6379</span>);<br>   			<span class="hljs-comment">//2. 操作</span><br>   			jedis.set(<span class="hljs-string">"username"</span>,<span class="hljs-string">"zhangsan"</span>);<br>    		<span class="hljs-comment">//3. 关闭连接</span><br>    		jedis.close();<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* Jedis操作各种redis中的数据结构<br>	<span class="hljs-number">1</span>) 字符串类型 string<br>		set<br>		get<br>		<br>		 <span class="hljs-comment">//1. 获取连接</span><br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis();<span class="hljs-comment">//如果使用空参构造，默认值 "localhost",6379端口</span><br>        <span class="hljs-comment">//2. 操作</span><br>        <span class="hljs-comment">//存储</span><br>        jedis.set(<span class="hljs-string">"username"</span>,<span class="hljs-string">"zhangsan"</span>);<br>        <span class="hljs-comment">//获取</span><br>        String username = jedis.get(<span class="hljs-string">"username"</span>);<br>        System.out.println(username);<br><br>        <span class="hljs-comment">//可以使用setex()方法存储可以指定过期时间的 key value</span><br>        jedis.setex(<span class="hljs-string">"activecode"</span>,<span class="hljs-number">20</span>,<span class="hljs-string">"hehe"</span>);<span class="hljs-comment">//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对</span><br><br>        <span class="hljs-comment">//3. 关闭连接</span><br>        jedis.close();<br><br>	<span class="hljs-number">2</span>) 哈希类型 hash ： map格式  <br>		hset<br>		hget<br>		hgetAll<br>		<span class="hljs-comment">//1. 获取连接</span><br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis();<span class="hljs-comment">//如果使用空参构造，默认值 "localhost",6379端口</span><br>        <span class="hljs-comment">//2. 操作</span><br>        <span class="hljs-comment">// 存储hash</span><br>        jedis.hset(<span class="hljs-string">"user"</span>,<span class="hljs-string">"name"</span>,<span class="hljs-string">"lisi"</span>);<br>        jedis.hset(<span class="hljs-string">"user"</span>,<span class="hljs-string">"age"</span>,<span class="hljs-string">"23"</span>);<br>        jedis.hset(<span class="hljs-string">"user"</span>,<span class="hljs-string">"gender"</span>,<span class="hljs-string">"female"</span>);<br><br>        <span class="hljs-comment">// 获取hash</span><br>        String name = jedis.hget(<span class="hljs-string">"user"</span>, <span class="hljs-string">"name"</span>);<br>        System.out.println(name);<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取hash的所有map中的数据</span><br>Map&lt;String, String&gt; user = jedis.hgetAll(<span class="hljs-string">"user"</span>);<br>	<br><span class="hljs-comment">// keyset</span><br>Set&lt;String&gt; keySet = user.keySet();<br><span class="hljs-keyword">for</span> (String key : keySet) &#123;<br>    <span class="hljs-comment">//获取value</span><br>    String value = user.get(key);<br>    System.out.println(key + <span class="hljs-string">":"</span> + value);<br>&#125;<br>	<br><span class="hljs-comment">//3. 关闭连接</span><br>jedis.close();<br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">3</span>) 列表类型 list ： linkedlist格式。支持重复元素<br>	lpush / rpush<br>	lpop / rpop<br>	lrange start end : 范围获取<br>	<br>	 <span class="hljs-comment">//1. 获取连接</span><br>       Jedis jedis = <span class="hljs-keyword">new</span> Jedis();<span class="hljs-comment">//如果使用空参构造，默认值 "localhost",6379端口</span><br>       <span class="hljs-comment">//2. 操作</span><br>       <span class="hljs-comment">// list 存储</span><br>       jedis.lpush(<span class="hljs-string">"mylist"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>);<span class="hljs-comment">//从左边存</span><br>       jedis.rpush(<span class="hljs-string">"mylist"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>);<span class="hljs-comment">//从右边存</span><br>	<br>       <span class="hljs-comment">// list 范围获取</span><br>       List&lt;String&gt; mylist = jedis.lrange(<span class="hljs-string">"mylist"</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>       System.out.println(mylist);<br>       <br>       <span class="hljs-comment">// list 弹出</span><br>       String element1 = jedis.lpop(<span class="hljs-string">"mylist"</span>);<span class="hljs-comment">//c</span><br>       System.out.println(element1);<br>	<br>       String element2 = jedis.rpop(<span class="hljs-string">"mylist"</span>);<span class="hljs-comment">//c</span><br>       System.out.println(element2);<br>	<br>       <span class="hljs-comment">// list 范围获取</span><br>       List&lt;String&gt; mylist2 = jedis.lrange(<span class="hljs-string">"mylist"</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>       System.out.println(mylist2);<br>	<br>       <span class="hljs-comment">//3. 关闭连接</span><br>       jedis.close();<br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">4</span>) 集合类型 set  ： 不允许重复元素<br>	sadd<br>	smembers:获取所有元素<br><br>	<span class="hljs-comment">//1. 获取连接</span><br>       Jedis jedis = <span class="hljs-keyword">new</span> Jedis();<span class="hljs-comment">//如果使用空参构造，默认值 "localhost",6379端口</span><br>       <span class="hljs-comment">//2. 操作</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">       <span class="hljs-comment">// set 存储</span><br>       jedis.sadd(<span class="hljs-string">"myset"</span>,<span class="hljs-string">"java"</span>,<span class="hljs-string">"php"</span>,<span class="hljs-string">"c++"</span>);<br>	<br>       <span class="hljs-comment">// set 获取</span><br>       Set&lt;String&gt; myset = jedis.smembers(<span class="hljs-string">"myset"</span>);<br>       System.out.println(myset);<br>	<br>       <span class="hljs-comment">//3. 关闭连接</span><br>       jedis.close();<br><span class="hljs-number">5</span>) 有序集合类型 sortedset：不允许重复元素，且元素有顺序<br>	zadd<br>	zrange<br><br>	<span class="hljs-comment">//1. 获取连接</span><br>       Jedis jedis = <span class="hljs-keyword">new</span> Jedis();<span class="hljs-comment">//如果使用空参构造，默认值 "localhost",6379端口</span><br>       <span class="hljs-comment">//2. 操作</span><br>       <span class="hljs-comment">// sortedset 存储</span><br>       jedis.zadd(<span class="hljs-string">"mysortedset"</span>,<span class="hljs-number">3</span>,<span class="hljs-string">"亚瑟"</span>);<br>       jedis.zadd(<span class="hljs-string">"mysortedset"</span>,<span class="hljs-number">30</span>,<span class="hljs-string">"后裔"</span>);<br>       jedis.zadd(<span class="hljs-string">"mysortedset"</span>,<span class="hljs-number">55</span>,<span class="hljs-string">"孙悟空"</span>);<br>	<br>       <span class="hljs-comment">// sortedset 获取</span><br>       Set&lt;String&gt; mysortedset = jedis.zrange(<span class="hljs-string">"mysortedset"</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>	<br>       System.out.println(mysortedset);<br>		<span class="hljs-comment">//3. 关闭连接</span><br>       jedis.close();<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">	* jedis连接池： JedisPool<br>		* 使用：<br>			<span class="hljs-number">1</span>. 创建JedisPool连接池对象<br>			<span class="hljs-number">2</span>. 调用方法 getResource()方法获取Jedis连接<br>				<span class="hljs-comment">//0.创建一个配置对象</span><br>		        JedisPoolConfig config = <span class="hljs-keyword">new</span> JedisPoolConfig();<br>		        config.setMaxTotal(<span class="hljs-number">50</span>);<br>		        config.setMaxIdle(<span class="hljs-number">10</span>);<br>		<br>		        <span class="hljs-comment">//1.创建Jedis连接池对象</span><br>		        JedisPool jedisPool = <span class="hljs-keyword">new</span> JedisPool(config,<span class="hljs-string">"localhost"</span>,<span class="hljs-number">6379</span>);<br>		<br>		        <span class="hljs-comment">//2.获取连接</span><br>		        Jedis jedis = jedisPool.getResource();<br>		        <span class="hljs-comment">//3. 使用</span><br>		        jedis.set(<span class="hljs-string">"hehe"</span>,<span class="hljs-string">"heihei"</span>);<br><span class="hljs-comment">//4. 关闭 归还到连接池中</span><br>		        jedis.close();<br>		<br>		* 连接池工具类<br>			<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisPoolUtils</span> </span>&#123;<br><br>			    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jedisPool;<br>			<br>			    <span class="hljs-keyword">static</span>&#123;<br>			        <span class="hljs-comment">//读取配置文件</span><br>			        InputStream is =   JedisPoolUtils.class.getClassLoader().getResourceAsStream("jedis.properties");<br>			        <span class="hljs-comment">//创建Properties对象</span><br>			        Properties pro = <span class="hljs-keyword">new</span> Properties();<br>			        <span class="hljs-comment">//关联文件</span><br>			        <span class="hljs-keyword">try</span> &#123;<br>			            pro.load(is);<br>			        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>			            e.printStackTrace();<br>			        &#125;<br>			        <span class="hljs-comment">//获取数据，设置到JedisPoolConfig中</span><br>			        JedisPoolConfig config = <span class="hljs-keyword">new</span> JedisPoolConfig();<br>			        config.setMaxTotal(Integer.parseInt(pro.getProperty(<span class="hljs-string">"maxTotal"</span>)));<br>			        config.setMaxIdle(Integer.parseInt(pro.getProperty(<span class="hljs-string">"maxIdle"</span>)));<br>			<br>			        <span class="hljs-comment">//初始化JedisPool</span><br>			        jedisPool = <span class="hljs-keyword">new</span> JedisPool(config,pro.getProperty(<span class="hljs-string">"host"</span>),Integer.parseInt(pro.getProperty(<span class="hljs-string">"port"</span>)));<br>			        &#125;<br>			        	    <span class="hljs-comment">/**</span><br><span class="hljs-comment">			     * 获取连接方法</span><br><span class="hljs-comment">			     */</span><br>			    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title">getJedis</span><span class="hljs-params">()</span></span>&#123;<br>			        <span class="hljs-keyword">return</span> jedisPool.getResource();<br>			    &#125;<br>			&#125;<br></code></pre></td></tr></table></figure>





<ul>
<li><strong>注意：使用redis缓存一些不经常发生变化的数据。</strong><ul>
<li><strong>数据库的数据一旦发生改变，则需要更新缓存。</strong><ul>
<li><strong>数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入</strong></li>
<li><strong>在service对应的增删改方法中，将redis数据删除。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​    </p>
]]></content>
      <tags>
        <tag>reids</tag>
      </tags>
  </entry>
  <entry>
    <title>Jquery中.value与.val的区别</title>
    <url>/2020/04/16/Jquery%E4%B8%AD-value%E4%B8%8E-val()%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="今天被这个坑了一上午，人傻了"><a href="#今天被这个坑了一上午，人傻了" class="headerlink" title="今天被这个坑了一上午，人傻了"></a>今天被这个坑了一上午，人傻了</h1><p>Juqery中.val()与.value之间的区别<a id="more"></a></p>
<p>先说理论：<br>.val()方法，一个是带参：给输入框赋值，一个是不参数的方法：获取输入框的值<br>.value：获取Dom标签元素的value值，属于原生态JavaScript的写法 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;input type=<span class="hljs-string">"text"</span> id=<span class="hljs-string">"username"</span> name=<span class="hljs-string">"username"</span> placeholder=<span class="hljs-string">"请输入用户名"</span> &gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">"#username"</span>).blur(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><br>    <span class="hljs-keyword">var</span> username = $(<span class="hljs-keyword">this</span>).val();<br>    alert(username)<br>    <br><br>&#125;);<br></code></pre></td></tr></table></figure>

<img src="/2020/04/16/Jquery%E4%B8%AD-value%E4%B8%8E-val()%E7%9A%84%E5%8C%BA%E5%88%AB/1.png" class="" title="第一种">

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">"#username"</span>).blur(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><br>    <span class="hljs-keyword">var</span> username = $(<span class="hljs-keyword">this</span>).value;<br>    alert(username)<br><br><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>因为在input中没有定义value值所以获取出来的是undefined</p>
<img src="/2020/04/16/Jquery%E4%B8%AD-value%E4%B8%8E-val()%E7%9A%84%E5%8C%BA%E5%88%AB/2.png" class="" title="第二种">]]></content>
      <tags>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>Filter</title>
    <url>/2020/04/14/Filter/</url>
    <content><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>1.Filter：过滤器</p>
<p>2.Listener：监听器</p>
<a id="more"></a>


<h1 id="Filter：过滤器"><a href="#Filter：过滤器" class="headerlink" title="Filter：过滤器"></a>Filter：过滤器</h1><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>. 概念：<br>	* 生活中的过滤器：净水器,空气净化器，土匪、<br>	* web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。<br>	* 过滤器的作用：<br>		* 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤...<br><br><span class="hljs-number">2</span>. 快速入门：<br>	<span class="hljs-number">1</span>. 步骤：<br>		<span class="hljs-number">1</span>. 定义一个类，实现接口Filter<br>		<span class="hljs-number">2</span>. 复写方法<br>		<span class="hljs-number">3</span>. 配置拦截路径<br>			<span class="hljs-number">1</span>. web.xml<br>			<span class="hljs-number">2</span>. 注解<br>	<span class="hljs-number">2</span>. 代码：<br>		<span class="hljs-meta">@WebFilter</span>(<span class="hljs-string">"/*"</span>)<span class="hljs-comment">//访问所有资源之前，都会执行该过滤器</span><br>		<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterDemo1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>		    <span class="hljs-meta">@Override</span><br>		    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>		<br>		    &#125;<br>		<br>		    <span class="hljs-meta">@Override</span><br>		    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>		        System.out.println(<span class="hljs-string">"filterDemo1被执行了...."</span>);<br></code></pre></td></tr></table></figure>


<p>​            </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">        <span class="hljs-comment">//放行</span><br>        filterChain.doFilter(servletRequest,servletResponse);<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">3</span>. 过滤器细节：<br>	<span class="hljs-number">1</span>. web.xml配置	<br>		&lt;filter&gt;<br>	        &lt;filter-name&gt;demo1&lt;/filter-name&gt;<br>	        &lt;filter-<span class="hljs-class"><span class="hljs-keyword">class</span>&gt;<span class="hljs-title">cn</span>.<span class="hljs-title">itcast</span>.<span class="hljs-title">web</span>.<span class="hljs-title">filter</span>.<span class="hljs-title">FilterDemo1</span>&lt;/<span class="hljs-title">filter</span>-<span class="hljs-title">class</span>&gt;</span><br><span class="hljs-class">	    &lt;/<span class="hljs-title">filter</span>&gt;</span><br><span class="hljs-class">	    &lt;<span class="hljs-title">filter</span>-<span class="hljs-title">mapping</span>&gt;</span><br><span class="hljs-class">	        &lt;<span class="hljs-title">filter</span>-<span class="hljs-title">name</span>&gt;<span class="hljs-title">demo1</span>&lt;/<span class="hljs-title">filter</span>-<span class="hljs-title">name</span>&gt;</span><br><span class="hljs-class">			&lt;!-- 拦截路径 --&gt;</span><br><span class="hljs-class">	        &lt;<span class="hljs-title">url</span>-<span class="hljs-title">pattern</span>&gt;/*&lt;/<span class="hljs-title">url</span>-<span class="hljs-title">pattern</span>&gt;    </span><br><span class="hljs-class">	    &lt;/<span class="hljs-title">filter</span>-<span class="hljs-title">mapping</span>&gt;</span><br><span class="hljs-class">	2. 过滤器执行流程</span><br><span class="hljs-class">		1. 执行过滤器</span><br><span class="hljs-class">		2. 执行放行后的资源</span><br><span class="hljs-class">		3. 回来执行过滤器放行代码下边的代码</span><br><span class="hljs-class">	3. 过滤器生命周期方法</span><br>		1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源<br>		<span class="hljs-number">2</span>. doFilter:每一次请求被拦截资源时，会执行。执行多次<br>		<span class="hljs-number">3</span>. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源<br>	<span class="hljs-number">4</span>. 过滤器配置详解<br>		* 拦截路径配置：<br>			<span class="hljs-number">1</span>. 具体资源路径： /index.jsp   只有访问index.jsp资源时，过滤器才会被执行<br>			<span class="hljs-number">2</span>. 拦截目录： /user<span class="hljs-comment">/*	/访问/user下的所有资源时，过滤器都会被执行</span><br><span class="hljs-comment">			3. 后缀名拦截： *.jsp		访问所有后缀名为jsp资源时，过滤器都会被执行</span><br><span class="hljs-comment">			4. 拦截所有资源：/*		访问所有资源时，过滤器都会被执行</span><br><span class="hljs-comment">		* 拦截方式配置：资源被访问的方式</span><br><span class="hljs-comment">			* 注解配置：</span><br><span class="hljs-comment">				* 设置dispatcherTypes属性</span><br><span class="hljs-comment">					1. REQUEST：默认值。浏览器直接请求资源</span><br><span class="hljs-comment">					2. FORWARD：转发访问资源</span><br><span class="hljs-comment">					3. INCLUDE：包含访问资源</span><br><span class="hljs-comment">					4. ERROR：错误跳转资源</span><br><span class="hljs-comment">					5. ASYNC：异步访问资源</span><br><span class="hljs-comment">			* web.xml配置</span><br><span class="hljs-comment">				* 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可</span><br><span class="hljs-comment">			</span><br><span class="hljs-comment">	5. 过滤器链(配置多个过滤器)</span><br><span class="hljs-comment">		* 执行顺序：如果有两个过滤器：过滤器1和过滤器2</span><br><span class="hljs-comment">			1. 过滤器1</span><br><span class="hljs-comment">			2. 过滤器2</span><br><span class="hljs-comment">			3. 资源执行</span><br><span class="hljs-comment">			4. 过滤器2</span><br><span class="hljs-comment">			5. 过滤器1 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">		* 过滤器先后顺序问题：</span><br><span class="hljs-comment">			1. 注解配置：按照类名的字符串比较规则比较，值小的先执行</span><br><span class="hljs-comment">				* 如： AFilter 和 BFilter，AFilter就先执行了。</span><br><span class="hljs-comment">			2. web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行</span><br><span class="hljs-comment">4. 案例：</span><br><span class="hljs-comment">	1. 案例1_登录验证</span><br><span class="hljs-comment">		* 需求：</span><br><span class="hljs-comment">			1. 访问day17_case案例的资源。验证其是否登录</span><br><span class="hljs-comment">			2. 如果登录了，则直接放行。</span><br><span class="hljs-comment">			3. 如果没有登录，则跳转到登录页面，提示"您尚未登录，请先登录"。</span><br></code></pre></td></tr></table></figure>


<p>​    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">2</span>. 案例<span class="hljs-number">2</span>_敏感词汇过滤<br>	* 需求：<br>		<span class="hljs-number">1</span>. 对day17_case案例录入的数据进行敏感词汇过滤<br>		<span class="hljs-number">2</span>. 敏感词汇参考《敏感词汇.txt》<br>		<span class="hljs-number">3</span>. 如果是敏感词汇，替换为 *** <br><br>	* 分析：<br>		<span class="hljs-number">1</span>. 对request对象进行增强。增强获取参数相关方法<br>		<span class="hljs-number">2</span>. 放行。传递代理对象<br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* 增强对象的功能：<br>	* 设计模式：一些通用的解决固定问题的方式<br>	<span class="hljs-number">1</span>. 装饰模式<br>	<span class="hljs-number">2</span>. 代理模式<br>		* 概念：<br>			<span class="hljs-number">1</span>. 真实对象：被代理的对象<br>			<span class="hljs-number">2</span>. 代理对象：<br>			<span class="hljs-number">3</span>. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的<br>	 	* 实现方式：<br>		 	<span class="hljs-number">1</span>. 静态代理：有一个类文件描述代理模式<br>		 	<span class="hljs-number">2</span>. 动态代理：在内存中形成代理类<br>				* 实现步骤：<br>					<span class="hljs-number">1</span>. 代理对象和真实对象实现相同的接口<br>					<span class="hljs-number">2</span>. 代理对象 = Proxy.newProxyInstance();<br>					<span class="hljs-number">3</span>. 使用代理对象调用方法。<br>					<span class="hljs-number">4</span>. 增强方法<br><br>				* 增强方式：<br>					<span class="hljs-number">1</span>. 增强参数列表<br>					<span class="hljs-number">2</span>. 增强返回值类型<br>					<span class="hljs-number">3</span>. 增强方法体执行逻辑<br></code></pre></td></tr></table></figure>


<h2 id="Listener：监听器"><a href="#Listener：监听器" class="headerlink" title="Listener：监听器"></a>Listener：监听器</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* 概念：web的三大组件之一。<br>	* 事件监听机制<br>		* 事件	：一件事情<br>		* 事件源 ：事件发生的地方<br>		* 监听器 ：一个对象<br>		* 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码<br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* ServletContextListener:监听ServletContext对象的创建和销毁<br>	* 方法：<br>		* <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextDestroyed</span><span class="hljs-params">(ServletContextEvent sce)</span> ：ServletContext对象被销毁之前会调用该方法</span><br><span class="hljs-function">		* <span class="hljs-keyword">void</span> <span class="hljs-title">contextInitialized</span><span class="hljs-params">(ServletContextEvent sce)</span> ：ServletContext对象创建后会调用该方法</span><br><span class="hljs-function">	* 步骤：</span><br><span class="hljs-function">		1. 定义一个类，实现ServletContextListener接口</span><br><span class="hljs-function">		2. 复写方法</span><br><span class="hljs-function">		3. 配置</span><br><span class="hljs-function">			1. web.xml</span><br><span class="hljs-function">					&lt;listener&gt;</span><br><span class="hljs-function"> 					 &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt;</span><br></code></pre></td></tr></table></figure>

<pre><code>&lt;/listener&gt;</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">		* 指定初始化参数&lt;context-param&gt;<br><span class="hljs-number">2</span>. 注解：<br>	* <span class="hljs-meta">@WebListener</span><br></code></pre></td></tr></table></figure>

<p>F</p>
]]></content>
      <tags>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title>异常与线程</title>
    <url>/2020/04/12/%E5%BC%82%E5%B8%B8%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li><p>异常、线程</p>
<a id="more"></a>

</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够辨别程序中异常和错误的区别</li>
<li><input disabled="" type="checkbox"> 说出异常的分类</li>
<li><input disabled="" type="checkbox"> 说出虚拟机处理异常的方式</li>
<li><input disabled="" type="checkbox"> 列举出常见的三个运行期异常</li>
<li><input disabled="" type="checkbox"> 能够使用try…catch关键字处理异常</li>
<li><input disabled="" type="checkbox"> 能够使用throws关键字处理异常</li>
<li><input disabled="" type="checkbox"> 能够自定义异常类</li>
<li><input disabled="" type="checkbox"> 能够处理自定义异常类</li>
<li><input disabled="" type="checkbox"> 说出进程的概念</li>
<li><input disabled="" type="checkbox"> 说出线程的概念</li>
<li><input disabled="" type="checkbox"> 能够理解并发与并行的区别</li>
<li><input disabled="" type="checkbox"> 能够开启新线程</li>
</ul>
<h1 id="第一章-异常"><a href="#第一章-异常" class="headerlink" title="第一章    异常"></a>第一章    异常</h1><h2 id="1-1-异常概念"><a href="#1-1-异常概念" class="headerlink" title="1.1 异常概念"></a>1.1 异常概念</h2><p>异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：</p>
<ul>
<li><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</li>
</ul>
<p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。</p>
<blockquote>
<p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.</p>
</blockquote>
<h2 id="1-2-异常体系"><a href="#1-2-异常体系" class="headerlink" title="1.2 异常体系"></a>1.2 异常体系</h2><p>异常机制其实是帮助我们<strong>找到</strong>程序中的问题，异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>。</p>


<p><strong>Throwable体系：</strong></p>
<ul>
<li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。</li>
<li><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。</li>
</ul>
<p><strong>Throwable中的常用方法：</strong></p>
<ul>
<li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p>
<p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
</li>
<li><p><code>public String getMessage()</code>:获取发生异常的原因。</p>
<p><em>提示给用户的时候,就提示错误原因。</em></p>
</li>
<li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p>
</li>
</ul>
<p><strong><em>出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。</em></strong></p>
<h2 id="1-3-异常分类"><a href="#1-3-异常分类" class="headerlink" title="1.3 异常分类"></a>1.3 异常分类</h2><p>我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。</p>
<p><strong>异常(Exception)的分类</strong>:根据在编译时期还是运行时期去检查异常?</p>
<ul>
<li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li>
<li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</li>
</ul>
<p>​    <img src="/2020/04/12/%E5%BC%82%E5%B8%B8%E4%B8%8E%E7%BA%BF%E7%A8%8B/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB.png" class="" title="异常的分类"></p>
<h2 id="1-4-异常的产生过程解析"><a href="#1-4-异常的产生过程解析" class="headerlink" title="1.4     异常的产生过程解析"></a>1.4     异常的产生过程解析</h2><p>先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。</p>
<p> 工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayTools</span> </span>&#123;<br>    <span class="hljs-comment">// 对给定的数组通过给定的角标获取元素。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> element = arr[index];<br>        <span class="hljs-keyword">return</span> element;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123; <span class="hljs-number">34</span>, <span class="hljs-number">12</span>, <span class="hljs-number">67</span> &#125;;<br>        intnum = ArrayTools.getElement(arr, <span class="hljs-number">4</span>)<br>        System.out.println(<span class="hljs-string">"num="</span> + num);<br>        System.out.println(<span class="hljs-string">"over"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述程序执行过程图解：</p>
 



<h1 id="第二章-异常的处理"><a href="#第二章-异常的处理" class="headerlink" title="第二章 异常的处理"></a>第二章 异常的处理</h1><p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p>
<h2 id="2-1-抛出异常throw"><a href="#2-1-抛出异常throw" class="headerlink" title="2.1     抛出异常throw"></a>2.1     抛出异常throw</h2><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p>
<p>在java中，提供了一个<strong>throw</strong>关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p>
<ol>
<li><p>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p>
</li>
<li><p>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。</p>
<p>throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p>
</li>
</ol>
<p><strong>使用格式：</strong></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type"></span>异常类名(参数);<br></code></pre></td></tr></table></figure>

<p> 例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"要访问的arr数组不存在"</span>);<br><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArrayIndexOutOfBoundsException(<span class="hljs-string">"该索引在数组中不存在，已超出范围"</span>);<br></code></pre></td></tr></table></figure>

<p>学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThrowDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建一个数组 </span><br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">52</span>,<span class="hljs-number">2</span>&#125;;<br>        <span class="hljs-comment">//根据索引找对应的元素 </span><br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">int</span> element = getElement(arr, index);<br><br>        System.out.println(element);<br>        System.out.println(<span class="hljs-string">"over"</span>);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 根据 索引找到数组中对应的元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> index)</span></span>&#123; <br>       	<span class="hljs-comment">//判断  索引是否越界</span><br>        <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span> || index&gt;arr.length-<span class="hljs-number">1</span>)&#123;<br>             <span class="hljs-comment">/*</span><br><span class="hljs-comment">             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。</span><br><span class="hljs-comment">             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 </span><br><span class="hljs-comment">              */</span><br>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArrayIndexOutOfBoundsException(<span class="hljs-string">"哥们，角标越界了~~~"</span>);<br>        &#125;<br>        <span class="hljs-keyword">int</span> element = arr[index];<br>        <span class="hljs-keyword">return</span> element;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。</p>
<p>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</p>
</blockquote>
<h2 id="2-2-Objects非空判断"><a href="#2-2-Objects非空判断" class="headerlink" title="2.2 Objects非空判断"></a>2.2 Objects非空判断</h2><p>还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。</p>
<ul>
<li><code>public static &lt;T&gt; T requireNonNull(T obj)</code>:查看指定引用对象不是null。</li>
</ul>
<p>查看源码发现这里对为null的进行了抛出异常操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">requireNonNull</span><span class="hljs-params">(T obj)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>)<br>      	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-3-声明异常throws"><a href="#2-3-声明异常throws" class="headerlink" title="2.3  声明异常throws"></a>2.3  声明异常throws</h2><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p>
<p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p>
<p><strong>声明异常格式：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">修饰符 返回值类型 方法名(参数) throws 异常类名<span class="hljs-number">1</span>,异常类名<span class="hljs-number">2</span>…&#123;   &#125;<br></code></pre></td></tr></table></figure>

<p>声明异常的代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThrowsDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        read(<span class="hljs-string">"a.txt"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        <span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">"a.txt"</span>)) &#123;<span class="hljs-comment">//如果不是 a.txt这个文件 </span><br>            <span class="hljs-comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(<span class="hljs-string">"文件不存在"</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThrowsDemo2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        read(<span class="hljs-string">"a.txt"</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String path)</span><span class="hljs-keyword">throws</span> FileNotFoundException, IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">"a.txt"</span>)) &#123;<span class="hljs-comment">//如果不是 a.txt这个文件 </span><br>            <span class="hljs-comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(<span class="hljs-string">"文件不存在"</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">"b.txt"</span>)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-4-捕获异常try…catch"><a href="#2-4-捕获异常try…catch" class="headerlink" title="2.4  捕获异常try…catch"></a>2.4  捕获异常try…catch</h2><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p>
<ol>
<li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li>
<li>在方法中使用try-catch的语句块来处理异常。</li>
</ol>
<p><strong>try-catch</strong>的方式就是捕获异常。</p>
<ul>
<li><strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li>
</ul>
<p>捕获异常语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>     编写可能会出现异常的代码<br>&#125;<span class="hljs-keyword">catch</span>(异常类型  e)&#123;<br>     处理异常的代码<br>     <span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>try：</strong>该代码块中编写可能产生异常的代码。</p>
<p><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p>
<blockquote>
<p>注意:try和catch都不能单独使用,必须连用。</p>
</blockquote>
<p>演示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TryCatchDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// 当产生异常时，必须有处理方式。要么捕获，要么声明。</span><br>            read(<span class="hljs-string">"b.txt"</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<span class="hljs-comment">// 括号中需要定义什么呢？</span><br>          	<span class="hljs-comment">//try中抛出的是什么异常，在括号中就定义什么异常类型</span><br>            System.out.println(e);<br>        &#125;<br>        System.out.println(<span class="hljs-string">"over"</span>);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        <span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">"a.txt"</span>)) &#123;<span class="hljs-comment">//如果不是 a.txt这个文件 </span><br>            <span class="hljs-comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(<span class="hljs-string">"文件不存在"</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如何获取异常信息：</p>
<p>Throwable类中定义了一些查看方法:</p>
<ul>
<li><code>public String getMessage()</code>:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。</li>
</ul>
<ul>
<li><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</li>
<li><code>public void printStackTrace()</code>:打印异常的跟踪栈信息并输出到控制台。</li>
</ul>
<p>​            <em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
<h2 id="2-4-finally-代码块"><a href="#2-4-finally-代码块" class="headerlink" title="2.4 finally 代码块"></a>2.4 finally 代码块</h2><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p>
<p>什么时候的代码必须最终执行？</p>
<p>当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。</p>
<p>finally的语法:</p>
<p> try…catch….finally:自身需要处理异常,最终还得关闭资源。</p>
<blockquote>
<p>注意:finally不能单独使用。</p>
</blockquote>
<p>比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。</p>
<p>finally代码参考如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TryCatchDemo4</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            read(<span class="hljs-string">"a.txt"</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            <span class="hljs-comment">//抓取到的是编译期异常  抛出去的是运行期 </span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">"不管程序怎样，这里都将会被执行。"</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">"over"</span>);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        <span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">"a.txt"</span>)) &#123;<span class="hljs-comment">//如果不是 a.txt这个文件 </span><br>            <span class="hljs-comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(<span class="hljs-string">"文件不存在"</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。</p>
</blockquote>
<h2 id="2-5-异常注意事项"><a href="#2-5-异常注意事项" class="headerlink" title="2.5   异常注意事项"></a>2.5   异常注意事项</h2><ul>
<li><p>多个异常使用捕获又该如何处理呢？</p>
<ol>
<li>多个异常分别处理。</li>
<li>多个异常一次捕获，多次处理。</li>
<li>多个异常一次捕获一次处理。</li>
</ol>
<p>一般我们是使用一次捕获多次处理方式，格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>     编写可能会出现异常的代码<br>&#125;<span class="hljs-keyword">catch</span>(异常类型A  e)&#123;  当<span class="hljs-keyword">try</span>中出现A类型异常,就用该<span class="hljs-keyword">catch</span>来捕获.<br>     处理异常的代码<br>     <span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型B  e)&#123;  当<span class="hljs-keyword">try</span>中出现B类型异常,就用该<span class="hljs-keyword">catch</span>来捕获.<br>     处理异常的代码<br>     <span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p>
</blockquote>
</li>
<li><p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p>
</li>
<li><p>如果finally有return语句,永远返回finally中的结果,避免该情况. </p>
</li>
<li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p>
</li>
<li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p>
</li>
</ul>
<h1 id="第三章-自定义异常"><a href="#第三章-自定义异常" class="headerlink" title="第三章 自定义异常"></a>第三章 自定义异常</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p><strong>为什么需要自定义异常类:</strong></p>
<p>我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。</p>
<p>在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？</p>
<p><strong>什么是自定义异常类:</strong></p>
<p>在开发中根据自己业务的异常情况来定义异常类.</p>
<p>自定义一个业务逻辑异常: <strong>RegisterException</strong>。一个注册异常类。</p>
<p><strong>异常类如何定义:</strong></p>
<ol>
<li>自定义一个编译期异常: 自定义类 并继承于<code>java.lang.Exception</code>。</li>
<li>自定义一个运行时期的异常类:自定义类 并继承于<code>java.lang.RuntimeException</code>。</li>
</ol>
<h2 id="3-2-自定义异常的练习"><a href="#3-2-自定义异常的练习" class="headerlink" title="3.2 自定义异常的练习"></a>3.2 自定义异常的练习</h2><p>要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。</p>
<p>首先定义一个登陆异常类RegisterException：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 业务逻辑异常</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegisterException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 空参构造</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RegisterException</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 表示异常提示</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RegisterException</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-comment">// 模拟数据库中已存在账号</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String[] names = &#123;<span class="hljs-string">"bill"</span>,<span class="hljs-string">"hill"</span>,<span class="hljs-string">"jill"</span>&#125;;<br>   <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;     <br>        <span class="hljs-comment">//调用方法</span><br>        <span class="hljs-keyword">try</span>&#123;<br>              <span class="hljs-comment">// 可能出现异常的代码</span><br>            checkUsername(<span class="hljs-string">"nill"</span>);<br>            System.out.println(<span class="hljs-string">"注册成功"</span>);<span class="hljs-comment">//如果没有异常就是注册成功</span><br>        &#125;<span class="hljs-keyword">catch</span>(RegisterException e)&#123;<br>            <span class="hljs-comment">//处理异常</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//判断当前注册账号是否存在</span><br>    <span class="hljs-comment">//因为是编译期异常，又想调用者去处理 所以声明该异常</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkUsername</span><span class="hljs-params">(String uname)</span> <span class="hljs-keyword">throws</span> LoginException</span>&#123;<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            <span class="hljs-keyword">if</span>(name.equals(uname))&#123;<span class="hljs-comment">//如果名字在这里面 就抛出登陆异常</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RegisterException(<span class="hljs-string">"亲"</span>+name+<span class="hljs-string">"已经被注册了！"</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="第四章-多线程"><a href="#第四章-多线程" class="headerlink" title="第四章 多线程"></a>第四章 多线程</h1><p>我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？</p>
<p>要解决上述问题,咱们得使用多进程或者多线程来解决.</p>
<h2 id="4-1-并发与并行"><a href="#4-1-并发与并行" class="headerlink" title="4.1 并发与并行"></a>4.1 并发与并行</h2><ul>
<li><p><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</p>
</li>
<li><p><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</p>
{% asset_img 并行与并发.bmp 并行与并发 %}

</li>
</ul>
<p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p>
<p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p>
<blockquote>
<p>注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p>
</blockquote>
<h2 id="4-2-线程与进程"><a href="#4-2-线程与进程" class="headerlink" title="4.2 线程与进程"></a>4.2 线程与进程</h2><ul>
<li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p>
</li>
<li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p>
<p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 </p>
</li>
</ul>
<p>我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程：</p>
<p><strong>进程</strong></p>
 {% asset_img 进程概念.png 进程 %}

<p><strong>线程</strong></p>
 {% asset_img 线程概念.png 线程 %}

<p><strong>线程调度:</strong></p>
<ul>
<li><p>分时调度</p>
<p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p>
</li>
<li><p>抢占式调度</p>
<p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p>
<ul>
<li><p>设置线程的优先级</p>
{% asset_img 设置线程优先级.bmp 线程优先 %}
</li>
<li><p>抢占式调度详解</p>
<p>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。</p>
<p>实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。<br>其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</p>
 {% asset_img 抢占式调度.bmp 异常产生过程 %}

</li>
</ul>
</li>
</ul>
<h2 id="4-3-创建线程类"><a href="#4-3-创建线程类" class="headerlink" title="4.3 创建线程类"></a>4.3 创建线程类</h2><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p>
<ol>
<li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ol>
<p>代码如下：</p>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">//创建自定义线程对象</span><br>		MyThread mt = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">"新的线程！"</span>);<br>		<span class="hljs-comment">//开启新线程</span><br>		mt.start();<br>		<span class="hljs-comment">//在主方法中执行for循环</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>			System.out.println(<span class="hljs-string">"main线程！"</span>+i);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>自定义线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>	<span class="hljs-comment">//定义指定线程名称的构造方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span> </span>&#123;<br>		<span class="hljs-comment">//调用父类的String参数的构造方法，指定线程的名称</span><br>		<span class="hljs-keyword">super</span>(name);<br>	&#125;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 重写run方法，完成该线程执行的逻辑</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>			System.out.println(getName()+<span class="hljs-string">"：正在执行！"</span>+i);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>CookieSession</title>
    <url>/2020/04/10/CookieSession/</url>
    <content><![CDATA[<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>1.Cookie</p>
<p>2.Session</p>
<a id="more"></a>

<h2 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>. 会话：一次会话中包含多次请求和响应。<br>	* 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止<br><span class="hljs-number">2</span>. 功能：在一次会话的范围内的多次请求间，共享数据<br><span class="hljs-number">3</span>. 方式：<br>	<span class="hljs-number">1</span>. 客户端会话技术：Cookie<br>	<span class="hljs-number">2</span>. 服务器端会话技术：Session<br></code></pre></td></tr></table></figure>

<h2 id="Cookie："><a href="#Cookie：" class="headerlink" title="Cookie："></a>Cookie：</h2>{% asset_img Cookie原理.bmp Cookie原理 %}

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>. 概念：客户端会话技术，将数据保存到客户端<br><br><span class="hljs-number">2</span>. 快速入门：<br>	* 使用步骤：<br>		<span class="hljs-number">1</span>. 创建Cookie对象，绑定数据<br>			* <span class="hljs-keyword">new</span> Cookie(String name, String value) <br>		<span class="hljs-number">2</span>. 发送Cookie对象<br>			* response.addCookie(Cookie cookie) <br>		<span class="hljs-number">3</span>. 获取Cookie，拿到数据<br>			* Cookie[]  request.getCookies()<br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">3</span>. 实现原理<br>	* 基于响应头set-cookie和请求头cookie实现<br><br><span class="hljs-number">4</span>. cookie的细节<br>	<span class="hljs-number">1</span>. 一次可不可以发送多个cookie?<br>		* 可以<br>		* 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。<br>	<span class="hljs-number">2</span>. cookie在浏览器中保存多长时间？<br>		<span class="hljs-number">1</span>. 默认情况下，当浏览器关闭后，Cookie数据被销毁<br>		<span class="hljs-number">2</span>. 持久化存储：<br>			* setMaxAge(<span class="hljs-keyword">int</span> seconds)<br>				<span class="hljs-number">1</span>. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效<br>				<span class="hljs-number">2</span>. 负数：默认值<br>				<span class="hljs-number">3</span>. 零：删除cookie信息<br>	<span class="hljs-number">3</span>. cookie能不能存中文？<br>		* 在tomcat <span class="hljs-number">8</span> 之前 cookie中不能直接存储中文数据。<br>			* 需要将中文数据转码---一般采用URL编码(%E3)<br>		* 在tomcat <span class="hljs-number">8</span> 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析<br>	<span class="hljs-number">4</span>. cookie共享问题？<br>		<span class="hljs-number">1</span>. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？<br>			* 默认情况下cookie不能共享<br><br>			* setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录<br>				* 如果要共享，则可以将path设置为<span class="hljs-string">"/"</span><br></code></pre></td></tr></table></figure>


<p>​            </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">2</span>. 不同的tomcat服务器间cookie共享问题？<br>	* setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享<br>		* setDomain(<span class="hljs-string">".baidu.com"</span>),那么tieba.baidu.com和news.baidu.com中cookie可以共享<br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">5</span>. Cookie的特点和作用<br>	<span class="hljs-number">1</span>. cookie存储数据在客户端浏览器<br>	<span class="hljs-number">2</span>. 浏览器对于单个cookie 的大小有限制(<span class="hljs-number">4</span>kb) 以及 对同一个域名下的总cookie数量也有限制(<span class="hljs-number">20</span>个)<br><br>	* 作用：<br>		<span class="hljs-number">1</span>. cookie一般用于存出少量的不太敏感的数据<br>		<span class="hljs-number">2</span>. 在不登录的情况下，完成服务器对客户端的身份识别<br><br><span class="hljs-number">6</span>. 案例：记住上一次访问时间<br>	<span class="hljs-number">1</span>. 需求：<br>		<span class="hljs-number">1</span>. 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。<br>		<span class="hljs-number">2</span>. 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串<br><br>	<span class="hljs-number">2</span>. 分析：<br>		<span class="hljs-number">1</span>. 可以采用Cookie来完成<br>		<span class="hljs-number">2</span>. 在服务器中的Servlet判断是否有一个名为lastTime的cookie<br>			<span class="hljs-number">1</span>. 有：不是第一次访问<br>				<span class="hljs-number">1</span>. 响应数据：欢迎回来，您上次访问时间为:<span class="hljs-number">2018</span>年<span class="hljs-number">6</span>月<span class="hljs-number">10</span>日<span class="hljs-number">11</span>:<span class="hljs-number">50</span>:<span class="hljs-number">20</span><br>				<span class="hljs-number">2</span>. 写回Cookie：lastTime=<span class="hljs-number">2018</span>年<span class="hljs-number">6</span>月<span class="hljs-number">10</span>日<span class="hljs-number">11</span>:<span class="hljs-number">50</span>:<span class="hljs-number">01</span><br>			<span class="hljs-number">2</span>. 没有：是第一次访问<br>				<span class="hljs-number">1</span>. 响应数据：您好，欢迎您首次访问<br>				<span class="hljs-number">2</span>. 写回Cookie：lastTime=<span class="hljs-number">2018</span>年<span class="hljs-number">6</span>月<span class="hljs-number">10</span>日<span class="hljs-number">11</span>:<span class="hljs-number">50</span>:<span class="hljs-number">01</span><br><br>	<span class="hljs-number">3</span>. 代码实现：<br>		<span class="hljs-keyword">package</span> cn.itcast.cookie;<br><br>		<span class="hljs-keyword">import</span> javax.servlet.ServletException;<br>		<span class="hljs-keyword">import</span> javax.servlet.annotation.WebServlet;<br>		<span class="hljs-keyword">import</span> javax.servlet.http.Cookie;<br>		<span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br>		<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br>		<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br>		<span class="hljs-keyword">import</span> java.io.IOException;<br>		<span class="hljs-keyword">import</span> java.net.URLDecoder;<br>		<span class="hljs-keyword">import</span> java.net.URLEncoder;<br>		<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br>		<span class="hljs-keyword">import</span> java.util.Date;<br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet</span>(<span class="hljs-string">"/cookieTest"</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CookieTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-comment">//设置响应的消息体的数据格式以及编码</span><br>        response.setContentType(<span class="hljs-string">"text/html;charset=utf-8"</span>);<br><br>        <span class="hljs-comment">//1.获取所有Cookie</span><br>        Cookie[] cookies = request.getCookies();<br>        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//没有cookie为lastTime</span><br>        <span class="hljs-comment">//2.遍历cookie数组</span><br>        <span class="hljs-keyword">if</span>(cookies != <span class="hljs-keyword">null</span> &amp;&amp; cookies.length &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">for</span> (Cookie cookie : cookies) &#123;<br>                <span class="hljs-comment">//3.获取cookie的名称</span><br>                String name = cookie.getName();<br>                <span class="hljs-comment">//4.判断名称是否是：lastTime</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-string">"lastTime"</span>.equals(name))&#123;<br>                    <span class="hljs-comment">//有该Cookie，不是第一次访问</span><br><br>                    flag = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//有lastTime的cookie</span><br><br>                    <span class="hljs-comment">//设置Cookie的value</span><br>                    <span class="hljs-comment">//获取当前时间的字符串，重新设置Cookie的值，重新发送cookie</span><br>                    Date date  = <span class="hljs-keyword">new</span> Date();<br>                    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy年MM月dd日 HH:mm:ss"</span>);<br>                    String str_date = sdf.format(date);<br>                    System.out.println(<span class="hljs-string">"编码前："</span>+str_date);<br>                    <span class="hljs-comment">//URL编码</span><br>                    str_date = URLEncoder.encode(str_date,<span class="hljs-string">"utf-8"</span>);<br>                    System.out.println(<span class="hljs-string">"编码后："</span>+str_date);<br>                    cookie.setValue(str_date);<br>                    <span class="hljs-comment">//设置cookie的存活时间</span><br>                    cookie.setMaxAge(<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">30</span>);<span class="hljs-comment">//一个月</span><br>                    response.addCookie(cookie);<br></code></pre></td></tr></table></figure>


<p>​        </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">            <span class="hljs-comment">//响应数据</span><br>            <span class="hljs-comment">//获取Cookie的value，时间</span><br>            String value = cookie.getValue();<br>            System.out.println(<span class="hljs-string">"解码前："</span>+value);<br>            <span class="hljs-comment">//URL解码：</span><br>            value = URLDecoder.decode(value,<span class="hljs-string">"utf-8"</span>);<br>            System.out.println(<span class="hljs-string">"解码后："</span>+value);<br>            response.getWriter().write(<span class="hljs-string">"&lt;h1&gt;欢迎回来，您上次访问时间为:"</span>+value+<span class="hljs-string">"&lt;/h1&gt;"</span>);<br>	<br>            <span class="hljs-keyword">break</span>;<br>	<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>​        </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(cookies == <span class="hljs-keyword">null</span> || cookies.length == <span class="hljs-number">0</span> || flag == <span class="hljs-keyword">false</span>)&#123;<br>    <span class="hljs-comment">//没有，第一次访问</span><br>	<br>    <span class="hljs-comment">//设置Cookie的value</span><br>    <span class="hljs-comment">//获取当前时间的字符串，重新设置Cookie的值，重新发送cookie</span><br>    Date date  = <span class="hljs-keyword">new</span> Date();<br>    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy年MM月dd日 HH:mm:ss"</span>);<br>    String str_date = sdf.format(date);<br>    System.out.println(<span class="hljs-string">"编码前："</span>+str_date);<br>    <span class="hljs-comment">//URL编码</span><br>    str_date = URLEncoder.encode(str_date,<span class="hljs-string">"utf-8"</span>);<br>    System.out.println(<span class="hljs-string">"编码后："</span>+str_date);<br>	<br>    Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">"lastTime"</span>,str_date);<br>    <span class="hljs-comment">//设置cookie的存活时间</span><br>    cookie.setMaxAge(<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">30</span>);<span class="hljs-comment">//一个月</span><br>    response.addCookie(cookie);<br>	<br>    response.getWriter().write(<span class="hljs-string">"&lt;h1&gt;您好，欢迎您首次访问&lt;/h1&gt;"</span>);<br>&#125;<br></code></pre></td></tr></table></figure>


<p>​        </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.doPost(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Cookie案例记住上次访问时间：{% asset_img Cookie案例_记住上次访问时间.bmp 案例分析 %}</p>
<h2 id="Session：主菜"><a href="#Session：主菜" class="headerlink" title="Session：主菜"></a>Session：主菜</h2>{% asset_img Session原理.bmp Session原理 %}

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>. 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession<br><span class="hljs-number">2</span>. 快速入门：<br>	<span class="hljs-number">1</span>. 获取HttpSession对象：<br>		HttpSession session = request.getSession();<br>	<span class="hljs-number">2</span>. 使用HttpSession对象：<br>		<span class="hljs-function">Object <span class="hljs-title">getAttribute</span><span class="hljs-params">(String name)</span>  </span><br><span class="hljs-function">		<span class="hljs-keyword">void</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(String name, Object value)</span></span><br><span class="hljs-function">		<span class="hljs-keyword">void</span> <span class="hljs-title">removeAttribute</span><span class="hljs-params">(String name)</span>  </span><br><span class="hljs-function"></span><br><span class="hljs-function">3. 原理</span><br><span class="hljs-function">	* Session的实现是依赖于Cookie的。</span><br></code></pre></td></tr></table></figure>


<p>​    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">4</span>. 细节：<br>	<span class="hljs-number">1</span>. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？<br>		* 默认情况下。不是。<br>		* 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。<br>			 Cookie c = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">"JSESSIONID"</span>,session.getId());<br>	         c.setMaxAge(<span class="hljs-number">60</span>*<span class="hljs-number">60</span>);<br>	         response.addCookie(c);<br><br>	<span class="hljs-number">2</span>. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？<br>		* 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作<br>			* session的钝化：<br>				* 在服务器正常关闭之前，将session对象系列化到硬盘上<br>			* session的活化：<br>				* 在服务器启动后，将session文件转化为内存中的session对象即可。<br>			<br>	<span class="hljs-number">3</span>. session什么时候被销毁？<br>		<span class="hljs-number">1</span>. 服务器关闭<br>		<span class="hljs-number">2</span>. session对象调用invalidate() 。<br>		<span class="hljs-number">3</span>. session默认失效时间 <span class="hljs-number">30</span>分钟<br>			选择性配置修改	<br>			&lt;session-config&gt;<br>		        &lt;session-timeout&gt;30&lt;/session-timeout&gt;<br>		    &lt;/session-config&gt;<br><br> <span class="hljs-number">5</span>. session的特点<br>	 <span class="hljs-number">1</span>. session用于存储一次会话的多次请求的数据，存在服务器端<br>	 <span class="hljs-number">2</span>. session可以存储任意类型，任意大小的数据<br><br>	* session与Cookie的区别：<br>		<span class="hljs-number">1</span>. session存储数据在服务器端，Cookie在客户端<br>		<span class="hljs-number">2</span>. session没有数据大小限制，Cookie有<br>		<span class="hljs-number">3</span>. session数据安全，Cookie相对于不安全<br></code></pre></td></tr></table></figure>


<h2 id="案例：验证码"><a href="#案例：验证码" class="headerlink" title="案例：验证码"></a>案例：验证码</h2><pre><code>1. 案例需求：
    1. 访问带有验证码的登录页面login.jsp
    2. 用户输入用户名，密码以及验证码。
        * 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误
        * 如果验证码输入有误，跳转登录页面，提示：验证码错误
        * 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您</code></pre><ol start="2">
<li>分析：<img src="/2020/04/10/CookieSession/%E7%99%BB%E5%BD%95%E6%A1%88%E4%BE%8B.bmp" class="" title="案例分析"></li>
</ol>
<p>​    </p>
]]></content>
      <tags>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title>Response介绍</title>
    <url>/2020/04/10/Response%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>1.HTTP协议：响应消息</p>
<p>2.Response对象</p>
<p>3.ServletContext对象</p>
<a id="more"></a>


<h2 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>. 请求消息：客户端发送给服务器端的数据<br>	* 数据格式：<br>		<span class="hljs-number">1</span>. 请求行<br>		<span class="hljs-number">2</span>. 请求头<br>		<span class="hljs-number">3</span>. 请求空行<br>		<span class="hljs-number">4</span>. 请求体<br><span class="hljs-number">2</span>. 响应消息：服务器端发送给客户端的数据<br>	* 数据格式：<br>		<span class="hljs-number">1</span>. 响应行<br>			<span class="hljs-number">1</span>. 组成：协议/版本 响应状态码 状态码描述<br>			<span class="hljs-number">2</span>. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。<br>				<span class="hljs-number">1</span>. 状态码都是<span class="hljs-number">3</span>位数字 <br>				<span class="hljs-number">2</span>. 分类：<br>					<span class="hljs-number">1</span>. <span class="hljs-number">1</span>xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送<span class="hljs-number">1</span>xx多状态码<br>					<span class="hljs-number">2</span>. <span class="hljs-number">2</span>xx：成功。代表：<span class="hljs-number">200</span><br>					<span class="hljs-number">3</span>. <span class="hljs-number">3</span>xx：重定向。代表：<span class="hljs-number">302</span>(重定向)，<span class="hljs-number">304</span>(访问缓存)<br>					<span class="hljs-number">4</span>. <span class="hljs-number">4</span>xx：客户端错误。<br>						* 代表：<br>							* <span class="hljs-number">404</span>（请求路径没有对应的资源） <br>							* <span class="hljs-number">405</span>：请求方式没有对应的doXxx方法<br>					<span class="hljs-number">5</span>. <span class="hljs-number">5</span>xx：服务器端错误。代表：<span class="hljs-number">500</span>(服务器内部出现异常)<br></code></pre></td></tr></table></figure>


<p>​                    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">2</span>. 响应头：<br>	<span class="hljs-number">1</span>. 格式：头名称： 值<br>	<span class="hljs-number">2</span>. 常见的响应头：<br>		<span class="hljs-number">1</span>. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式<br>		<span class="hljs-number">2</span>. Content-disposition：服务器告诉客户端以什么格式打开响应体数据<br>			* 值：<br>				* in-line:默认值,在当前页面内打开<br>				* attachment;filename=xxx：以附件形式打开响应体。文件下载<br><span class="hljs-number">3</span>. 响应空行<br><span class="hljs-number">4</span>. 响应体:传输的数据<br></code></pre></td></tr></table></figure>


<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">* 响应字符串格式<br>	HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<br>	Content-Type: text/html;charset=UTF-<span class="hljs-number">8</span><br>	Content-Length: <span class="hljs-number">101</span><br>	Date: Wed, <span class="hljs-number">06</span> Jun <span class="hljs-number">2018</span> <span class="hljs-number">07</span>:<span class="hljs-number">08</span>:<span class="hljs-number">42</span> GMT<br><br>	&lt;html&gt;<br>	  &lt;head&gt;<br>	    &lt;title&gt;$Title$&lt;/title&gt;<br>	  &lt;/head&gt;<br>	  &lt;body&gt;<br>	  hello , response<br>	  &lt;/body&gt;<br>	&lt;/html&gt;<br></code></pre></td></tr></table></figure>



<h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2>{% asset_img 重定向.bmp 重定向 %}

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* 功能：设置响应消息<br>	<span class="hljs-number">1</span>. 设置响应行<br>		<span class="hljs-number">1</span>. 格式：HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> ok<br>		<span class="hljs-number">2</span>. 设置状态码：setStatus(<span class="hljs-keyword">int</span> sc) <br>	<span class="hljs-number">2</span>. 设置响应头：setHeader(String name, String value) <br>		<br>	<span class="hljs-number">3</span>. 设置响应体：<br>		* 使用步骤：<br>			<span class="hljs-number">1</span>. 获取输出流<br>				* 字符输出流：<span class="hljs-function">PrintWriter <span class="hljs-title">getWriter</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">				* 字节输出流：ServletOutputStream <span class="hljs-title">getOutputStream</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">			2. 使用输出流，将数据输出到客户端浏览器</span><br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* 案例：<br>	<span class="hljs-number">1</span>. 完成重定向<br>		* 重定向：资源跳转的方式<br>		* 代码实现：<br>			<span class="hljs-comment">//1. 设置状态码为302</span><br>	        response.setStatus(<span class="hljs-number">302</span>);<br>	        <span class="hljs-comment">//2.设置响应头location</span><br>	        response.setHeader(<span class="hljs-string">"location"</span>,<span class="hljs-string">"/day15/responseDemo2"</span>);<br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">       <span class="hljs-comment">//简单的重定向方法</span><br>       response.sendRedirect(<span class="hljs-string">"/day15/responseDemo2"</span>);<br><br>* 重定向的特点:redirect<br>	<span class="hljs-number">1</span>. 地址栏发生变化<br>	<span class="hljs-number">2</span>. 重定向可以访问其他站点(服务器)的资源<br>	<span class="hljs-number">3</span>. 重定向是两次请求。不能使用request对象来共享数据<br>* 转发的特点：forward<br>	<span class="hljs-number">1</span>. 转发地址栏路径不变<br>	<span class="hljs-number">2</span>. 转发只能访问当前服务器下的资源<br>	<span class="hljs-number">3</span>. 转发是一次请求，可以使用request对象来共享数据<br><br>* forward 和  redirect 区别<br>	<br>* 路径写法：<br>	<span class="hljs-number">1</span>. 路径分类<br>		<span class="hljs-number">1</span>. 相对路径：通过相对路径不可以确定唯一资源<br>			* 如：./index.html<br>			* 不以/开头，以.开头路径<br><br>			* 规则：找到当前资源和目标资源之间的相对位置关系<br>				* ./：当前目录<br>				* ../:后退一级目录<br>		<span class="hljs-number">2</span>. 绝对路径：通过绝对路径可以确定唯一资源<br>			* 如：http:<span class="hljs-comment">//localhost/day15/responseDemo2		/day15/responseDemo2</span><br>			* 以/开头的路径<br><br>			* 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出<br>				* 给客户端浏览器使用：需要加虚拟目录(项目的访问路径)<br>					* 建议虚拟目录动态获取：request.getContextPath()<br>					* &lt;a&gt; , &lt;form&gt; 重定向...<br>				* 给服务器使用：不需要加虚拟目录<br>					* 转发路径<br></code></pre></td></tr></table></figure>


<p>​<br>​                        </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">2</span>. 服务器输出字符数据到浏览器<br>	* 步骤：<br>		<span class="hljs-number">1</span>. 获取字符输出流<br>		<span class="hljs-number">2</span>. 输出数据<br><br>	* 注意：<br>		* 乱码问题：<br>			<span class="hljs-number">1</span>. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-<span class="hljs-number">8859</span>-<span class="hljs-number">1</span><br>			<span class="hljs-number">2</span>. 设置该流的默认编码<br>			<span class="hljs-number">3</span>. 告诉浏览器响应体使用的编码<br><br>			<span class="hljs-comment">//简单的形式，设置编码，是在获取流之前设置</span><br>   			response.setContentType(<span class="hljs-string">"text/html;charset=utf-8"</span>);<br><span class="hljs-number">3</span>. 服务器输出字节数据到浏览器<br>	* 步骤：<br>		<span class="hljs-number">1</span>. 获取字节输出流<br>		<span class="hljs-number">2</span>. 输出数据<br><br><span class="hljs-number">4</span>. 验证码<br>	<span class="hljs-number">1</span>. 本质：图片<br>	<span class="hljs-number">2</span>. 目的：防止恶意表单注册<br></code></pre></td></tr></table></figure>



<h2 id="ServletContext对象："><a href="#ServletContext对象：" class="headerlink" title="ServletContext对象："></a>ServletContext对象：</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>. 概念：代表整个web应用，可以和程序的容器(服务器)来通信<br><span class="hljs-number">2</span>. 获取：<br>	<span class="hljs-number">1</span>. 通过request对象获取<br>		request.getServletContext();<br>	<span class="hljs-number">2</span>. 通过HttpServlet获取<br>		<span class="hljs-keyword">this</span>.getServletContext();<br><span class="hljs-number">3</span>. 功能：<br>	<span class="hljs-number">1</span>. 获取MIME类型：<br>		* MIME类型:在互联网通信过程中定义的一种文件数据类型<br>			* 格式： 大类型/小类型   text/html		image/jpeg<br><br>		* 获取：<span class="hljs-function">String <span class="hljs-title">getMimeType</span><span class="hljs-params">(String file)</span>  </span><br><span class="hljs-function">	2. 域对象：共享数据</span><br><span class="hljs-function">		1. <span class="hljs-title">setAttribute</span><span class="hljs-params">(String name,Object value)</span></span><br><span class="hljs-function">		2. <span class="hljs-title">getAttribute</span><span class="hljs-params">(String name)</span></span><br><span class="hljs-function">		3. <span class="hljs-title">removeAttribute</span><span class="hljs-params">(String name)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">		* ServletContext对象范围：所有用户所有请求的数据</span><br><span class="hljs-function">	3. 获取文件的真实<span class="hljs-params">(服务器)</span>路径</span><br><span class="hljs-function">		1. 方法：String <span class="hljs-title">getRealPath</span><span class="hljs-params">(String path)</span>  </span><br><span class="hljs-function">			 String b </span>= context.getRealPath(<span class="hljs-string">"/b.txt"</span>);<span class="hljs-comment">//web目录下资源访问</span><br>	         System.out.println(b);<br>	<br>	        String c = context.getRealPath(<span class="hljs-string">"/WEB-INF/c.txt"</span>);<span class="hljs-comment">//WEB-INF目录下的资源访问</span><br>	        System.out.println(c);<br>	<br>	        String a = context.getRealPath(<span class="hljs-string">"/WEB-INF/classes/a.txt"</span>);<span class="hljs-comment">//src目录下的资源访问</span><br>	        System.out.println(a);<br></code></pre></td></tr></table></figure>



<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>* 文件下载需求：
    1. 页面显示超链接
    2. 点击超链接后弹出下载提示框
    3. 完成图片文件下载


* 分析：
    1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求
    2. 任何资源都必须弹出下载提示框
    3. 使用响应头设置资源的打开方式：
        * content-disposition:attachment;filename=xxx


* 步骤：
    1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename
    2. 定义Servlet
        1. 获取文件名称
        2. 使用字节输入流加载文件进内存
        3. 指定response的响应头： content-disposition:attachment;filename=xxx
        4. 将数据写出到response输出流


* 问题：
    * 中文文件问题
        * 解决思路：
            1. 获取客户端使用的浏览器版本信息
            2. 根据不同的版本信息，设置filename的编码方式不同</code></pre>]]></content>
      <tags>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title>Junit与反射</title>
    <url>/2020/04/08/Junit%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><ol>
<li>Junit单元测试</li>
<li>反射</li>
<li>注解</li>
</ol>
<a id="more"></a>

<h2 id="Junit单元测试："><a href="#Junit单元测试：" class="headerlink" title="Junit单元测试："></a>Junit单元测试：</h2><img src="/2020/04/08/Junit%E4%B8%8E%E5%8F%8D%E5%B0%84/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB.bmp" class="" title="测试分类">

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* 测试分类：<br>	<span class="hljs-number">1</span>. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。<br>	<span class="hljs-number">2</span>. 白盒测试：需要写代码的。关注程序具体的执行流程。<br><br>* Junit使用：白盒测试<br>	* 步骤：<br>		<span class="hljs-number">1</span>. 定义一个测试类(测试用例)<br>			* 建议：<br>				* 测试类名：被测试的类名Test		CalculatorTest<br>				* 包名：xxx.xxx.xx.test		cn.itcast.test<br><br>		<span class="hljs-number">2</span>. 定义测试方法：可以独立运行<br>			* 建议：<br>				* 方法名：test测试的方法名		testAdd()  <br>				* 返回值：<span class="hljs-keyword">void</span><br>				* 参数列表：空参<br><br>		<span class="hljs-number">3</span>. 给方法加<span class="hljs-meta">@Test</span><br>		<span class="hljs-number">4</span>. 导入junit依赖环境<br><br>	* 判定结果：<br>		* 红色：失败<br>		* 绿色：成功<br>		* 一般我们会使用断言操作来处理结果<br>			* Assert.assertEquals(期望的结果,运算的结果);<br><br>	* 补充：<br>		* <span class="hljs-meta">@Before</span>:<br>			* 修饰的方法会在测试方法之前被自动执行<br>		* <span class="hljs-meta">@After</span>:<br>			* 修饰的方法会在测试方法执行之后自动被执行<br></code></pre></td></tr></table></figure>

<h2 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h2><p>代码的三个阶段</p>
{% asset_img Java代码的三个阶段.bmp 代码的三个阶段 %}

<pre><code>* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码
* 反射：将类的各个组成部分封装为其他对象，这就是反射机制
    * 好处：
        1. 可以在程序运行过程中，操作这些对象。
        2. 可以解耦，提高程序的可扩展性。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* 获取Class对象的方式：<br>	<span class="hljs-number">1</span>. Class.forName(<span class="hljs-string">"全类名"</span>)：将字节码文件加载进内存，返回Class对象<br>		* 多用于配置文件，将类名定义在配置文件中。读取文件，加载类<br>	<span class="hljs-number">2</span>. 类名<span class="hljs-class">.<span class="hljs-keyword">class</span>：通过类名的属性<span class="hljs-title">class</span>获取</span><br><span class="hljs-class">		* 多用于参数的传递</span><br><span class="hljs-class">	3. 对象.<span class="hljs-title">getClass</span>()：<span class="hljs-title">getClass</span>()方法在<span class="hljs-title">Object</span>类中定义着。</span><br><span class="hljs-class">		* 多用于对象的获取字节码的方式</span><br><span class="hljs-class"></span><br><span class="hljs-class">	* 结论：</span><br><span class="hljs-class">		同一个字节码文件(*.<span class="hljs-title">class</span>)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的<span class="hljs-title">Class</span>对象都是同一个。</span><br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* Class对象功能：<br>	* 获取功能：<br>		<span class="hljs-number">1</span>. 获取成员变量们<br>			* Field[] getFields() ：获取所有<span class="hljs-keyword">public</span>修饰的成员变量<br>			* <span class="hljs-function">Field <span class="hljs-title">getField</span><span class="hljs-params">(String name)</span>   获取指定名称的 <span class="hljs-keyword">public</span>修饰的成员变量</span><br><span class="hljs-function"></span><br><span class="hljs-function">			* Field[] <span class="hljs-title">getDeclaredFields</span><span class="hljs-params">()</span>  获取所有的成员变量，不考虑修饰符</span><br><span class="hljs-function">			* Field <span class="hljs-title">getDeclaredField</span><span class="hljs-params">(String name)</span>  </span><br><span class="hljs-function">		2. 获取构造方法们</span><br><span class="hljs-function">			* Constructor&lt;?&gt;[] <span class="hljs-title">getConstructors</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function">			* Constructor&lt;T&gt; <span class="hljs-title">getConstructor</span><span class="hljs-params">(类&lt;?&gt;... parameterTypes)</span>  </span><br><span class="hljs-function"></span><br><span class="hljs-function">			* Constructor&lt;T&gt; <span class="hljs-title">getDeclaredConstructor</span><span class="hljs-params">(类&lt;?&gt;... parameterTypes)</span>  </span><br><span class="hljs-function">			* Constructor&lt;?&gt;[] <span class="hljs-title">getDeclaredConstructors</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function">		3. 获取成员方法们：</span><br><span class="hljs-function">			* Method[] <span class="hljs-title">getMethods</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function">			* Method <span class="hljs-title">getMethod</span><span class="hljs-params">(String name, 类&lt;?&gt;... parameterTypes)</span>  </span><br><span class="hljs-function"></span><br><span class="hljs-function">			* Method[] <span class="hljs-title">getDeclaredMethods</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function">			* Method <span class="hljs-title">getDeclaredMethod</span><span class="hljs-params">(String name, 类&lt;?&gt;... parameterTypes)</span>  </span><br><span class="hljs-function"></span><br><span class="hljs-function">		4. 获取全类名	</span><br><span class="hljs-function">			* String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* Field：成员变量<br>	* 操作：<br>		<span class="hljs-number">1</span>. 设置值<br>			* <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Object obj, Object value)</span>  </span><br><span class="hljs-function">		2. 获取值</span><br><span class="hljs-function">			* <span class="hljs-title">get</span><span class="hljs-params">(Object obj)</span> </span><br><span class="hljs-function"></span><br><span class="hljs-function">		3. 忽略访问权限修饰符的安全检查</span><br><span class="hljs-function">			* <span class="hljs-title">setAccessible</span><span class="hljs-params">(<span class="hljs-keyword">true</span>)</span>:暴力反射</span><br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* Constructor:构造方法<br>	* 创建对象：<br>		* <span class="hljs-function">T <span class="hljs-title">newInstance</span><span class="hljs-params">(Object... initargs)</span>  </span><br><span class="hljs-function"></span><br><span class="hljs-function">		* 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</span><br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* Method：方法对象<br>	* 执行方法：<br>		* <span class="hljs-function">Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj, Object... args)</span>  </span><br><span class="hljs-function"></span><br><span class="hljs-function">	* 获取方法名称：</span><br><span class="hljs-function">		* String getName:获取方法名</span><br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* 案例：<br>	* 需求：写一个<span class="hljs-string">"框架"</span>，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法<br>		* 实现：<br>			<span class="hljs-number">1</span>. 配置文件<br>			<span class="hljs-number">2</span>. 反射<br>		* 步骤：<br>			<span class="hljs-number">1</span>. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中<br>			<span class="hljs-number">2</span>. 在程序中加载读取配置文件<br>			<span class="hljs-number">3</span>. 使用反射技术来加载类文件进内存<br>			<span class="hljs-number">4</span>. 创建对象<br>			<span class="hljs-number">5</span>. 执行方法<br></code></pre></td></tr></table></figure>


<h2 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* 概念：说明程序的。给计算机看的<br>* 注释：用文字描述程序的。给程序员看的<br><br>* 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1<span class="hljs-number">.5</span>及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。<br>* 概念描述：<br>	* JDK1<span class="hljs-number">.5</span>之后的新特性<br>	* 说明程序的<br>	* 使用注解：@注解名称<br></code></pre></td></tr></table></figure>


<p>​    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* 作用分类：<br>	①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】<br>	②代码分析：通过代码里标识的注解对代码进行分析【使用反射】<br>	③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】<br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* JDK中预定义的一些注解<br>	* <span class="hljs-meta">@Override</span>	：检测被该注解标注的方法是否是继承自父类(接口)的<br>	* <span class="hljs-meta">@Deprecated</span>：该注解标注的内容，表示已过时<br>	* <span class="hljs-meta">@SuppressWarnings</span>：压制警告<br>		* 一般传递参数all  <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"all"</span>)<br><br>* 自定义注解<br>	* 格式：<br>		元注解<br>		<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> 注解名称&#123;<br>			属性列表;<br>		&#125;<br><br>	* 本质：注解本质上就是一个接口，该接口默认继承Annotation接口<br>		* <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyAnno</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">annotation</span>.<span class="hljs-title">Annotation</span> </span>&#123;&#125;<br><br>	* 属性：接口中的抽象方法<br>		* 要求：<br>			<span class="hljs-number">1</span>. 属性的返回值类型有下列取值<br>				* 基本数据类型<br>				* String<br>				* 枚举<br>				* 注解<br>				* 以上类型的数组<br><br>			<span class="hljs-number">2</span>. 定义了属性，在使用时需要给属性赋值<br>				<span class="hljs-number">1</span>. 如果定义属性时，使用<span class="hljs-keyword">default</span>关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。<br>				<span class="hljs-number">2</span>. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。<br>				<span class="hljs-number">3</span>. 数组赋值时，值使用&#123;&#125;包裹。如果数组中只有一个值，则&#123;&#125;可以省略<br>	<br>	* 元注解：用于描述注解的注解<br>		* <span class="hljs-meta">@Target</span>：描述注解能够作用的位置<br>			* ElementType取值：<br>				* TYPE：可以作用于类上<br>				* METHOD：可以作用于方法上<br>				* FIELD：可以作用于成员变量上<br>		* <span class="hljs-meta">@Retention</span>：描述注解被保留的阶段<br>			* <span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到<span class="hljs-class"><span class="hljs-keyword">class</span>字节码文件中，并被<span class="hljs-title">JVM</span>读取到</span><br><span class="hljs-class">		* @<span class="hljs-title">Documented</span>：描述注解是否被抽取到<span class="hljs-title">api</span>文档中</span><br><span class="hljs-class">		* @<span class="hljs-title">Inherited</span>：描述注解是否被子类继承</span><br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* 在程序使用(解析)注解：获取注解中定义的属性值<br>	<span class="hljs-number">1</span>. 获取注解定义的位置的对象  （Class，Method,Field）<br>	<span class="hljs-number">2</span>. 获取指定的注解<br>		* getAnnotation(Class)<br>		<span class="hljs-comment">//其实就是在内存中生成了一个该注解接口的子类实现对象</span><br><br>	            <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Pro</span></span>&#123;<br>	                <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">className</span><span class="hljs-params">()</span></span>&#123;<br>	                    <span class="hljs-keyword">return</span> <span class="hljs-string">"cn.itcast.annotation.Demo1"</span>;<br>	                &#125;<br>	                <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">methodName</span><span class="hljs-params">()</span></span>&#123;<br>	                    <span class="hljs-keyword">return</span> <span class="hljs-string">"show"</span>;<br>	                &#125;<br>	            &#125;<br>	<span class="hljs-number">3</span>. 调用注解中的抽象方法获取配置的属性值<br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* 案例：简单的测试框架<br>* 小结：<br>	<span class="hljs-number">1</span>. 以后大多数时候，我们会使用注解，而不是自定义注解<br>	<span class="hljs-number">2</span>. 注解给谁用？<br>		<span class="hljs-number">1</span>. 编译器<br>		<span class="hljs-number">2</span>. 给解析程序用<br>	<span class="hljs-number">3</span>. 注解不是程序的一部分，可以理解为注解就是一个标签<br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>java网络编程</title>
    <url>/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>软件架构CS／BS</li>
<li>网络通信三要素</li>
<li>TCP通信</li>
<li>Socket套接字</li>
<li>ServerSocket</li>
<li><a id="more"></a>


</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够辨别UDP和TCP协议特点</li>
<li><input disabled="" type="checkbox"> 能够说出TCP协议下两个常用类名称</li>
<li><input disabled="" type="checkbox"> 能够编写TCP协议下字符串数据传输程序</li>
<li><input disabled="" type="checkbox"> 能够理解TCP协议下文件上传案例</li>
<li><input disabled="" type="checkbox"> 能够理解TCP协议下案例2</li>
</ul>
<h1 id="第一章-网络编程入门"><a href="#第一章-网络编程入门" class="headerlink" title="第一章 网络编程入门"></a>第一章 网络编程入门</h1><h2 id="1-1软件结构"><a href="#1-1软件结构" class="headerlink" title="1.1软件结构"></a>1.1软件结构</h2><ul>
<li><strong>C/S结构</strong> ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。</li>
</ul>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1_cs.jpg" class="" title="cs">

<p><strong>B/S结构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</p>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2_bs.jpg" class="" title="bs">

<p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p>
<h2 id="1-2-网络通信协议"><a href="#1-2-网络通信协议" class="headerlink" title="1.2 网络通信协议"></a>1.2 网络通信协议</h2><ul>
<li><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li>
</ul>
<ul>
<li><p><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</p>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/3_tcp_ip.jpg" class="" title="四层">

</li>
</ul>
<p>上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p>
<h2 id="1-3-协议分类"><a href="#1-3-协议分类" class="headerlink" title="1.3 协议分类"></a>1.3 协议分类</h2><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p>
<p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p>
<ul>
<li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP是<strong>无连接通信</strong>协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p>
<p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p>
<p>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。</p>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/UDP%E9%80%9A%E4%BF%A1%E5%9B%BE%E8%A7%A3.bmp" class="" title="udp">

</li>
</ul>
<p>特点:数据被限制在64kb以内，超出这个范围就不能发送了。</p>
<p>数据报(Datagram):网络传输的基本单位 </p>
<ul>
<li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p>
<p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p>
<ul>
<li><p>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。</p>
<ul>
<li><p>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</p>
</li>
<li><p>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</p>
</li>
<li><p>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。</p>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/4_tcp.jpg" class="" title="tcp">

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​    完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p>
<h2 id="1-4-网络编程三要素"><a href="#1-4-网络编程三要素" class="headerlink" title="1.4 网络编程三要素"></a>1.4 网络编程三要素</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li>
</ul>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul>
<li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</li>
</ul>
<p><strong>IP地址分类</strong></p>
<ul>
<li><p>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p>
</li>
<li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p>
<p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p>
</li>
</ul>
<p><strong>常用命令</strong></p>
<ul>
<li>查看本机IP地址，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ipconfig<br></code></pre></td></tr></table></figure>

<ul>
<li>检查网络是否连通，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ping 空格 IP地址<br>ping <span class="hljs-number">220.181</span><span class="hljs-number">.57</span><span class="hljs-number">.216</span><br></code></pre></td></tr></table></figure>

<p><strong>特殊的IP地址</strong></p>
<ul>
<li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li>
</ul>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p>
<p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p>
<ul>
<li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li>
</ul>
<p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p>
<h1 id="第二章-TCP通信程序"><a href="#第二章-TCP通信程序" class="headerlink" title="第二章 TCP通信程序"></a>第二章 TCP通信程序</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。</p>
<p><strong>两端通信时步骤：</strong></p>
<ol>
<li>服务端程序，需要事先启动，等待客户端的连接。</li>
<li>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。</li>
</ol>
<p><strong>在Java中，提供了两个类用于实现TCP通信程序：</strong></p>
<ol>
<li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li>
<li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li>
</ol>
<h2 id="2-2-Socket类"><a href="#2-2-Socket类" class="headerlink" title="2.2 Socket类"></a>2.2 Socket类</h2><p><code>Socket</code> 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><p><code>public Socket(String host, int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。  </p>
<blockquote>
<p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p>
</blockquote>
</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Socket client = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">6666</span>);<br></code></pre></td></tr></table></figure>

<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><p><code>public InputStream getInputStream()</code> ： 返回此套接字的输入流。</p>
<ul>
<li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li>
<li>关闭生成的InputStream也将关闭相关的Socket。</li>
</ul>
</li>
<li><p><code>public OutputStream getOutputStream()</code> ： 返回此套接字的输出流。</p>
<ul>
<li>如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li>
<li>关闭生成的OutputStream也将关闭相关的Socket。</li>
</ul>
</li>
<li><p><code>public void close()</code> ：关闭此套接字。</p>
<ul>
<li>一旦一个socket被关闭，它不可再使用。</li>
<li>关闭此socket也将关闭相关的InputStream和OutputStream 。 </li>
</ul>
</li>
<li><p><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。   </p>
<ul>
<li>任何先前写出的数据将被发送，随后终止输出流。 </li>
</ul>
<h2 id="2-3-ServerSocket类"><a href="#2-3-ServerSocket类" class="headerlink" title="2.3 ServerSocket类"></a>2.3 ServerSocket类</h2></li>
</ul>
<p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ServerSocket(int port)</code> ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br></code></pre></td></tr></table></figure>

<h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><code>public Socket accept()</code> ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 </li>
</ul>
<h2 id="2-4-简单的TCP网络程序"><a href="#2-4-简单的TCP网络程序" class="headerlink" title="2.4 简单的TCP网络程序"></a>2.4 简单的TCP网络程序</h2><h3 id="TCP通信分析图解"><a href="#TCP通信分析图解" class="headerlink" title="TCP通信分析图解"></a>TCP通信分析图解</h3><ol>
<li>【服务端】启动,创建ServerSocket对象，等待连接。</li>
<li>【客户端】启动,创建Socket对象，请求连接。</li>
<li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li>
<li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li>
<li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。</li>
</ol>
<blockquote>
<p>到此，客户端向服务端发送数据成功。</p>
</blockquote>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/5_%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%A1.jpg" class="" title="简单通信">

<blockquote>
<p>自此，服务端向客户端回写数据。</p>
</blockquote>
<ol start="6">
<li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li>
<li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li>
<li>【客户端】释放资源，断开连接。</li>
</ol>
<h3 id="客户端向服务器发送数据"><a href="#客户端向服务器发送数据" class="headerlink" title="客户端向服务器发送数据"></a>客户端向服务器发送数据</h3><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerTCP</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">"服务端启动 , 等待连接 .... "</span>);<br>        <span class="hljs-comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span><br>        ServerSocket ss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>        <span class="hljs-comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span><br>        Socket server = ss.accept();<br>        <span class="hljs-comment">// 3.通过socket 获取输入流</span><br>        InputStream is = server.getInputStream();<br>        <span class="hljs-comment">// 4.一次性读取数据</span><br>      	<span class="hljs-comment">// 4.1 创建字节数组</span><br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>      	<span class="hljs-comment">// 4.2 据读取到字节数组中.</span><br>        <span class="hljs-keyword">int</span> len = is.read(b)；<br>        <span class="hljs-comment">// 4.3 解析数组,打印字符串信息</span><br>        String msg = <span class="hljs-keyword">new</span> String(b, <span class="hljs-number">0</span>, len);<br>        System.out.println(msg);<br>        <span class="hljs-comment">//5.关闭资源.</span><br>        is.close();<br>        server.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientTCP</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>		System.out.println(<span class="hljs-string">"客户端 发送数据"</span>);<br>		<span class="hljs-comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span><br>		Socket client = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">6666</span>);<br>		<span class="hljs-comment">// 2.获取流对象 . 输出流</span><br>		OutputStream os = client.getOutputStream();<br>		<span class="hljs-comment">// 3.写出数据.</span><br>		os.write(<span class="hljs-string">"你好么? tcp ,我来了"</span>.getBytes());<br>		<span class="hljs-comment">// 4. 关闭资源 .</span><br>		os.close();<br>		client.close();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="服务器向客户端回写数据"><a href="#服务器向客户端回写数据" class="headerlink" title="服务器向客户端回写数据"></a>服务器向客户端回写数据</h3><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerTCP</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">"服务端启动 , 等待连接 .... "</span>);<br>        <span class="hljs-comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span><br>        ServerSocket ss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>        <span class="hljs-comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span><br>        Socket server = ss.accept();<br>        <span class="hljs-comment">// 3.通过socket 获取输入流</span><br>        InputStream is = server.getInputStream();<br>        <span class="hljs-comment">// 4.一次性读取数据</span><br>      	<span class="hljs-comment">// 4.1 创建字节数组</span><br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>      	<span class="hljs-comment">// 4.2 据读取到字节数组中.</span><br>        <span class="hljs-keyword">int</span> len = is.read(b)；<br>        <span class="hljs-comment">// 4.3 解析数组,打印字符串信息</span><br>        String msg = <span class="hljs-keyword">new</span> String(b, <span class="hljs-number">0</span>, len);<br>        System.out.println(msg);<br>      	<span class="hljs-comment">// =================回写数据=======================</span><br>      	<span class="hljs-comment">// 5. 通过 socket 获取输出流</span><br>      	 OutputStream out = server.getOutputStream();<br>      	<span class="hljs-comment">// 6. 回写数据</span><br>      	 out.write(<span class="hljs-string">"我很好,谢谢你"</span>.getBytes());<br>      	<span class="hljs-comment">// 7.关闭资源.</span><br>      	out.close();<br>        is.close();<br>        server.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientTCP</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>		System.out.println(<span class="hljs-string">"客户端 发送数据"</span>);<br>		<span class="hljs-comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span><br>		Socket client = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">6666</span>);<br>		<span class="hljs-comment">// 2.通过Scoket,获取输出流对象 </span><br>		OutputStream os = client.getOutputStream();<br>		<span class="hljs-comment">// 3.写出数据.</span><br>		os.write(<span class="hljs-string">"你好么? tcp ,我来了"</span>.getBytes());<br>      	<span class="hljs-comment">// ==============解析回写=========================</span><br>      	<span class="hljs-comment">// 4. 通过Scoket,获取 输入流对象</span><br>      	InputStream in = client.getInputStream();<br>      	<span class="hljs-comment">// 5. 读取数据数据</span><br>      	<span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">100</span>];<br>      	<span class="hljs-keyword">int</span> len = in.read(b);<br>      	System.out.println(<span class="hljs-keyword">new</span> String(b, <span class="hljs-number">0</span>, len));<br>		<span class="hljs-comment">// 6. 关闭资源 .</span><br>      	in.close();<br>		os.close();<br>		client.close();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件上传案例"><a href="#3-1-文件上传案例" class="headerlink" title="3.1 文件上传案例"></a>3.1 文件上传案例</h2><h3 id="文件上传分析图解"><a href="#文件上传分析图解" class="headerlink" title="文件上传分析图解"></a>文件上传分析图解</h3><ol>
<li>【客户端】输入流，从硬盘读取文件数据到程序中。</li>
<li>【客户端】输出流，写出文件数据到服务端。</li>
<li>【服务端】输入流，读取文件数据到服务端程序。</li>
<li>【服务端】输出流，写出文件数据到服务器硬盘中。</li>
</ol>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/6_upload.jpg" class="" title="案例分析">    

<h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUpload_Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">"服务器 启动.....  "</span>);<br>        <span class="hljs-comment">// 1. 创建服务端ServerSocket</span><br>      	ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>  		<span class="hljs-comment">// 2. 建立连接 </span><br>        Socket accept = serverSocket.accept();<br>      	<span class="hljs-comment">// 3. 创建流对象</span><br>      	<span class="hljs-comment">// 3.1 获取输入流,读取文件数据</span><br>        BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(accept.getInputStream());<br>        <span class="hljs-comment">// 3.2 创建输出流,保存到本地 .</span><br>        BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"copy.jpg"</span>));<br>		<span class="hljs-comment">// 4. 读写数据</span><br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span>];<br>        <span class="hljs-keyword">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = bis.read(b)) != -<span class="hljs-number">1</span>) &#123;<br>            bos.write(b, <span class="hljs-number">0</span>, len);<br>        &#125;<br>        <span class="hljs-comment">//5. 关闭 资源</span><br>        bos.close();<br>        bis.close();<br>        accept.close();<br>        System.out.println(<span class="hljs-string">"文件上传已保存"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUPload_Client</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 1.创建流对象</span><br>        <span class="hljs-comment">// 1.1 创建输入流,读取本地文件  </span><br>        BufferedInputStream bis  = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"test.jpg"</span>));<br>        <span class="hljs-comment">// 1.2 创建输出流,写到服务端 </span><br>        Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">6666</span>);<br>        BufferedOutputStream   bos   = <span class="hljs-keyword">new</span> BufferedOutputStream(socket.getOutputStream());<br><br>        <span class="hljs-comment">//2.写出数据. </span><br>        <span class="hljs-keyword">byte</span>[] b  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span> ];<br>        <span class="hljs-keyword">int</span> len ; <br>        <span class="hljs-keyword">while</span> (( len  = bis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>            bos.write(b, <span class="hljs-number">0</span>, len);<br>            bos.flush();<br>        &#125;<br>        System.out.println(<span class="hljs-string">"文件发送完毕"</span>);<br>        <span class="hljs-comment">// 3.释放资源</span><br><br>        bos.close(); <br>        socket.close();<br>        bis.close(); <br>        System.out.println(<span class="hljs-string">"文件上传完毕 "</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="文件上传优化分析"><a href="#文件上传优化分析" class="headerlink" title="文件上传优化分析"></a>文件上传优化分析</h3><ol>
<li><p><strong>文件名称写死的问题</strong></p>
<p>服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">FileOutputStream fis = <span class="hljs-keyword">new</span> FileOutputStream(System.currentTimeMillis()+<span class="hljs-string">".jpg"</span>) <span class="hljs-comment">// 文件名称</span><br>BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fis);<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>循环接收的问题</strong></p>
<p>服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 每次接收新的连接,创建一个Socket</span><br><span class="hljs-keyword">while</span>（<span class="hljs-keyword">true</span>）&#123;<br>    Socket accept = serverSocket.accept();<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>效率问题</strong></p>
<p>服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>（<span class="hljs-keyword">true</span>）&#123;<br>    Socket accept = serverSocket.accept();<br>    <span class="hljs-comment">// accept 交给子线程处理.</span><br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>      	......<br>        InputStream bis = accept.getInputStream();<br>      	......<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUpload_Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">"服务器 启动.....  "</span>);<br>        <span class="hljs-comment">// 1. 创建服务端ServerSocket</span><br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>      	<span class="hljs-comment">// 2. 循环接收,建立连接</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            Socket accept = serverSocket.accept();<br>          	<span class="hljs-comment">/* </span><br><span class="hljs-comment">          	3. socket对象交给子线程处理,进行读写操作</span><br><span class="hljs-comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> (<br>                    <span class="hljs-comment">//3.1 获取输入流对象</span><br>                    BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(accept.getInputStream());<br>                    <span class="hljs-comment">//3.2 创建输出流对象, 保存到本地 .</span><br>                    FileOutputStream fis = <span class="hljs-keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="hljs-string">".jpg"</span>);<br>                    BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fis);) &#123;<br>                    <span class="hljs-comment">// 3.3 读写数据</span><br>                    <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span>];<br>                    <span class="hljs-keyword">int</span> len;<br>                    <span class="hljs-keyword">while</span> ((len = bis.read(b)) != -<span class="hljs-number">1</span>) &#123;<br>                      bos.write(b, <span class="hljs-number">0</span>, len);<br>                    &#125;<br>                    <span class="hljs-comment">//4. 关闭 资源</span><br>                    bos.close();<br>                    bis.close();<br>                    accept.close();<br>                    System.out.println(<span class="hljs-string">"文件上传已保存"</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                  	e.printStackTrace();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="信息回写分析图解"><a href="#信息回写分析图解" class="headerlink" title="信息回写分析图解"></a>信息回写分析图解</h3><p>前四步与基本文件上传一致.</p>
<ol start="5">
<li>【服务端】获取输出流，回写数据。</li>
<li>【客户端】获取输入流，解析回写数据。</li>
</ol>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/6_upload2.jpg" class="" title="回写分析">    

<h4 id="回写实现"><a href="#回写实现" class="headerlink" title="回写实现"></a>回写实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUpload_Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">"服务器 启动.....  "</span>);<br>        <span class="hljs-comment">// 1. 创建服务端ServerSocket</span><br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>        <span class="hljs-comment">// 2. 循环接收,建立连接</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            Socket accept = serverSocket.accept();<br>          	<span class="hljs-comment">/*</span><br><span class="hljs-comment">          	3. socket对象交给子线程处理,进行读写操作</span><br><span class="hljs-comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> (<br>                    <span class="hljs-comment">//3.1 获取输入流对象</span><br>                    BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(accept.getInputStream());<br>                    <span class="hljs-comment">//3.2 创建输出流对象, 保存到本地 .</span><br>                    FileOutputStream fis = <span class="hljs-keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="hljs-string">".jpg"</span>);<br>                    BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fis);<br>                ) &#123;<br>                    <span class="hljs-comment">// 3.3 读写数据</span><br>                    <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span>];<br>                    <span class="hljs-keyword">int</span> len;<br>                    <span class="hljs-keyword">while</span> ((len = bis.read(b)) != -<span class="hljs-number">1</span>) &#123;<br>                        bos.write(b, <span class="hljs-number">0</span>, len);<br>                    &#125;<br><br>                    <span class="hljs-comment">// 4.=======信息回写===========================</span><br>                    System.out.println(<span class="hljs-string">"back ........"</span>);<br>                    OutputStream out = accept.getOutputStream();<br>                    out.write(<span class="hljs-string">"上传成功"</span>.getBytes());<br>                    out.close();<br>                    <span class="hljs-comment">//================================</span><br><br>                    <span class="hljs-comment">//5. 关闭 资源</span><br>                    bos.close();<br>                    bis.close();<br>                    accept.close();<br>                    System.out.println(<span class="hljs-string">"文件上传已保存"</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUpload_Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 1.创建流对象</span><br>        <span class="hljs-comment">// 1.1 创建输入流,读取本地文件</span><br>        BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"test.jpg"</span>));<br>        <span class="hljs-comment">// 1.2 创建输出流,写到服务端</span><br>        Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">6666</span>);<br>        BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(socket.getOutputStream());<br><br>        <span class="hljs-comment">//2.写出数据.</span><br>        <span class="hljs-keyword">byte</span>[] b  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span> ];<br>        <span class="hljs-keyword">int</span> len ;<br>        <span class="hljs-keyword">while</span> (( len  = bis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>            bos.write(b, <span class="hljs-number">0</span>, len);<br>        &#125;<br>      	<span class="hljs-comment">// 关闭输出流,通知服务端,写出数据完毕</span><br>        socket.shutdownOutput();<br>        System.out.println(<span class="hljs-string">"文件发送完毕"</span>);<br>        <span class="hljs-comment">// 3. =====解析回写============</span><br>        InputStream in = socket.getInputStream();<br>        <span class="hljs-keyword">byte</span>[] back = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">20</span>];<br>        in.read(back);<br>        System.out.println(<span class="hljs-keyword">new</span> String(back));<br>        in.close();<br>        <span class="hljs-comment">// ============================</span><br><br>        <span class="hljs-comment">// 4.释放资源</span><br>        socket.close();<br>        bis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/04_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%A1%88%E4%BE%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98.bmp" class="" title="堵塞分析">    

<h2 id="3-2-模拟B-S服务器-扩展知识点"><a href="#3-2-模拟B-S服务器-扩展知识点" class="headerlink" title="3.2 模拟B\S服务器(扩展知识点)"></a>3.2 模拟B\S服务器(扩展知识点)</h2><p>模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li><p>我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    	ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8000</span>);<br>    	Socket socket = server.accept();<br>    	InputStream in = socket.getInputStream();<br>   	    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>    	<span class="hljs-keyword">int</span> len = in.read(bytes);<br>    	System.out.println(<span class="hljs-keyword">new</span> String(bytes,<span class="hljs-number">0</span>,len));<br>    	socket.close();<br>    	server.close();<br>&#125;<br></code></pre></td></tr></table></figure>

{% asset_img 无法访问.jpg 无法访问 %}  
</li>
<li><p>服务器程序中字节输入流可以读取到浏览器发来的请求信息</p>
<p><img src="H:/%E5%8E%8B%E7%BC%A9%E5%8C%85/02-Java%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/02-Java%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/day11_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/img/%E8%AF%BB%E5%8F%96%E8%AE%BF%E9%97%AE%E4%BF%A1%E6%81%AF.jpg" alt=""></p>
</li>
</ol>
<p>GET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//转换流,读取浏览器请求第一行</span><br>BufferedReader readWb = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));<br>String requst = readWb.readLine();<br><span class="hljs-comment">//取出请求资源的路径</span><br>String[] strArr = requst.split(<span class="hljs-string">" "</span>);<br><span class="hljs-comment">//去掉web前面的/</span><br>String path = strArr[<span class="hljs-number">1</span>].substring(<span class="hljs-number">1</span>);<br>System.out.println(path);<br></code></pre></td></tr></table></figure>

<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>服务端实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">"服务端  启动 , 等待连接 .... "</span>);<br>        <span class="hljs-comment">// 创建ServerSocket 对象</span><br>        ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8888</span>);<br>        Socket socket = server.accept();<br>        <span class="hljs-comment">// 转换流读取浏览器的请求消息</span><br>        BufferedReader readWb = <span class="hljs-keyword">new</span><br>        BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));<br>        String requst = readWb.readLine();<br>        <span class="hljs-comment">// 取出请求资源的路径</span><br>        String[] strArr = requst.split(<span class="hljs-string">" "</span>);<br>        <span class="hljs-comment">// 去掉web前面的/</span><br>        String path = strArr[<span class="hljs-number">1</span>].substring(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 读取客户端请求的资源文件</span><br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(path);<br>        <span class="hljs-keyword">byte</span>[] bytes= <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span> ;<br>        <span class="hljs-comment">// 字节输出流,将文件写会客户端</span><br>        OutputStream out = socket.getOutputStream();<br>        <span class="hljs-comment">// 写入HTTP协议响应头,固定写法</span><br>        out.write(<span class="hljs-string">"HTTP/1.1 200 OK\r\n"</span>.getBytes());<br>        out.write(<span class="hljs-string">"Content-Type:text/html\r\n"</span>.getBytes());<br>        <span class="hljs-comment">// 必须要写入空行,否则浏览器不解析</span><br>        out.write(<span class="hljs-string">"\r\n"</span>.getBytes());<br>        <span class="hljs-keyword">while</span>((len = fis.read(bytes))!=-<span class="hljs-number">1</span>)&#123;<br>            out.write(bytes,<span class="hljs-number">0</span>,len);<br>        &#125;<br>        fis.close();<br>        out.close();<br>        readWb.close();	<br>        socket.close();<br>        server.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="访问效果"><a href="#访问效果" class="headerlink" title="访问效果"></a>访问效果</h3><ul>
<li><p><strong>火狐</strong></p>
{% asset_img 效果图1.png 无法访问 %}  

</li>
</ul>
<blockquote>
<p>小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。</p>
</blockquote>
<p>发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。</p>
<p>浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8888</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            Socket socket = server.accept();<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Web(socket)).start();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Web</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>        <span class="hljs-keyword">private</span> Socket socket;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Web</span><span class="hljs-params">(Socket socket)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.socket=socket;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-comment">//转换流,读取浏览器请求第一行</span><br>                BufferedReader readWb = <span class="hljs-keyword">new</span><br>                        BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));<br>                String requst = readWb.readLine();<br>                <span class="hljs-comment">//取出请求资源的路径</span><br>                String[] strArr = requst.split(<span class="hljs-string">" "</span>);<br>                System.out.println(Arrays.toString(strArr));<br>                String path = strArr[<span class="hljs-number">1</span>].substring(<span class="hljs-number">1</span>);<br>                System.out.println(path);<br><br>                FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(path);<br>                System.out.println(fis);<br>                <span class="hljs-keyword">byte</span>[] bytes= <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>                <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span> ;<br>                <span class="hljs-comment">//向浏览器 回写数据</span><br>                OutputStream out = socket.getOutputStream();<br>                out.write(<span class="hljs-string">"HTTP/1.1 200 OK\r\n"</span>.getBytes());<br>                out.write(<span class="hljs-string">"Content-Type:text/html\r\n"</span>.getBytes());<br>                out.write(<span class="hljs-string">"\r\n"</span>.getBytes());<br>                <span class="hljs-keyword">while</span>((len = fis.read(bytes))!=-<span class="hljs-number">1</span>)&#123;<br>                    out.write(bytes,<span class="hljs-number">0</span>,len);<br>                &#125;<br>                fis.close();<br>                out.close();<br>                readWb.close();<br>                socket.close();<br>            &#125;<span class="hljs-keyword">catch</span>(Exception ex)&#123;<br><br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>访问效果：</strong></p>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E6%95%88%E6%9E%9C%E5%9B%BE2.png" class="" title="无法访问">  

<p><img src="H:/%E5%8E%8B%E7%BC%A9%E5%8C%85/02-Java%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/02-Java%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/day11_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/img/%E6%95%88%E6%9E%9C%E5%9B%BE2.png" alt="">图解：</p>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/BS%E9%80%9A%E4%BF%A1.bmp" class="" title="bs分析"> ]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC连接池</title>
    <url>/2020/04/06/JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>1.数据库连接池</p>
<p>2.Spring JDBC : JDBC Template</p>
<a id="more"></a>

<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><img src="/2020/04/06/JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.bmp" class="" title="数据库连接池">

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>. 概念：其实就是一个容器(集合)，存放数据库连接的容器。<br>	当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。<br><br><span class="hljs-number">2</span>. 好处：<br>	<span class="hljs-number">1</span>. 节约资源<br>	<span class="hljs-number">2</span>. 用户访问高效<br><br><span class="hljs-number">3</span>. 实现：<br>	<span class="hljs-number">1</span>. 标准接口：DataSource   javax.sql包下的<br>		<span class="hljs-number">1</span>. 方法：<br>			* 获取连接：getConnection()<br>			* 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接<br><br>	<span class="hljs-number">2</span>. 一般我们不去实现它，有数据库厂商来实现<br>		<span class="hljs-number">1</span>. C3P0：数据库连接池技术<br>		<span class="hljs-number">2</span>. Druid：数据库连接池实现技术，由阿里巴巴提供的<br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">4</span>. C3P0：数据库连接池技术<br>	* 步骤：<br>		<span class="hljs-number">1</span>. 导入jar包 (两个) c3p0-<span class="hljs-number">0.9</span><span class="hljs-number">.5</span><span class="hljs-number">.2</span>.jar mchange-commons-java-<span class="hljs-number">0.2</span><span class="hljs-number">.12</span>.jar ，<br>			* 不要忘记导入数据库驱动jar包<br>		<span class="hljs-number">2</span>. 定义配置文件：<br>			* 名称： c3p0.properties 或者 c3p0-config.xml<br>			* 路径：直接将文件放在src目录下即可。<br><br>		<span class="hljs-number">3</span>. 创建核心对象 数据库连接池对象 ComboPooledDataSource<br>		<span class="hljs-number">4</span>. 获取连接： getConnection<br>	* 代码：<br>		 <span class="hljs-comment">//1.创建数据库连接池对象</span><br>        DataSource ds  = <span class="hljs-keyword">new</span> ComboPooledDataSource();<br>        <span class="hljs-comment">//2. 获取连接对象</span><br>        Connection conn = ds.getConnection();<br><span class="hljs-number">5</span>. Druid：数据库连接池实现技术，由阿里巴巴提供的<br>	<span class="hljs-number">1</span>. 步骤：<br>		<span class="hljs-number">1</span>. 导入jar包 druid-<span class="hljs-number">1.0</span><span class="hljs-number">.9</span>.jar<br>		<span class="hljs-number">2</span>. 定义配置文件：<br>			* 是properties形式的<br>			* 可以叫任意名称，可以放在任意目录下<br>		<span class="hljs-number">3</span>. 加载配置文件。Properties<br>		<span class="hljs-number">4</span>. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory<br>		<span class="hljs-number">5</span>. 获取连接：getConnection<br>	* 代码：<br>		 <span class="hljs-comment">//3.加载配置文件</span><br>        Properties pro = <span class="hljs-keyword">new</span> Properties();<br>        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream("druid.properties");<br>        pro.load(is);<br>        <span class="hljs-comment">//4.获取连接池对象</span><br>        DataSource ds = DruidDataSourceFactory.createDataSource(pro);<br>        <span class="hljs-comment">//5.获取连接</span><br>        Connection conn = ds.getConnection();<br>	<span class="hljs-number">2</span>. 定义工具类<br>		<span class="hljs-number">1</span>. 定义一个类 JDBCUtils<br>		<span class="hljs-number">2</span>. 提供静态代码块加载配置文件，初始化连接池对象<br>		<span class="hljs-number">3</span>. 提供方法<br>			<span class="hljs-number">1</span>. 获取连接方法：通过数据库连接池获取连接<br>			<span class="hljs-number">2</span>. 释放资源<br>			<span class="hljs-number">3</span>. 获取连接池的方法<br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* 代码：<br>	<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCUtils</span> </span>&#123;<br><br>	    <span class="hljs-comment">//1.定义成员变量 DataSource</span><br>	    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource ds ;<br>	<br>	    <span class="hljs-keyword">static</span>&#123;<br>	        <span class="hljs-keyword">try</span> &#123;<br>	            <span class="hljs-comment">//1.加载配置文件</span><br>	            Properties pro = <span class="hljs-keyword">new</span> Properties();<br>	                pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties"));<br>	            <span class="hljs-comment">//2.获取DataSource</span><br>	            ds = DruidDataSourceFactory.createDataSource(pro);<br>	        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>	            e.printStackTrace();<br>	        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>	            e.printStackTrace();<br>	        &#125;<br>	    &#125;<br>	<br>	    <span class="hljs-comment">/**</span><br><span class="hljs-comment">	     * 获取连接</span><br><span class="hljs-comment">	     */</span><br>	    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>	        <span class="hljs-keyword">return</span> ds.getConnection();<br>	    &#125;<br>	<br>	    <span class="hljs-comment">/**</span><br><span class="hljs-comment">	     * 释放资源</span><br><span class="hljs-comment">	     */</span><br>	    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Statement stmt,Connection conn)</span></span>&#123;<br>	       <span class="hljs-comment">/* if(stmt != null)&#123;</span><br><span class="hljs-comment">	            try &#123;</span><br><span class="hljs-comment">	                stmt.close();</span><br><span class="hljs-comment">	            &#125; catch (SQLException e) &#123;</span><br><span class="hljs-comment">	                e.printStackTrace();</span><br><span class="hljs-comment">	            &#125;</span><br><span class="hljs-comment">	        &#125;</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">	        if(conn != null)&#123;</span><br><span class="hljs-comment">	            try &#123;</span><br><span class="hljs-comment">	                conn.close();//归还连接</span><br><span class="hljs-comment">	            &#125; catch (SQLException e) &#123;</span><br><span class="hljs-comment">	                e.printStackTrace();</span><br><span class="hljs-comment">	            &#125;</span><br><span class="hljs-comment">	        &#125;*/</span><br>	<br>	       close(<span class="hljs-keyword">null</span>,stmt,conn);<br>	    &#125;<br></code></pre></td></tr></table></figure>


<p>​            </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(ResultSet rs , Statement stmt, Connection conn)</span></span>&#123;<br></code></pre></td></tr></table></figure>


<p>​            </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(rs != <span class="hljs-keyword">null</span>)&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        rs.close();<br>    &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>​            </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">        <span class="hljs-keyword">if</span>(stmt != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                stmt.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(conn != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn.close();<span class="hljs-comment">//归还连接</span><br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取连接池方法</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataSource <span class="hljs-title">getDataSource</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span>  ds;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发<br>* 步骤：<br>	<span class="hljs-number">1</span>. 导入jar包<br>	<span class="hljs-number">2</span>. 创建JdbcTemplate对象。依赖于数据源DataSource<br>		* JdbcTemplate template = <span class="hljs-keyword">new</span> JdbcTemplate(ds);<br><br>	<span class="hljs-number">3</span>. 调用JdbcTemplate的方法来完成CRUD的操作<br>		* update():执行DML语句。增、删、改语句<br>		* queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合<br>			* 注意：这个方法查询的结果集长度只能是<span class="hljs-number">1</span><br>		* queryForList():查询结果将结果集封装为list集合<br>			* 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中<br>		* query():查询结果，将结果封装为JavaBean对象<br>			* query的参数：RowMapper<br>				* 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装<br>				* <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;类型&gt;(类型<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><br><span class="hljs-class">		* <span class="hljs-title">queryForObject</span>：查询结果，将结果封装为对象</span><br><span class="hljs-class">			* 一般用于聚合函数的查询</span><br><span class="hljs-class"></span><br><span class="hljs-class">	4. 练习：</span><br><span class="hljs-class">		* 需求：</span><br><span class="hljs-class">			1. 修改1号数据的 <span class="hljs-title">salary</span> 为 10000</span><br><span class="hljs-class">			2. 添加一条记录</span><br><span class="hljs-class">			3. 删除刚才添加的记录</span><br><span class="hljs-class">			4. 查询<span class="hljs-title">id</span>为1的记录，将其封装为<span class="hljs-title">Map</span>集合</span><br><span class="hljs-class">			5. 查询所有记录，将其封装为<span class="hljs-title">List</span></span><br><span class="hljs-class">			6. 查询所有记录，将其封装为<span class="hljs-title">Emp</span>对象的<span class="hljs-title">List</span>集合</span><br><span class="hljs-class">			7. 查询总记录数</span><br><span class="hljs-class"></span><br><span class="hljs-class">		* 代码：</span><br><span class="hljs-class">			</span><br><span class="hljs-class">			<span class="hljs-title">import</span> <span class="hljs-title">cn</span>.<span class="hljs-title">itcast</span>.<span class="hljs-title">domain</span>.<span class="hljs-title">Emp</span></span>;<br>			<span class="hljs-keyword">import</span> cn.itcast.utils.JDBCUtils;<br>			<span class="hljs-keyword">import</span> org.junit.Test;<br>			<span class="hljs-keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;<br>			<span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<br>			<span class="hljs-keyword">import</span> org.springframework.jdbc.core.RowMapper;<br>			<br>			<span class="hljs-keyword">import</span> java.sql.Date;<br>			<span class="hljs-keyword">import</span> java.sql.ResultSet;<br>			<span class="hljs-keyword">import</span> java.sql.SQLException;<br>			<span class="hljs-keyword">import</span> java.util.List;<br>			<span class="hljs-keyword">import</span> java.util.Map;<br>			<br>			<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcTemplateDemo2</span> </span>&#123;<br>			<br>			    <span class="hljs-comment">//Junit单元测试，可以让方法独立执行</span><br></code></pre></td></tr></table></figure>


<p>​                </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 获取JDBCTemplate对象</span><br><span class="hljs-keyword">private</span> JdbcTemplate template = <span class="hljs-keyword">new</span>  JdbcTemplate(JDBCUtils.getDataSource());<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1. 修改1号数据的 salary 为 10000</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>			<br>    <span class="hljs-comment">//2. 定义sql</span><br>    String sql = <span class="hljs-string">"update emp set salary = 10000 where id = 1001"</span>;<br>    <span class="hljs-comment">//3. 执行sql</span><br>    <span class="hljs-keyword">int</span> count = template.update(sql);<br>    System.out.println(count);<br>&#125;<br>			<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 2. 添加一条记录</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>    String sql = <span class="hljs-string">"insert into emp(id,ename,dept_id) values(?,?,?)"</span>;<br>    <span class="hljs-keyword">int</span> count = template.update(sql, <span class="hljs-number">1015</span>, <span class="hljs-string">"郭靖"</span>, <span class="hljs-number">10</span>);<br>    System.out.println(count);<br>			<br>&#125;<br>			<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 3.删除刚才添加的记录</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;<br>    String sql = <span class="hljs-string">"delete from emp where id = ?"</span>;<br>    <span class="hljs-keyword">int</span> count = template.update(sql, <span class="hljs-number">1015</span>);<br>    System.out.println(count);<br>&#125;<br>			<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 4.查询id为1001的记录，将其封装为Map集合</span><br><span class="hljs-comment"> * 注意：这个方法查询的结果集长度只能是1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span>&#123;<br>    String sql = <span class="hljs-string">"select * from emp where id = ? or id = ?"</span>;<br>    Map&lt;String, Object&gt; map = template.queryForMap(sql, <span class="hljs-number">1001</span>,<span class="hljs-number">1002</span>);<br>    System.out.println(map);<br>    <span class="hljs-comment">//&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;</span><br>			<br>&#125;<br>			<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 5. 查询所有记录，将其封装为List</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span>&#123;<br>    String sql = <span class="hljs-string">"select * from emp"</span>;<br>    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);<br>			<br>    <span class="hljs-keyword">for</span> (Map&lt;String, Object&gt; stringObjectMap : list) &#123;<br>        System.out.println(stringObjectMap);<br>    &#125;<br>&#125;<br>			<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 6. 查询所有记录，将其封装为Emp对象的List集合</span><br><span class="hljs-comment"> */</span><br>			<br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span></span>&#123;<br>    String sql = <span class="hljs-string">"select * from emp"</span>;<br>    List&lt;Emp&gt; list = template.query(sql, <span class="hljs-keyword">new</span> RowMapper&lt;Emp&gt;() &#123;<br>			<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Emp <span class="hljs-title">mapRow</span><span class="hljs-params">(ResultSet rs, <span class="hljs-keyword">int</span> i)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>            Emp emp = <span class="hljs-keyword">new</span> Emp();<br>            <span class="hljs-keyword">int</span> id = rs.getInt(<span class="hljs-string">"id"</span>);<br>            String ename = rs.getString(<span class="hljs-string">"ename"</span>);<br>            <span class="hljs-keyword">int</span> job_id = rs.getInt(<span class="hljs-string">"job_id"</span>);<br>            <span class="hljs-keyword">int</span> mgr = rs.getInt(<span class="hljs-string">"mgr"</span>);<br>            Date joindate = rs.getDate(<span class="hljs-string">"joindate"</span>);<br>            <span class="hljs-keyword">double</span> salary = rs.getDouble(<span class="hljs-string">"salary"</span>);<br>            <span class="hljs-keyword">double</span> bonus = rs.getDouble(<span class="hljs-string">"bonus"</span>);<br>            <span class="hljs-keyword">int</span> dept_id = rs.getInt(<span class="hljs-string">"dept_id"</span>);<br>			<br>            emp.setId(id);<br>            emp.setEname(ename);<br>            emp.setJob_id(job_id);<br>            emp.setMgr(mgr);<br>            emp.setJoindate(joindate);<br>            emp.setSalary(salary);<br>            emp.setBonus(bonus);<br>            emp.setDept_id(dept_id);<br>			<br>            <span class="hljs-keyword">return</span> emp;<br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure>


<p>​                </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">        <span class="hljs-keyword">for</span> (Emp emp : list) &#123;<br>            System.out.println(emp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6_2</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">"select * from emp"</span>;<br>        List&lt;Emp&gt; list = template.query(sql, <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;Emp&gt;(Emp<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;<br>        <span class="hljs-keyword">for</span> (Emp emp : list) &#123;<br>            System.out.println(emp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 7. 查询总记录数</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">"select count(id) from emp"</span>;<br>        Long total = template.queryForObject(sql, Long<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>        System.out.println(total);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC基础</title>
    <url>/2020/04/04/JDBC%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><ol>
<li>JDBC基本概念</li>
<li>快速入门</li>
<li>对JDBC中各个接口和类详解</li>
</ol>
<a id="more"></a>

<h2 id="JDBC："><a href="#JDBC：" class="headerlink" title="JDBC："></a>JDBC：</h2><img src="/2020/04/04/JDBC%E5%9F%BA%E7%A1%80/JDBC%E6%9C%AC%E8%B4%A8.bmp" class="" title="JDBC本质">

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>. 概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库<br>	* JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。<br><br><span class="hljs-number">2</span>. 快速入门：<br>	* 步骤：<br>		<span class="hljs-number">1</span>. 导入驱动jar包 mysql-connector-java-<span class="hljs-number">5.1</span><span class="hljs-number">.37</span>-bin.jar<br>			<span class="hljs-number">1</span>.复制mysql-connector-java-<span class="hljs-number">5.1</span><span class="hljs-number">.37</span>-bin.jar到项目的libs目录下<br>			<span class="hljs-number">2</span>.右键--&gt;Add As Library<br>		<span class="hljs-number">2</span>. 注册驱动<br>		<span class="hljs-number">3</span>. 获取数据库连接对象 Connection<br>		<span class="hljs-number">4</span>. 定义sql<br>		<span class="hljs-number">5</span>. 获取执行sql语句的对象 Statement<br>		<span class="hljs-number">6</span>. 执行sql，接受返回结果<br>		<span class="hljs-number">7</span>. 处理结果<br>		<span class="hljs-number">8</span>. 释放资源<br><br>	* 代码实现：<br>	  	<span class="hljs-comment">//1. 导入驱动jar包</span><br>        <span class="hljs-comment">//2.注册驱动</span><br>        Class.forName(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);<br>        <span class="hljs-comment">//3.获取数据库连接对象</span><br>        Connection conn = DriverManager.getConnection(<span class="hljs-string">"jdbc:mysql://localhost:3306/db3"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"root"</span>);<br>        <span class="hljs-comment">//4.定义sql语句</span><br>        String sql = <span class="hljs-string">"update account set balance = 500 where id = 1"</span>;<br>        <span class="hljs-comment">//5.获取执行sql的对象 Statement</span><br>        Statement stmt = conn.createStatement();<br>        <span class="hljs-comment">//6.执行sql</span><br>        <span class="hljs-keyword">int</span> count = stmt.executeUpdate(sql);<br>        <span class="hljs-comment">//7.处理结果</span><br>        System.out.println(count);<br>        <span class="hljs-comment">//8.释放资源</span><br>        stmt.close();<br>        conn.close();<br><br><span class="hljs-number">3</span>. 详解各个对象：<br>	<span class="hljs-number">1</span>. DriverManager：驱动管理对象<br>		* 功能：<br>			<span class="hljs-number">1</span>. 注册驱动：告诉程序该使用哪一个数据库驱动jar<br>				<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerDriver</span><span class="hljs-params">(Driver driver)</span> :注册与给定的驱动程序 DriverManager 。 </span><br><span class="hljs-function">				写代码使用：  Class.<span class="hljs-title">forName</span><span class="hljs-params">(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>)</span></span>;<br>				通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块<br>				 <span class="hljs-keyword">static</span> &#123;<br>				        <span class="hljs-keyword">try</span> &#123;<br>				            java.sql.DriverManager.registerDriver(<span class="hljs-keyword">new</span> Driver());<br>				        &#125; <span class="hljs-keyword">catch</span> (SQLException E) &#123;<br>				            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Can't register driver!"</span>);<br>				        &#125;<br>					&#125;<br><br>				注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。<br>			<span class="hljs-number">2</span>. 获取数据库连接：<br>				* 方法：<span class="hljs-function"><span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(String url, String user, String password)</span> </span><br><span class="hljs-function">				* 参数：</span><br><span class="hljs-function">					* url：指定连接的路径</span><br><span class="hljs-function">						* 语法：jdbc:mysql:<span class="hljs-comment">//ip地址(域名):端口号/数据库名称</span></span><br><span class="hljs-function">						* 例子：jdbc:mysql:<span class="hljs-comment">//localhost:3306/db3</span></span><br><span class="hljs-function">						* 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:<span class="hljs-comment">///数据库名称</span></span><br><span class="hljs-function">					* user：用户名</span><br><span class="hljs-function">					* password：密码 </span><br><span class="hljs-function">	2. Connection：数据库连接对象</span><br><span class="hljs-function">		1. 功能：</span><br><span class="hljs-function">			1. 获取执行sql 的对象</span><br><span class="hljs-function">				* Statement <span class="hljs-title">createStatement</span><span class="hljs-params">()</span></span><br><span class="hljs-function">				* PreparedStatement <span class="hljs-title">prepareStatement</span><span class="hljs-params">(String sql)</span>  </span><br><span class="hljs-function">			2. 管理事务：</span><br><span class="hljs-function">				* 开启事务：<span class="hljs-title">setAutoCommit</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> autoCommit)</span> ：调用该方法设置参数为<span class="hljs-keyword">false</span>，即开启事务</span><br><span class="hljs-function">				* 提交事务：<span class="hljs-title">commit</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">				* 回滚事务：<span class="hljs-title">rollback</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">	3. Statement：执行sql的对象</span><br><span class="hljs-function">		1. 执行sql</span><br><span class="hljs-function">			1. <span class="hljs-keyword">boolean</span> <span class="hljs-title">execute</span><span class="hljs-params">(String sql)</span> ：可以执行任意的sql 了解 </span><br><span class="hljs-function">			2. <span class="hljs-keyword">int</span> <span class="hljs-title">executeUpdate</span><span class="hljs-params">(String sql)</span> ：执行DML（insert、update、delete）语句、<span class="hljs-title">DDL</span><span class="hljs-params">(create，alter、drop)</span>语句</span><br><span class="hljs-function">				* 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。</span><br><span class="hljs-function">			3. ResultSet <span class="hljs-title">executeQuery</span><span class="hljs-params">(String sql)</span>  ：执行DQL（select)语句</span><br><span class="hljs-function">		2. 练习：</span><br><span class="hljs-function">			1. account表 添加一条记录</span><br><span class="hljs-function">			2. account表 修改记录</span><br><span class="hljs-function">			3. account表 删除一条记录</span><br><span class="hljs-function"></span><br><span class="hljs-function">			代码：</span><br><span class="hljs-function">				Statement stmt </span>= <span class="hljs-keyword">null</span>;<br>		        Connection conn = <span class="hljs-keyword">null</span>;<br>		        <span class="hljs-keyword">try</span> &#123;<br>		            <span class="hljs-comment">//1. 注册驱动</span><br>		            Class.forName(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);<br>		            <span class="hljs-comment">//2. 定义sql</span><br>		            String sql = <span class="hljs-string">"insert into account values(null,'王五',3000)"</span>;<br>		            <span class="hljs-comment">//3.获取Connection对象</span><br>		            conn = DriverManager.getConnection(<span class="hljs-string">"jdbc:mysql:///db3"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"root"</span>);<br>		            <span class="hljs-comment">//4.获取执行sql的对象 Statement</span><br>		            stmt = conn.createStatement();<br>		            <span class="hljs-comment">//5.执行sql</span><br>		            <span class="hljs-keyword">int</span> count = stmt.executeUpdate(sql);<span class="hljs-comment">//影响的行数</span><br>		            <span class="hljs-comment">//6.处理结果</span><br>		            System.out.println(count);<br>		            <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>)&#123;<br>		                System.out.println(<span class="hljs-string">"添加成功！"</span>);<br>		            &#125;<span class="hljs-keyword">else</span>&#123;<br>		                System.out.println(<span class="hljs-string">"添加失败！"</span>);<br>		            &#125;<br>		<br>		        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>		            e.printStackTrace();<br>		        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>		            e.printStackTrace();<br>		        &#125;<span class="hljs-keyword">finally</span> &#123;<br>		            <span class="hljs-comment">//stmt.close();</span><br>		            <span class="hljs-comment">//7. 释放资源</span><br>		            <span class="hljs-comment">//避免空指针异常</span><br>		            <span class="hljs-keyword">if</span>(stmt != <span class="hljs-keyword">null</span>)&#123;<br>		                <span class="hljs-keyword">try</span> &#123;<br>		                    stmt.close();<br>		                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>		                    e.printStackTrace();<br>		                &#125;<br>		            &#125;<br>		<br>		            <span class="hljs-keyword">if</span>(conn != <span class="hljs-keyword">null</span>)&#123;<br>		                <span class="hljs-keyword">try</span> &#123;<br>		                    conn.close();<br>		                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>		                    e.printStackTrace();<br>		                &#125;<br>		            &#125;<br>		        &#125;<br>			<br>	<span class="hljs-number">4</span>. ResultSet：结果集对象,封装查询结果<br>		* <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">next</span><span class="hljs-params">()</span>: 游标向下移动一行，判断当前行是否是最后一行末尾<span class="hljs-params">(是否有数据)</span>，如果是，则返回<span class="hljs-keyword">false</span>，如果不是则返回<span class="hljs-keyword">true</span></span><br><span class="hljs-function">		* <span class="hljs-title">getXxx</span><span class="hljs-params">(参数)</span>:获取数据</span><br><span class="hljs-function">			* Xxx：代表数据类型   如： <span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span> ,	String <span class="hljs-title">getString</span><span class="hljs-params">()</span></span><br><span class="hljs-function">			* 参数：</span><br><span class="hljs-function">				1. <span class="hljs-keyword">int</span>：代表列的编号,从1开始   如： <span class="hljs-title">getString</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function">				2. String：代表列名称。 如： <span class="hljs-title">getDouble</span><span class="hljs-params">(<span class="hljs-string">"balance"</span>)</span></span><br><span class="hljs-function">		</span><br><span class="hljs-function">		* 注意：</span><br><span class="hljs-function">			* 使用步骤：</span><br><span class="hljs-function">				1. 游标向下移动一行</span><br><span class="hljs-function">				2. 判断是否有数据</span><br><span class="hljs-function">				3. 获取数据</span><br><span class="hljs-function"></span><br><span class="hljs-function">			   <span class="hljs-comment">//循环判断游标是否是最后一行末尾。</span></span><br><span class="hljs-function">	            <span class="hljs-title">while</span><span class="hljs-params">(rs.next()</span>)</span>&#123;<br>	                <span class="hljs-comment">//获取数据</span><br>	                <span class="hljs-comment">//6.2 获取数据</span><br>	                <span class="hljs-keyword">int</span> id = rs.getInt(<span class="hljs-number">1</span>);<br>	                String name = rs.getString(<span class="hljs-string">"name"</span>);<br>	                <span class="hljs-keyword">double</span> balance = rs.getDouble(<span class="hljs-number">3</span>);<br>	<br>	                System.out.println(id + <span class="hljs-string">"---"</span> + name + <span class="hljs-string">"---"</span> + balance);<br>	            &#125;<br><br>		* 练习：<br>			* 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。<br>				<span class="hljs-number">1</span>. 定义Emp类<br>				<span class="hljs-number">2</span>. 定义方法 <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Emp&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>&#123;&#125;<br>				<span class="hljs-number">3</span>. 实现方法 select * from emp;<br>					<br>	<span class="hljs-number">5</span>. PreparedStatement：执行sql的对象<br>		<span class="hljs-number">1</span>. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题<br>			<span class="hljs-number">1</span>. 输入用户随便，输入密码：a<span class="hljs-string">' or '</span>a<span class="hljs-string">' = '</span>a<br>			<span class="hljs-number">2</span>. sql：select * from user where username = <span class="hljs-string">'fhdsjkf'</span> and password = <span class="hljs-string">'a'</span> or <span class="hljs-string">'a'</span> = <span class="hljs-string">'a'</span> <br><br>		<span class="hljs-number">2</span>. 解决sql注入问题：使用PreparedStatement对象来解决<br>		<span class="hljs-number">3</span>. 预编译的SQL：参数使用?作为占位符<br>		<span class="hljs-number">4</span>. 步骤：<br>			<span class="hljs-number">1</span>. 导入驱动jar包 mysql-connector-java-<span class="hljs-number">5.1</span><span class="hljs-number">.37</span>-bin.jar<br>			<span class="hljs-number">2</span>. 注册驱动<br>			<span class="hljs-number">3</span>. 获取数据库连接对象 Connection<br>			<span class="hljs-number">4</span>. 定义sql<br>				* 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;<br>			<span class="hljs-number">5</span>. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql) <br>			<span class="hljs-number">6</span>. 给？赋值：<br>				* 方法： setXxx(参数<span class="hljs-number">1</span>,参数<span class="hljs-number">2</span>)<br>					* 参数<span class="hljs-number">1</span>：？的位置编号 从<span class="hljs-number">1</span> 开始<br>					* 参数<span class="hljs-number">2</span>：？的值<br>			<span class="hljs-number">7</span>. 执行sql，接受返回结果，不需要传递sql语句<br>			<span class="hljs-number">8</span>. 处理结果<br>			<span class="hljs-number">9</span>. 释放资源<br><br>		<span class="hljs-number">5</span>. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作<br>			<span class="hljs-number">1</span>. 可以防止SQL注入<br>			<span class="hljs-number">2</span>. 效率更高<br></code></pre></td></tr></table></figure>

<h2 id="抽取JDBC工具类-：-JDBCUtils"><a href="#抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="抽取JDBC工具类 ： JDBCUtils"></a>抽取JDBC工具类 ： JDBCUtils</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">* 目的：简化书写<br>* 分析：<br>	<span class="hljs-number">1</span>. 注册驱动也抽取<br>	<span class="hljs-number">2</span>. 抽取一个方法获取连接对象<br>		* 需求：不想传递参数（麻烦），还得保证工具类的通用性。<br>		* 解决：配置文件<br>			jdbc.properties<br>				url=<br>				user=<br>				password=<br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">	<span class="hljs-number">3</span>. 抽取一个方法释放资源<br><br>* 代码实现：<br>	<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCUtils</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String url;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String user;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String password;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String driver;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-comment">//读取资源文件，获取值。</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1. 创建Properties集合类。</span><br>            Properties pro = <span class="hljs-keyword">new</span> Properties();<br><br>            <span class="hljs-comment">//获取src路径下的文件的方式---&gt;ClassLoader 类加载器</span><br>            ClassLoader classLoader = JDBCUtils<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>()</span>;<br>            URL res  = classLoader.getResource(<span class="hljs-string">"jdbc.properties"</span>);<br>            String path = res.getPath();<br>            System.out.println(path);<span class="hljs-comment">///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties</span><br>            <span class="hljs-comment">//2. 加载文件</span><br>           <span class="hljs-comment">// pro.load(new FileReader("D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties"));</span><br>            pro.load(<span class="hljs-keyword">new</span> FileReader(path));<br><br>            <span class="hljs-comment">//3. 获取数据，赋值</span><br>            url = pro.getProperty(<span class="hljs-string">"url"</span>);<br>            user = pro.getProperty(<span class="hljs-string">"user"</span>);<br>            password = pro.getProperty(<span class="hljs-string">"password"</span>);<br>            driver = pro.getProperty(<span class="hljs-string">"driver"</span>);<br>            <span class="hljs-comment">//4. 注册驱动</span><br>            Class.forName(driver);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>


<p>​    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取连接</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 连接对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br><br>    <span class="hljs-keyword">return</span> DriverManager.getConnection(url, user, password);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放资源</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> stmt</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> conn</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Statement stmt,Connection conn)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>( stmt != <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            stmt.close();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( conn != <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            conn.close();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>​    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放资源</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> stmt</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> conn</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(ResultSet rs,Statement stmt, Connection conn)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>( rs != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                rs.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>( stmt != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                stmt.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>( conn != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br>* 练习：<br>	* 需求：<br>		<span class="hljs-number">1</span>. 通过键盘录入用户名和密码<br>		<span class="hljs-number">2</span>. 判断用户是否登录成功<br>			* select * from user where username = <span class="hljs-string">""</span> and password = <span class="hljs-string">""</span>;<br>			* 如果这个sql有查询结果，则成功，反之，则失败<br><br>	* 步骤：<br>		<span class="hljs-number">1</span>. 创建数据库表 user<br>			<span class="hljs-function">CREATE TABLE <span class="hljs-title">USER</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">				id INT PRIMARY KEY AUTO_INCREMENT,</span></span><br><span class="hljs-function"><span class="hljs-params">				username VARCHAR(<span class="hljs-number">32</span>)</span>,</span><br><span class="hljs-function">				PASSWORD <span class="hljs-title">VARCHAR</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span></span><br><span class="hljs-function">			</span><br><span class="hljs-function">			)</span>;<br><br>			<span class="hljs-function">INSERT INTO USER <span class="hljs-title">VALUES</span><span class="hljs-params">(NULL,<span class="hljs-string">'zhangsan'</span>,<span class="hljs-string">'123'</span>)</span></span>;<br>			<span class="hljs-function">INSERT INTO USER <span class="hljs-title">VALUES</span><span class="hljs-params">(NULL,<span class="hljs-string">'lisi'</span>,<span class="hljs-string">'234'</span>)</span></span>;<br><br>		<span class="hljs-number">2</span>. 代码实现：<br>			<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCDemo9</span> </span>&#123;<br><br>			    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>			        <span class="hljs-comment">//1.键盘录入，接受用户名和密码</span><br>			        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>			        System.out.println(<span class="hljs-string">"请输入用户名："</span>);<br>			        String username = sc.nextLine();<br>			        System.out.println(<span class="hljs-string">"请输入密码："</span>);<br>			        String password = sc.nextLine();<br>			        <span class="hljs-comment">//2.调用方法</span><br>			        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">new</span> JDBCDemo9().login(username, password);<br>			        <span class="hljs-comment">//3.判断结果，输出不同语句</span><br>			        <span class="hljs-keyword">if</span>(flag)&#123;<br>			            <span class="hljs-comment">//登录成功</span><br>			            System.out.println(<span class="hljs-string">"登录成功！"</span>);<br>			        &#125;<span class="hljs-keyword">else</span>&#123;<br>			            System.out.println(<span class="hljs-string">"用户名或密码错误！"</span>);<br>			        &#125;<br></code></pre></td></tr></table></figure>


<p>​                </p>
<pre><code>}</code></pre><p>​<br>​                </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 登录方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String username ,String password)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(username == <span class="hljs-keyword">null</span> || password == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//连接数据库判断是否登录成功</span><br>    Connection conn = <span class="hljs-keyword">null</span>;<br>    Statement stmt =  <span class="hljs-keyword">null</span>;<br>    ResultSet rs = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//1.获取连接</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        conn =  JDBCUtils.getConnection();<br>        <span class="hljs-comment">//2.定义sql</span><br>        String sql = <span class="hljs-string">"select * from user where username = '"</span>+username+<span class="hljs-string">"' and password = '"</span>+password+<span class="hljs-string">"' "</span>;<br>        <span class="hljs-comment">//3.获取执行sql的对象</span><br>        stmt = conn.createStatement();<br>        <span class="hljs-comment">//4.执行查询</span><br>        rs = stmt.executeQuery(sql);<br>        <span class="hljs-comment">//5.判断</span><br>       <span class="hljs-comment">/* if(rs.next())&#123;//如果有下一行，则返回true</span><br><span class="hljs-comment">            return true;</span><br><span class="hljs-comment">        &#125;else&#123;</span><br><span class="hljs-comment">            return false;</span><br><span class="hljs-comment">        &#125;*/</span><br>       <span class="hljs-keyword">return</span> rs.next();<span class="hljs-comment">//如果有下一行，则返回true</span><br>			<br>    &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>        e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        JDBCUtils.close(rs,stmt,conn);<br>    &#125;<br></code></pre></td></tr></table></figure>


<p>​                </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。<br><span class="hljs-number">2</span>. 操作：<br>	<span class="hljs-number">1</span>. 开启事务<br>	<span class="hljs-number">2</span>. 提交事务<br>	<span class="hljs-number">3</span>. 回滚事务<br><span class="hljs-number">3</span>. 使用Connection对象来管理事务<br>	* 开启事务：setAutoCommit(<span class="hljs-keyword">boolean</span> autoCommit) ：调用该方法设置参数为<span class="hljs-keyword">false</span>，即开启事务<br>		* 在执行sql之前开启事务<br>	* 提交事务：commit() <br>		* 当所有sql都执行完提交事务<br>	* 回滚事务：rollback() <br>		* 在<span class="hljs-keyword">catch</span>中回滚事务<br><br><span class="hljs-number">4</span>. 代码：<br>	<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCDemo10</span> </span>&#123;<br><br>	    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	        Connection conn = <span class="hljs-keyword">null</span>;<br>	        PreparedStatement pstmt1 = <span class="hljs-keyword">null</span>;<br>	        PreparedStatement pstmt2 = <span class="hljs-keyword">null</span>;<br>	<br>	        <span class="hljs-keyword">try</span> &#123;<br>	            <span class="hljs-comment">//1.获取连接</span><br>	            conn = JDBCUtils.getConnection();<br>	            <span class="hljs-comment">//开启事务</span><br>	            conn.setAutoCommit(<span class="hljs-keyword">false</span>);<br>	<br>	            <span class="hljs-comment">//2.定义sql</span><br>	            <span class="hljs-comment">//2.1 张三 - 500</span><br>	            String sql1 = <span class="hljs-string">"update account set balance = balance - ? where id = ?"</span>;<br>	            <span class="hljs-comment">//2.2 李四 + 500</span><br>	            String sql2 = <span class="hljs-string">"update account set balance = balance + ? where id = ?"</span>;<br>	            <span class="hljs-comment">//3.获取执行sql对象</span><br>	            pstmt1 = conn.prepareStatement(sql1);<br>	            pstmt2 = conn.prepareStatement(sql2);<br>	            <span class="hljs-comment">//4. 设置参数</span><br>	            pstmt1.setDouble(<span class="hljs-number">1</span>,<span class="hljs-number">500</span>);<br>	            pstmt1.setInt(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br>	<br>	            pstmt2.setDouble(<span class="hljs-number">1</span>,<span class="hljs-number">500</span>);<br>	            pstmt2.setInt(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br>	            <span class="hljs-comment">//5.执行sql</span><br>	            pstmt1.executeUpdate();<br>	            <span class="hljs-comment">// 手动制造异常</span><br>	            <span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>/<span class="hljs-number">0</span>;<br>	<br>	            pstmt2.executeUpdate();<br>	            <span class="hljs-comment">//提交事务</span><br>	            conn.commit();<br>	        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>	            <span class="hljs-comment">//事务回滚</span><br>	            <span class="hljs-keyword">try</span> &#123;<br>	                <span class="hljs-keyword">if</span>(conn != <span class="hljs-keyword">null</span>) &#123;<br>	                    conn.rollback();<br>	                &#125;<br>	            &#125; <span class="hljs-keyword">catch</span> (SQLException e1) &#123;<br>	                e1.printStackTrace();<br>	            &#125;<br>	            e.printStackTrace();<br>	        &#125;<span class="hljs-keyword">finally</span> &#123;<br>	            JDBCUtils.close(pstmt1,conn);<br>	            JDBCUtils.close(pstmt2,<span class="hljs-keyword">null</span>);<br>	        &#125;<br></code></pre></td></tr></table></figure>


<p>​        </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>


<p>​            </p>
]]></content>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>day03-List,Set</title>
    <url>/2020/04/04/day03-List-Set/</url>
    <content><![CDATA[<h1 id="day03-【List、Set、数据结构、Collections】"><a href="#day03-【List、Set、数据结构、Collections】" class="headerlink" title="day03 【List、Set、数据结构、Collections】"></a>day03 【List、Set、数据结构、Collections】</h1><a id="more"></a>

<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>数据结构</li>
<li>List集合</li>
<li>Set集合</li>
<li>Collections</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够说出List集合特点</li>
<li><input disabled="" type="checkbox"> 能够说出常见的数据结构</li>
<li><input disabled="" type="checkbox"> 能够说出数组结构特点</li>
<li><input disabled="" type="checkbox"> 能够说出栈结构特点</li>
<li><input disabled="" type="checkbox"> 能够说出队列结构特点</li>
<li><input disabled="" type="checkbox"> 能够说出单向链表结构特点</li>
<li><input disabled="" type="checkbox"> 能够说出Set集合的特点</li>
<li><input disabled="" type="checkbox"> 能够说出哈希表的特点</li>
<li><input disabled="" type="checkbox"> 使用HashSet集合存储自定义元素</li>
<li><input disabled="" type="checkbox"> 能够说出可变参数的格式</li>
<li><input disabled="" type="checkbox"> 能够使用集合工具类</li>
<li><input disabled="" type="checkbox"> 能够使用Comparator比较器进行排序</li>
</ul>
<h1 id="第一章-数据结构"><a href="#第一章-数据结构" class="headerlink" title="第一章 数据结构"></a>第一章 数据结构</h1><h2 id="2-1-数据结构有什么用？"><a href="#2-1-数据结构有什么用？" class="headerlink" title="2.1 数据结构有什么用？"></a>2.1 数据结构有什么用？</h2><p>当你用着java里面的容器类很爽的时候，你有没有想过，怎么ArrayList就像一个无限扩充的数组，也好像链表之类的。好用吗？好用，这就是数据结构的用处，只不过你在不知不觉中使用了。</p>
<p>现实世界的存储，我们使用的工具和建模。每种数据结构有自己的优点和缺点，想想如果Google的数据用的是数组的存储，我们还能方便地查询到所需要的数据吗？而算法，在这么多的数据中如何做到最快的插入，查找，删除，也是在追求更快。</p>
<p>我们java是面向对象的语言，就好似自动档轿车，C语言好似手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从 A点 开到 B点，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。当然了，数据结构内容比较多，细细的学起来也是相对费功夫的，不可能达到一蹴而就。我们将常见的数据结构：堆栈、队列、数组、链表和红黑树 这几种给大家介绍一下，作为数据结构的入门，了解一下它们的特点即可。</p>
<h2 id="2-2-常见的数据结构"><a href="#2-2-常见的数据结构" class="headerlink" title="2.2 常见的数据结构"></a>2.2 常见的数据结构</h2><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下：</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul>
<li><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li>
</ul>
<p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p>
<ul>
<li><p>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</p>
</li>
<li><p>栈的入口、出口的都是栈的顶端位置。</p>
</li>
</ul>
<p>这里两个名词需要注意：</p>
<ul>
<li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li>
<li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li>
</ul>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul>
<li><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li>
</ul>
<p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</li>
<li>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</li>
</ul>
<p>简单的说,采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li><p>查找元素快：通过索引，可以快速访问指定位置的元素</p>
</li>
<li><p>增删元素慢</p>
<ul>
<li><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。</li>
<li><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图</li>
</ul>
</li>
</ul>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul>
<li><p><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是<strong>单向链表</strong>。</p>
<img src="/2020/04/04/day03-List-Set/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9.png" class="" title="单链结构">

</li>
</ul>
<p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li><p>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</p>
<img src="/2020/04/04/day03-List-Set/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png" class="" title="单链结构">
</li>
<li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p>
</li>
<li><p>增删元素快：</p>
<ul>
<li><p>增加元素：只需要修改连接下个元素的地址即可。</p>
<img src="/2020/04/04/day03-List-Set/%E5%A2%9E%E5%8A%A0%E7%BB%93%E7%82%B9.png" class="" title="增加结点">
</li>
<li><p>删除元素：只需要修改连接下个元素的地址即可。</p>
<img src="/2020/04/04/day03-List-Set/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9.bmp" class="" title="删除结点">



</li>
</ul>
</li>
</ul>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ul>
<li><strong>二叉树</strong>：<strong>binary tree</strong> ,是每个结点不超过2的有序<strong>树（tree）</strong> 。</li>
</ul>
<p>简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。</p>
<p>二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。</p>
<p>如图：</p>
<img src="/2020/04/04/day03-List-Set/04_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%BA%A2%E9%BB%91%E6%A0%91.bmp" class="" title="红黑树">

<p>我们要说的是二叉树的一种比较有意思的叫做<strong>红黑树</strong>，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。</p>
<p>红黑树的约束:</p>
<ol>
<li>节点可以是红色的或者黑色的</li>
</ol>
<ol start="2">
<li>根节点是黑色的</li>
</ol>
<ol start="3">
<li>叶子节点(特指空节点)是黑色的</li>
<li>每个红色节点的子节点都是黑色的</li>
<li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</li>
</ol>
<p>红黑树的特点:</p>
<p>​    速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍</p>
<h1 id="第二章-List集合"><a href="#第二章-List集合" class="headerlink" title="第二章 List集合"></a>第二章 List集合</h1><p>我们掌握了Collection接口的使用后，再来看看Collection接口中的子类，他们都具备那些特性呢？</p>
<p>接下来，我们一起学习Collection中的常用几个子类（<code>java.util.List</code>集合、<code>java.util.Set</code>集合）。</p>
<h2 id="1-1-List接口介绍"><a href="#1-1-List接口介绍" class="headerlink" title="1.1 List接口介绍"></a>1.1 List接口介绍</h2><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p>
<p>看完API，我们总结一下：</p>
<p>List接口特点：</p>
<ol>
<li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li>
<li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li>
<li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li>
</ol>
<blockquote>
<p>tips:我们在基础班的时候已经学习过List接口的子类java.util.ArrayList类，该类中的方法都是来自List中定义。</p>
</blockquote>
<h2 id="1-2-List接口中常用方法"><a href="#1-2-List接口中常用方法" class="headerlink" title="1.2 List接口中常用方法"></a>1.2 List接口中常用方法</h2><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p>
<ul>
<li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li>
<li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li>
<li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li>
<li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li>
</ul>
<p>List集合特有的方法都是跟索引相关，我们在基础班都学习过，那么我们再来复习一遍吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 创建List集合对象</span><br>    	List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    	<br>    	<span class="hljs-comment">// 往 尾部添加 指定元素</span><br>    	list.add(<span class="hljs-string">"图图"</span>);<br>    	list.add(<span class="hljs-string">"小美"</span>);<br>    	list.add(<span class="hljs-string">"不高兴"</span>);<br>    	<br>    	System.out.println(list);<br>    	<span class="hljs-comment">// add(int index,String s) 往指定位置添加</span><br>    	list.add(<span class="hljs-number">1</span>,<span class="hljs-string">"没头脑"</span>);<br>    	<br>    	System.out.println(list);<br>    	<span class="hljs-comment">// String remove(int index) 删除指定位置元素  返回被删除元素</span><br>    	<span class="hljs-comment">// 删除索引位置为2的元素 </span><br>    	System.out.println(<span class="hljs-string">"删除索引位置为2的元素"</span>);<br>    	System.out.println(list.remove(<span class="hljs-number">2</span>));<br>    	<br>    	System.out.println(list);<br>    	<br>    	<span class="hljs-comment">// String set(int index,String s)</span><br>    	<span class="hljs-comment">// 在指定位置 进行 元素替代（改） </span><br>    	<span class="hljs-comment">// 修改指定位置元素</span><br>    	list.set(<span class="hljs-number">0</span>, <span class="hljs-string">"三毛"</span>);<br>    	System.out.println(list);<br>    	<br>    	<span class="hljs-comment">// String get(int index)  获取指定位置元素</span><br>    	<br>    	<span class="hljs-comment">// 跟size() 方法一起用  来 遍历的 </span><br>    	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;list.size();i++)&#123;<br>    		System.out.println(list.get(i));<br>    	&#125;<br>    	<span class="hljs-comment">//还可以使用增强for</span><br>    	<span class="hljs-keyword">for</span> (String string : list) &#123;<br>			System.out.println(string);<br>		&#125;  	<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="第三章-List的子类"><a href="#第三章-List的子类" class="headerlink" title="第三章 List的子类"></a>第三章 List的子类</h1><h2 id="3-1-ArrayList集合"><a href="#3-1-ArrayList集合" class="headerlink" title="3.1 ArrayList集合"></a>3.1 ArrayList集合</h2><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p>
<p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。</p>
<h2 id="3-2-LinkedList集合"><a href="#3-2-LinkedList集合" class="headerlink" title="3.2 LinkedList集合"></a>3.2 LinkedList集合</h2><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p>
<blockquote>
<p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p>
</blockquote>
{% asset_img 双向链表.png 双向链表 %}

<p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p>
<ul>
<li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li>
<li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li>
<li><code>public E getFirst()</code>:返回此列表的第一个元素。</li>
<li><code>public E getLast()</code>:返回此列表的最后一个元素。</li>
<li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li>
<li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li>
<li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li>
<li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li>
<li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li>
</ul>
<p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可）</p>
<p>方法演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedListDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LinkedList&lt;String&gt; link = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>        <span class="hljs-comment">//添加元素</span><br>        link.addFirst(<span class="hljs-string">"abc1"</span>);<br>        link.addFirst(<span class="hljs-string">"abc2"</span>);<br>        link.addFirst(<span class="hljs-string">"abc3"</span>);<br>        System.out.println(link);<br>        <span class="hljs-comment">// 获取元素</span><br>        System.out.println(link.getFirst());<br>        System.out.println(link.getLast());<br>        <span class="hljs-comment">// 删除元素</span><br>        System.out.println(link.removeFirst());<br>        System.out.println(link.removeLast());<br><br>        <span class="hljs-keyword">while</span> (!link.isEmpty()) &#123; <span class="hljs-comment">//判断集合是否为空</span><br>            System.out.println(link.pop()); <span class="hljs-comment">//弹出集合中的栈顶元素</span><br>        &#125;<br><br>        System.out.println(link);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="第四章-Set接口"><a href="#第四章-Set接口" class="headerlink" title="第四章 Set接口"></a>第四章 Set接口</h1><p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p>
<p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>这两个集合。</p>
<blockquote>
<p>tips:Set集合取出元素的方式可以采用：迭代器、增强for。</p>
</blockquote>
<h2 id="3-1-HashSet集合介绍"><a href="#3-1-HashSet集合介绍" class="headerlink" title="3.1 HashSet集合介绍"></a>3.1 HashSet集合介绍</h2><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，由于我们暂时还未学习，先做了解。</p>
<p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p>
<p>我们先来使用一下Set集合存储，看下现象，再进行原理的讲解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashSetDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建 Set集合</span><br>        HashSet&lt;String&gt;  set = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();<br><br>        <span class="hljs-comment">//添加元素</span><br>        set.add(<span class="hljs-keyword">new</span> String(<span class="hljs-string">"cba"</span>));<br>        set.add(<span class="hljs-string">"abc"</span>);<br>        set.add(<span class="hljs-string">"bac"</span>); <br>        set.add(<span class="hljs-string">"cba"</span>);  <br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-keyword">for</span> (String name : set) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果如下，说明集合中不能存储重复元素：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">cba</span><br><span class="hljs-attribute">abc</span><br><span class="hljs-attribute">bac</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>tips:根据结果我们发现字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。</p>
</blockquote>
<h2 id="2-2-HashSet集合存储数据的结构（哈希表）"><a href="#2-2-HashSet集合存储数据的结构（哈希表）" class="headerlink" title="2.2  HashSet集合存储数据的结构（哈希表）"></a>2.2  HashSet集合存储数据的结构（哈希表）</h2><p>什么是哈希表呢？</p>
<p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p>
<p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。</p>
<img src="/2020/04/04/day03-List-Set/%E5%93%88%E5%B8%8C%E8%A1%A8.png" class="" title="哈希表">

<p>看到这张图就有人要问了，这个是怎么存储的呢？</p>
<p>为了方便大家的理解我们结合一个存储流程图来说明一下：</p>
<img src="/2020/04/04/day03-List-Set/%E5%93%88%E5%B8%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="" title="哈希表流程">

<p>总而言之，<strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p>
<h2 id="2-3-HashSet存储自定义类型元素"><a href="#2-3-HashSet存储自定义类型元素" class="headerlink" title="2.3  HashSet存储自定义类型元素"></a>2.3  HashSet存储自定义类型元素</h2><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一</p>
<p>创建自定义Student类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass())<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        Student student = (Student) o;<br>        <span class="hljs-keyword">return</span> age == student.age &amp;&amp;<br>               Objects.equals(name, student.name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashSetDemo2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建集合对象   该集合中存储 Student类型对象</span><br>        HashSet&lt;Student&gt; stuSet = <span class="hljs-keyword">new</span> HashSet&lt;Student&gt;();<br>        <span class="hljs-comment">//存储 </span><br>        Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"于谦"</span>, <span class="hljs-number">43</span>);<br>        stuSet.add(stu);<br>        stuSet.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">"郭德纲"</span>, <span class="hljs-number">44</span>));<br>        stuSet.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">"于谦"</span>, <span class="hljs-number">43</span>));<br>        stuSet.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">"郭麒麟"</span>, <span class="hljs-number">23</span>));<br>        stuSet.add(stu);<br><br>        <span class="hljs-keyword">for</span> (Student stu2 : stuSet) &#123;<br>            System.out.println(stu2);<br>        &#125;<br>    &#125;<br>&#125;<br>执行结果：<br>Student [name=郭德纲, age=<span class="hljs-number">44</span>]<br>Student [name=于谦, age=<span class="hljs-number">43</span>]<br>Student [name=郭麒麟, age=<span class="hljs-number">23</span>]<br></code></pre></td></tr></table></figure>

<h2 id="2-3-LinkedHashSet"><a href="#2-3-LinkedHashSet" class="headerlink" title="2.3 LinkedHashSet"></a>2.3 LinkedHashSet</h2><p>我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p>
<p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p>
<p>演示代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedHashSetDemo</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Set&lt;String&gt; set = <span class="hljs-keyword">new</span> LinkedHashSet&lt;String&gt;();<br>		set.add(<span class="hljs-string">"bbb"</span>);<br>		set.add(<span class="hljs-string">"aaa"</span>);<br>		set.add(<span class="hljs-string">"abc"</span>);<br>		set.add(<span class="hljs-string">"bbc"</span>);<br>        Iterator&lt;String&gt; it = set.iterator();<br>		<span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>			System.out.println(it.next());<br>		&#125;<br>	&#125;<br>&#125;<br>结果：<br>  bbb<br>  aaa<br>  abc<br>  bbc<br></code></pre></td></tr></table></figure>

<h2 id="1-9-可变参数"><a href="#1-9-可变参数" class="headerlink" title="1.9  可变参数"></a>1.9  可变参数</h2><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;<br></code></pre></td></tr></table></figure>

<p>其实这个书写完全等价与</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">修饰符 返回值类型 方法名(参数类型<span class="hljs-selector-attr">[]</span> 形参名)&#123;  &#125;<br></code></pre></td></tr></table></figure>

<p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</p>
<p><strong>JDK1.5</strong>以后。出现了简化操作。<strong>…</strong> 用在参数上，称之为可变参数。</p>
<p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p>
<p>代码演示：    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangeArgs</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">62</span>, <span class="hljs-number">431</span>, <span class="hljs-number">2</span> &#125;;<br>        <span class="hljs-keyword">int</span> sum = getSum(arr);<br>        System.out.println(sum);<br>        <span class="hljs-comment">//  6  7  2 12 2121</span><br>        <span class="hljs-comment">// 求 这几个元素和 6  7  2 12 2121</span><br>        <span class="hljs-keyword">int</span> sum2 = getSum(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">12</span>, <span class="hljs-number">2121</span>);<br>        System.out.println(sum2);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 完成数组  所有元素的求和 原始写法</span><br><span class="hljs-comment">     </span><br><span class="hljs-comment">      public static int getSum(int[] arr)&#123;</span><br><span class="hljs-comment">        int sum = 0;</span><br><span class="hljs-comment">        for(int a : arr)&#123;</span><br><span class="hljs-comment">            sum += a;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        return sum;</span><br><span class="hljs-comment">      &#125;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">//可变参数写法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>... arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a : arr) &#123;<br>            sum += a;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>tips: 上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性</p>
<p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p>
</blockquote>
<h1 id="第五章-Collections"><a href="#第五章-Collections" class="headerlink" title="第五章  Collections"></a>第五章  Collections</h1><h2 id="2-1-常用功能"><a href="#2-1-常用功能" class="headerlink" title="2.1 常用功能"></a>2.1 常用功能</h2><ul>
<li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</li>
</ul>
<ul>
<li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)</code>:往集合中添加一些元素。</li>
<li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li>
</ul>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionsDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-comment">//原来写法</span><br>        <span class="hljs-comment">//list.add(12);</span><br>        <span class="hljs-comment">//list.add(14);</span><br>        <span class="hljs-comment">//list.add(15);</span><br>        <span class="hljs-comment">//list.add(1000);</span><br>        <span class="hljs-comment">//采用工具类 完成 往集合中添加元素  </span><br>        Collections.addAll(list, <span class="hljs-number">5</span>, <span class="hljs-number">222</span>, <span class="hljs-number">1</span>，<span class="hljs-number">2</span>);<br>        System.out.println(list);<br>        <span class="hljs-comment">//排序方法 </span><br>        Collections.sort(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br>结果：<br>[<span class="hljs-number">5</span>, <span class="hljs-number">222</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">222</span>]<br></code></pre></td></tr></table></figure>

<p>代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？</p>
<p>我们发现还有个方法没有讲，<code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。</p>
<h2 id="2-2-Comparator比较器"><a href="#2-2-Comparator比较器" class="headerlink" title="2.2 Comparator比较器"></a>2.2 Comparator比较器</h2><p>我们还是先研究这个方法</p>
<p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p>
<p>不过这次存储的是字符串类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionsDemo2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;String&gt;  list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        list.add(<span class="hljs-string">"cba"</span>);<br>        list.add(<span class="hljs-string">"aba"</span>);<br>        list.add(<span class="hljs-string">"sba"</span>);<br>        list.add(<span class="hljs-string">"nba"</span>);<br>        <span class="hljs-comment">//排序方法</span><br>        Collections.sort(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">[aba, cba, nba, sba]<br></code></pre></td></tr></table></figure>

<p>我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？</p>
<p>说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用<code>java.lang.Comparable</code>接口去实现，一种是灵活的当我需要做排序的时候在去选择的<code>java.util.Comparator</code>接口完成。</p>
<p>那么我们采用的<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br></code></pre></td></tr></table></figure>

<p>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用</p>
<p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</p>
<ul>
<li><p><code>public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</p>
<blockquote>
<p>两个对象比较的结果有三种：大于，等于，小于。</p>
<p>如果要按照升序排序，<br>则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）<br>如果要按照降序排序<br>则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p>
</blockquote>
</li>
</ul>
<p>操作如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionsDemo3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        list.add(<span class="hljs-string">"cba"</span>);<br>        list.add(<span class="hljs-string">"aba"</span>);<br>        list.add(<span class="hljs-string">"sba"</span>);<br>        list.add(<span class="hljs-string">"nba"</span>);<br>        <span class="hljs-comment">//排序方法  按照第一个单词的降序</span><br>        Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String o1, String o2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> o2.charAt(<span class="hljs-number">0</span>) - o1.charAt(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">[sba, nba, cba, aba]<br></code></pre></td></tr></table></figure>

<h2 id="2-3-简述Comparable和Comparator两个接口的区别。"><a href="#2-3-简述Comparable和Comparator两个接口的区别。" class="headerlink" title="2.3 简述Comparable和Comparator两个接口的区别。"></a>2.3 简述Comparable和Comparator两个接口的区别。</h2><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p>
<p><strong>Comparator</strong>强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p>
<h2 id="2-4-练习"><a href="#2-4-练习" class="headerlink" title="2.4  练习"></a>2.4  练习</h2><p>创建一个学生类，存储到ArrayList集合中完成指定排序操作。</p>
<p>Student 初始类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"Student&#123;"</span> +<br>               <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +<br>               <span class="hljs-string">", age="</span> + age +<br>               <span class="hljs-string">'&#125;'</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建四个学生对象 存储到集合中</span><br>        ArrayList&lt;Student&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Student&gt;();<br><br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">"rose"</span>,<span class="hljs-number">18</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">"jack"</span>,<span class="hljs-number">16</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">"abc"</span>,<span class="hljs-number">16</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">"ace"</span>,<span class="hljs-number">17</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">"mark"</span>,<span class="hljs-number">16</span>));<br><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          让学生 按照年龄排序 升序</span><br><span class="hljs-comment">         */</span><br><span class="hljs-comment">//        Collections.sort(list);//要求 该list中元素类型  必须实现比较器Comparable接口</span><br><br><br>        <span class="hljs-keyword">for</span> (Student student : list) &#123;<br>            System.out.println(student);<br>        &#125;<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>发现，当我们调用Collections.sort()方法的时候 程序报错了。</p>
<p>原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。</p>
<p>于是我们就完成了Student类的一个实现，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Student</span>&gt;</span>&#123;<br>    ....<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Student o)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age-o.age;<span class="hljs-comment">//升序</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>再次测试，代码就OK 了效果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Student&#123;name=<span class="hljs-string">'jack'</span>, age=<span class="hljs-number">16</span>&#125;<br>Student&#123;name=<span class="hljs-string">'abc'</span>, age=<span class="hljs-number">16</span>&#125;<br>Student&#123;name=<span class="hljs-string">'mark'</span>, age=<span class="hljs-number">16</span>&#125;<br>Student&#123;name=<span class="hljs-string">'ace'</span>, age=<span class="hljs-number">17</span>&#125;<br>Student&#123;name=<span class="hljs-string">'rose'</span>, age=<span class="hljs-number">18</span>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-5-扩展"><a href="#2-5-扩展" class="headerlink" title="2.5 扩展"></a>2.5 扩展</h2><p>如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor<T> c)方式，自己定义规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;Student&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> o2.getAge()-o1.getAge();<span class="hljs-comment">//以学生的年龄降序</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>效果：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">'rose'</span>, <span class="hljs-attribute">age</span>=18&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">'ace'</span>, <span class="hljs-attribute">age</span>=17&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">'jack'</span>, <span class="hljs-attribute">age</span>=16&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">'abc'</span>, <span class="hljs-attribute">age</span>=16&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">'mark'</span>, <span class="hljs-attribute">age</span>=16&#125;<br></code></pre></td></tr></table></figure>



<p>如果想要规则更多一些，可以参考下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;<br>                <span class="hljs-comment">// 年龄降序</span><br>                <span class="hljs-keyword">int</span> result = o2.getAge()-o1.getAge();<span class="hljs-comment">//年龄降序</span><br><br>                <span class="hljs-keyword">if</span>(result==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//第一个规则判断完了 下一个规则 姓名的首字母 升序</span><br>                    result = o1.getName().charAt(<span class="hljs-number">0</span>)-o2.getName().charAt(<span class="hljs-number">0</span>);<br>                &#125;<br><br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure>

<p>效果如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">'rose'</span>, <span class="hljs-attribute">age</span>=18&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">'ace'</span>, <span class="hljs-attribute">age</span>=17&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">'abc'</span>, <span class="hljs-attribute">age</span>=16&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">'jack'</span>, <span class="hljs-attribute">age</span>=16&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">'mark'</span>, <span class="hljs-attribute">age</span>=16&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>day02[Collection.泛型]</title>
    <url>/2020/04/04/day02-Collection-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="day02【Collection、泛型】"><a href="#day02【Collection、泛型】" class="headerlink" title="day02【Collection、泛型】"></a>day02【Collection、泛型】</h1><a id="more"></a>

<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>Collection集合</li>
<li>迭代器</li>
<li>增强for</li>
<li>泛型</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够说出集合与数组的区别</li>
<li><input disabled="" type="checkbox"> 说出Collection集合的常用功能</li>
<li><input disabled="" type="checkbox"> 能够使用迭代器对集合进行取元素</li>
<li><input disabled="" type="checkbox"> 能够说出集合的使用细节</li>
<li><input disabled="" type="checkbox"> 能够使用集合存储自定义类型</li>
<li><input disabled="" type="checkbox"> 能够使用foreach循环遍历集合</li>
<li><input disabled="" type="checkbox"> 能够使用泛型定义集合对象</li>
<li><input disabled="" type="checkbox"> 能够理解泛型上下限</li>
<li><input disabled="" type="checkbox"> 能够阐述泛型通配符的作用</li>
</ul>
<h1 id="第一章-Collection集合"><a href="#第一章-Collection集合" class="headerlink" title="第一章 Collection集合"></a>第一章 Collection集合</h1><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1 集合概述"></a>1.1 集合概述</h2><p>在前面基础班我们已经学习过并使用过集合ArrayList<E> ,那么集合到底是什么呢?</p>
<ul>
<li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li>
</ul>
<p>集合和数组既然都是容器，它们有啥区别呢？</p>
<ul>
<li>数组的长度是固定的。集合的长度是可变的。</li>
<li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li>
</ul>
<h2 id="1-2-集合框架"><a href="#1-2-集合框架" class="headerlink" title="1.2  集合框架"></a>1.2  集合框架</h2><p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p>
<p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>，今天我们主要学习<code>Collection</code>集合，在day04时讲解<code>Map</code>集合。</p>
<ul>
<li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素无序，而且不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li>
</ul>
<p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。</p>
<img src="/2020/04/04/day02-Collection-%E6%B3%9B%E5%9E%8B/01.jpg" class="" title="This is an 01 image">

<p>其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。</p>
<p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p>
<h2 id="1-3-Collection-常用功能"><a href="#1-3-Collection-常用功能" class="headerlink" title="1.3 Collection 常用功能"></a>1.3 Collection 常用功能</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p>
<ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code> :清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
</ul>
<p>方法演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1Collection</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 创建集合对象 </span><br>    	<span class="hljs-comment">// 使用多态形式</span><br>    	Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    	<span class="hljs-comment">// 使用方法</span><br>    	<span class="hljs-comment">// 添加功能  boolean  add(String s)</span><br>    	coll.add(<span class="hljs-string">"小李广"</span>);<br>    	coll.add(<span class="hljs-string">"扫地僧"</span>);<br>    	coll.add(<span class="hljs-string">"石破天"</span>);<br>    	System.out.println(coll);<br><br>    	<span class="hljs-comment">// boolean contains(E e) 判断o是否在集合中存在</span><br>    	System.out.println(<span class="hljs-string">"判断  扫地僧 是否在集合中"</span>+coll.contains(<span class="hljs-string">"扫地僧"</span>));<br><br>    	<span class="hljs-comment">//boolean remove(E e) 删除在集合中的o元素</span><br>    	System.out.println(<span class="hljs-string">"删除石破天："</span>+coll.remove(<span class="hljs-string">"石破天"</span>));<br>    	System.out.println(<span class="hljs-string">"操作之后集合中元素:"</span>+coll);<br>    	<br>    	<span class="hljs-comment">// size() 集合中有几个元素</span><br>		System.out.println(<span class="hljs-string">"集合中有"</span>+coll.size()+<span class="hljs-string">"个元素"</span>);<br><br>		<span class="hljs-comment">// Object[] toArray()转换成一个Object数组</span><br>    	Object[] objects = coll.toArray();<br>    	<span class="hljs-comment">// 遍历数组</span><br>    	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; objects.length; i++) &#123;<br>			System.out.println(objects[i]);<br>		&#125;<br><br>		<span class="hljs-comment">// void  clear() 清空集合</span><br>		coll.clear();<br>		System.out.println(<span class="hljs-string">"集合中内容为："</span>+coll);<br>		<span class="hljs-comment">// boolean  isEmpty()  判断是否为空</span><br>		System.out.println(coll.isEmpty());  	<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p>
</blockquote>
<h2 id="第二章-Iterator迭代器"><a href="#第二章-Iterator迭代器" class="headerlink" title="第二章 Iterator迭代器"></a>第二章 Iterator迭代器</h2><h2 id="2-1-Iterator接口"><a href="#2-1-Iterator接口" class="headerlink" title="2.1 Iterator接口"></a>2.1 Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p>
<p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p>
<ul>
<li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li>
</ul>
<p>下面介绍一下迭代的概念：</p>
<ul>
<li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li>
</ul>
<p>Iterator接口的常用方法如下：</p>
<ul>
<li><code>public E next()</code>:返回迭代的下一个元素。</li>
<li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
</ul>
<p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IteratorDemo</span> </span>&#123;<br>  	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用多态方式 创建对象</span><br>        Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>        <span class="hljs-comment">// 添加元素到集合</span><br>        coll.add(<span class="hljs-string">"串串星人"</span>);<br>        coll.add(<span class="hljs-string">"吐槽星人"</span>);<br>        coll.add(<span class="hljs-string">"汪星人"</span>);<br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span><br>        Iterator&lt;String&gt; it = coll.iterator();<br>        <span class="hljs-comment">//  泛型指的是 迭代出 元素的数据类型</span><br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123; <span class="hljs-comment">//判断是否有迭代元素</span><br>            String s = it.next();<span class="hljs-comment">//获取迭代出的元素</span><br>            System.out.println(s);<br>        &#125;<br>  	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p>
</blockquote>
<h2 id="2-2-迭代器的实现原理"><a href="#2-2-迭代器的实现原理" class="headerlink" title="2.2 迭代器的实现原理"></a>2.2 迭代器的实现原理</h2><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p>
<p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p>
<img src="/2020/04/04/day02-Collection-%E6%B3%9B%E5%9E%8B/02_%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86(1).bmp" class="" title="迭代器原理">

<p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p>
<h2 id="2-3-增强for"><a href="#2-3-增强for" class="headerlink" title="2.3 增强for"></a>2.3 增强for</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; <br>  	<span class="hljs-comment">//写操作代码</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p>
<h4 id="练习1：遍历数组"><a href="#练习1：遍历数组" class="headerlink" title="练习1：遍历数组"></a>练习1：遍历数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NBForDemo1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">87</span>&#125;;<br>       	<span class="hljs-comment">//使用增强for遍历数组</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a : arr)&#123;<span class="hljs-comment">//a代表数组中的每个元素</span><br>			System.out.println(a);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="练习2-遍历集合"><a href="#练习2-遍历集合" class="headerlink" title="练习2:遍历集合"></a>练习2:遍历集合</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NBFor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <br>    	Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    	coll.add(<span class="hljs-string">"小河神"</span>);<br>    	coll.add(<span class="hljs-string">"老河神"</span>);<br>    	coll.add(<span class="hljs-string">"神婆"</span>);<br>    	<span class="hljs-comment">//使用增强for遍历</span><br>    	<span class="hljs-keyword">for</span>(String s :coll)&#123;<span class="hljs-comment">//接收变量s代表 代表被遍历到的集合元素</span><br>    		System.out.println(s);<br>    	&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p>
</blockquote>
<h1 id="第三章-泛型"><a href="#第三章-泛型" class="headerlink" title="第三章 泛型"></a>第三章 泛型</h1><h2 id="3-1-泛型概述"><a href="#3-1-泛型概述" class="headerlink" title="3.1  泛型概述"></a>3.1  泛型概述</h2><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p>
<p>大家观察下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericDemo</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Collection coll = <span class="hljs-keyword">new</span> ArrayList();<br>		coll.add(<span class="hljs-string">"abc"</span>);<br>		coll.add(<span class="hljs-string">"itcast"</span>);<br>		coll.add(<span class="hljs-number">5</span>);<span class="hljs-comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span><br>		Iterator it = coll.iterator();<br>		<span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>			<span class="hljs-comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span><br>			String str = (String) it.next();<br>			System.out.println(str.length());<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p>
<ul>
<li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li>
</ul>
<blockquote>
<p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p>
</blockquote>
<h2 id="3-2-使用泛型的好处"><a href="#3-2-使用泛型的好处" class="headerlink" title="3.2  使用泛型的好处"></a>3.2  使用泛型的好处</h2><p>上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？</p>
<ul>
<li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li>
<li>避免了类型强转的麻烦。</li>
</ul>
<p>通过我们如下代码体验一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericDemo2</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Collection&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        list.add(<span class="hljs-string">"abc"</span>);<br>        list.add(<span class="hljs-string">"itcast"</span>);<br>        <span class="hljs-comment">// list.add(5);//当集合明确类型后，存放类型不一致就会编译报错</span><br>        <span class="hljs-comment">// 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span><br>        Iterator&lt;String&gt; it = list.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            String str = it.next();<br>            <span class="hljs-comment">//当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span><br>            System.out.println(str.length());<br>        &#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p>
</blockquote>
<h2 id="3-3-泛型的定义与使用"><a href="#3-3-泛型的定义与使用" class="headerlink" title="3.3  泛型的定义与使用"></a>3.3  泛型的定义与使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p>
<p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p>
<h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">修饰符 <span class="hljs-class"><span class="hljs-keyword">class</span> 类名&lt;代表泛型的变量&gt; &#123;</span>  &#125;<br></code></pre></td></tr></table></figure>

<p>例如，API中的ArrayList集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123; <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>&#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123; &#125;<br>   	....<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用泛型： 即什么时候确定泛型。</p>
<p><strong>在创建对象的时候确定泛型</strong></p>
<p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p>
<p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123; <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(String e)</span></span>&#123; &#125;<br><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123;  &#125;<br>     ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p>
<p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123; <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(Integer e)</span> </span>&#123; &#125;<br><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;  &#125;<br>     ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>举例自定义泛型类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericClass</span>&lt;<span class="hljs-title">MVP</span>&gt; </span>&#123;<br>	<span class="hljs-comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span><br>	<span class="hljs-keyword">private</span> MVP mvp;<br>     <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMVP</span><span class="hljs-params">(MVP mvp)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mvp = mvp;<br>    &#125;<br>     <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MVP <span class="hljs-title">getMVP</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mvp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericClassDemo</span> </span>&#123;<br>  	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;		 <br>         <span class="hljs-comment">// 创建一个泛型为String的类</span><br>         MyGenericClass&lt;String&gt; my = <span class="hljs-keyword">new</span> MyGenericClass&lt;String&gt;();    	<br>         <span class="hljs-comment">// 调用setMVP</span><br>         my.setMVP(<span class="hljs-string">"大胡子登登"</span>);<br>         <span class="hljs-comment">// 调用getMVP</span><br>         String mvp = my.getMVP();<br>         System.out.println(mvp);<br>         <span class="hljs-comment">//创建一个泛型为Integer的类</span><br>         MyGenericClass&lt;Integer&gt; my2 = <span class="hljs-keyword">new</span> MyGenericClass&lt;Integer&gt;(); <br>         my2.setMVP(<span class="hljs-number">123</span>);   	  <br>         Integer mvp2 = my2.getMVP();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><code class="hljs dust"><span class="xml">修饰符 <span class="hljs-tag">&lt;<span class="hljs-name">代表泛型的变量</span>&gt;</span> 返回值类型 方法名(参数)</span><span class="hljs-template-variable">&#123;  &#125;</span><br></code></pre></td></tr></table></figure>

<p>例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericMethod</span> </span>&#123;	  <br>    <span class="hljs-keyword">public</span> &lt;MVP&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(MVP mvp)</span> </span>&#123;<br>    	System.out.println(mvp.getClass());<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> &lt;MVP&gt; <span class="hljs-function">MVP <span class="hljs-title">show2</span><span class="hljs-params">(MVP mvp)</span> </span>&#123;	<br>    	<span class="hljs-keyword">return</span> mvp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericMethodDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建对象</span><br>        MyGenericMethod mm = <span class="hljs-keyword">new</span> MyGenericMethod();<br>        <span class="hljs-comment">// 演示看方法提示</span><br>        mm.show(<span class="hljs-string">"aaa"</span>);<br>        mm.show(<span class="hljs-number">123</span>);<br>        mm.show(<span class="hljs-number">12.45</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript">修饰符 <span class="hljs-class"><span class="hljs-keyword">interface</span>接口名&lt;代表泛型的变量&gt; </span>&#123;  &#125;<br></code></pre></td></tr></table></figure>

<p>例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyGenericInterface</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> E <span class="hljs-title">getE</span><span class="hljs-params">()</span></span>;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用格式：</p>
<p><strong>1、定义类时确定泛型的类型</strong></p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImp1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyGenericInterface</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>	<span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String e)</span> </span>&#123;<br>        <span class="hljs-comment">// 省略...</span><br>    &#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getE</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时，泛型E的值就是String类型。</p>
<p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p>
<p> 例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImp2</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">MyGenericInterface</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>       	 <span class="hljs-comment">// 省略...</span><br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getE</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>确定泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericInterface</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyImp2&lt;String&gt;  my = <span class="hljs-keyword">new</span> MyImp2&lt;String&gt;();  <br>        my.add(<span class="hljs-string">"aa"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-4-泛型通配符"><a href="#3-4-泛型通配符" class="headerlink" title="3.4  泛型通配符"></a>3.4  泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p>
<h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p>
<p>此时只能接受数据,不能往该集合中存储数据。</p>
<p>举个例子大家理解使用即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Collection&lt;Intger&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    getElement(list1);<br>    Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    getElement(list2);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement</span><span class="hljs-params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;<br><span class="hljs-comment">//？代表可以接收任意类型</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>tips:泛型不存在继承关系 Collection<Object> list = new ArrayList<String>();这种是错误的。</p>
</blockquote>
<h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p>
<p><strong>泛型的上限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li>
</ul>
<p><strong>泛型的下限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li>
</ul>
<p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Collection&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    Collection&lt;Number&gt; list3 = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br>    Collection&lt;Object&gt; list4 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br>    <br>    getElement(list1);<br>    getElement(list2);<span class="hljs-comment">//报错</span><br>    getElement(list3);<br>    getElement(list4);<span class="hljs-comment">//报错</span><br>  <br>    getElement2(list1);<span class="hljs-comment">//报错</span><br>    getElement2(list2);<span class="hljs-comment">//报错</span><br>    getElement2(list3);<br>    getElement2(list4);<br>  <br>&#125;<br><span class="hljs-comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement1</span><span class="hljs-params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;<br><span class="hljs-comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement2</span><span class="hljs-params">(Collection&lt;? <span class="hljs-keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<h1 id="第四章-集合综合案例"><a href="#第四章-集合综合案例" class="headerlink" title="第四章 集合综合案例"></a>第四章 集合综合案例</h1><h2 id="4-1-案例介绍"><a href="#4-1-案例介绍" class="headerlink" title="4.1 案例介绍"></a>4.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。<br>具体规则：</p>
<p>使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</p>
<h2 id="4-2-案例分析"><a href="#4-2-案例分析" class="headerlink" title="4.2 案例分析"></a>4.2 案例分析</h2><ul>
<li><p>准备牌：</p>
<p>牌可以设计为一个ArrayList<String>,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collections类的shuffle方法进行随机排序。</p>
</li>
<li><p>发牌</p>
<p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p>
</li>
</ul>
<ul>
<li><p>看牌</p>
<p>直接打印每个集合。</p>
{% asset_img 04_斗地主案例的需求分析.bmp 斗地主案例分析 %}

</li>
</ul>
<h2 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Poker</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 1: 准备牌操作</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">//1.1 创建牌盒 将来存储牌面的 </span><br>        ArrayList&lt;String&gt; pokerBox = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        <span class="hljs-comment">//1.2 创建花色集合</span><br>        ArrayList&lt;String&gt; colors = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>        <span class="hljs-comment">//1.3 创建数字集合</span><br>        ArrayList&lt;String&gt; numbers = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>        <span class="hljs-comment">//1.4 分别给花色 以及 数字集合添加元素</span><br>        colors.add(<span class="hljs-string">"♥"</span>);<br>        colors.add(<span class="hljs-string">"♦"</span>);<br>        colors.add(<span class="hljs-string">"♠"</span>);<br>        colors.add(<span class="hljs-string">"♣"</span>);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">10</span>;i++)&#123;<br>            numbers.add(i+<span class="hljs-string">""</span>);<br>        &#125;<br>        numbers.add(<span class="hljs-string">"J"</span>);<br>        numbers.add(<span class="hljs-string">"Q"</span>);<br>        numbers.add(<span class="hljs-string">"K"</span>);<br>        numbers.add(<span class="hljs-string">"A"</span>);<br>        <span class="hljs-comment">//1.5 创造牌  拼接牌操作</span><br>        <span class="hljs-comment">// 拿出每一个花色  然后跟每一个数字 进行结合  存储到牌盒中</span><br>        <span class="hljs-keyword">for</span> (String color : colors) &#123;<br>            <span class="hljs-comment">//color每一个花色 </span><br>            <span class="hljs-comment">//遍历数字集合</span><br>            <span class="hljs-keyword">for</span>(String number : numbers)&#123;<br>                <span class="hljs-comment">//结合</span><br>                String card = color+number;<br>                <span class="hljs-comment">//存储到牌盒中</span><br>                pokerBox.add(card);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//1.6大王小王</span><br>        pokerBox.add(<span class="hljs-string">"小☺"</span>);<br>        pokerBox.add(<span class="hljs-string">"大☠"</span>);	  <br>        <span class="hljs-comment">// System.out.println(pokerBox);</span><br>        <span class="hljs-comment">//洗牌 是不是就是将  牌盒中 牌的索引打乱 </span><br>        <span class="hljs-comment">// Collections类  工具类  都是 静态方法</span><br>        <span class="hljs-comment">// shuffer方法   </span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * static void shuffle(List&lt;?&gt; list) </span><br><span class="hljs-comment">         *     使用默认随机源对指定列表进行置换。 </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//2:洗牌</span><br>        Collections.shuffle(pokerBox);<br>        <span class="hljs-comment">//3 发牌</span><br>        <span class="hljs-comment">//3.1 创建 三个 玩家集合  创建一个底牌集合</span><br>        ArrayList&lt;String&gt; player1 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; player2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; player3 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        ArrayList&lt;String&gt; dipai = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();	  <br><br>        <span class="hljs-comment">//遍历 牌盒  必须知道索引   </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;pokerBox.size();i++)&#123;<br>            <span class="hljs-comment">//获取 牌面</span><br>            String card = pokerBox.get(i);<br>            <span class="hljs-comment">//留出三张底牌 存到 底牌集合中</span><br>            <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">51</span>)&#123;<span class="hljs-comment">//存到底牌集合中</span><br>                dipai.add(card);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//玩家1   %3  ==0</span><br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>)&#123;<br>                  	player1.add(card);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i%<span class="hljs-number">3</span>==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//玩家2</span><br>                  	player2.add(card);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//玩家3</span><br>                  	player3.add(card);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//看看</span><br>        System.out.println(<span class="hljs-string">"令狐冲："</span>+player1);<br>        System.out.println(<span class="hljs-string">"田伯光："</span>+player2);<br>        System.out.println(<span class="hljs-string">"绿竹翁："</span>+player3);<br>        System.out.println(<span class="hljs-string">"底牌："</span>+dipai);  <br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>javaseObject类</title>
    <url>/2020/04/03/day01%E3%80%90Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%91-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="day01【Object类、常用API】"><a href="#day01【Object类、常用API】" class="headerlink" title="day01【Object类、常用API】"></a>day01【Object类、常用API】</h1><a id="more"></a>
<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>Object类</li>
<li>Date类</li>
<li>DateFormat类</li>
<li>Calendar类</li>
<li>System类</li>
<li>StringBuilder类</li>
<li>包装类</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><p>-[ ] 能够说出Object类的特点<br>-[ ] 能够重写Object类的toString方法<br>-[ ] 能够重写Object类的equals方法<br>-[ ] 能够使用日期类输出当前日期<br>-[ ] 能够使用将日期格式化为字符串的方法<br>-[ ] 能够使用将字符串转换成日期的方法<br>-[ ] 能够使用System类的数组复制方法<br>-[ ] 能够使用System类获取当前毫秒时刻值<br>-[ ] 能够说出使用StringBuilder类可以解决的问题<br>-[ ] 能够使用StringBuilder进行字符串拼接操作<br>-[ ] 能够说出8种基本类型对应的包装类名称<br>-[ ] 能够说出自动装箱、自动拆箱的概念<br>-[ ] 能够将字符串转换为对应的基本类型<br>-[ ] 能够将基本类型转换为对应的字符串</p>
<h1 id="第一章-Object类"><a href="#第一章-Object类" class="headerlink" title="第一章 Object类"></a>第一章 Object类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p>
<p>如果一个类没有特别指定父类，    那么默认则继承自Object类。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> /*<span class="hljs-keyword">extends</span> <span class="hljs-title">Object</span>*/ </span>&#123;<br>  	<span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：</p>
<ul>
<li><code>public String toString()</code>：返回该对象的字符串表示。</li>
<li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li>
</ul>
<h2 id="1-2-toString方法"><a href="#1-2-toString方法" class="headerlink" title="1.2 toString方法"></a>1.2 toString方法</h2><h3 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul>
<li><code>public String toString()</code>：返回该对象的字符串表示。</li>
</ul>
<p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p>
<p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p>
<h3 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h3><p>如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;  <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"Person&#123;"</span> + <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> + <span class="hljs-string">", age="</span> + age + <span class="hljs-string">'&#125;'</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 省略构造器与Getter Setter</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在IntelliJ IDEA中，可以点击<code>Code</code>菜单中的<code>Generate...</code>，也可以使用快捷键<code>alt+insert</code>，点击<code>toString()</code>选项。选择需要包含的成员变量并确定。如下图所示：</p>
<blockquote>
<p>小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。</p>
</blockquote>
<h2 id="1-3-equals方法"><a href="#1-3-equals方法" class="headerlink" title="1.3 equals方法"></a>1.3 equals方法</h2><h3 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul>
<li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li>
</ul>
<p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p>
<h3 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h3><p>如果没有覆盖重写equals方法，那么Object类中默认进行<code>==</code>运算符的对象地址比较，只要不是同一个对象，结果必然为false。</p>
<h3 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h3><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;	<br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>	<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果对象地址一样，则认为相同</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">// 如果参数为空，或者类型信息不一样，则认为不同</span><br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass())<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// 转换为当前类型</span><br>        Person person = (Person) o;<br>        <span class="hljs-comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span><br>        <span class="hljs-keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用<code>Code</code>菜单中的<code>Generate…</code>选项，也可以使用快捷键<code>alt+insert</code>，并选择<code>equals() and hashCode()</code>进行自动代码生成。</p>
<blockquote>
<p>tips：Object类当中的hashCode等其他方法，今后学习。</p>
</blockquote>
<h2 id="1-4-Objects类"><a href="#1-4-Objects类" class="headerlink" title="1.4 Objects类"></a>1.4 Objects类</h2><p>在刚才IDEA自动重写equals代码中，使用到了<code>java.util.Objects</code>类，那么这个类是什么呢？</p>
<p>在<strong>JDK7</strong>添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</p>
<p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p>
<ul>
<li><code>public static boolean equals(Object a, Object b)</code>:判断两个对象是否相等。</li>
</ul>
<p>我们可以查看一下源码，学习一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object a, Object b)</span> </span>&#123;  <br>    <span class="hljs-keyword">return</span> (a == b) || (a != <span class="hljs-keyword">null</span> &amp;&amp; a.equals(b));  <br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="第二章-日期时间类"><a href="#第二章-日期时间类" class="headerlink" title="第二章 日期时间类"></a>第二章 日期时间类</h1><h2 id="2-1-Date类"><a href="#2-1-Date类" class="headerlink" title="2.1 Date类"></a>2.1 Date类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>java.util.Date</code>类 表示特定的瞬间，精确到毫秒。</p>
<p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。</p>
<ul>
<li><code>public Date()</code>：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li>
<li><code>public Date(long date)</code>：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</li>
</ul>
<blockquote>
<p>tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。</p>
</blockquote>
<p>简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Date</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建日期对象，把当前的时间</span><br>        System.out.println(<span class="hljs-keyword">new</span> Date()); <span class="hljs-comment">// Tue Jan 16 14:37:35 CST 2018</span><br>        <span class="hljs-comment">// 创建日期对象，把当前的毫秒值转成日期对象</span><br>        System.out.println(<span class="hljs-keyword">new</span> Date(<span class="hljs-number">0L</span>)); <span class="hljs-comment">// Thu Jan 01 08:00:00 CST 1970</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。</p>
</blockquote>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>Date类中的多数方法已经过时，常用的方法有：</p>
<ul>
<li><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</li>
</ul>
<h2 id="2-2-DateFormat类"><a href="#2-2-DateFormat类" class="headerlink" title="2.2 DateFormat类"></a>2.2 DateFormat类</h2><p><code>java.text.DateFormat</code> 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。</p>
<ul>
<li><strong>格式化</strong>：按照指定的格式，从Date对象转换为String对象。</li>
<li><strong>解析</strong>：按照指定的格式，从String对象转换为Date对象。</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>由于DateFormat为抽象类，不能直接使用，所以需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：</p>
<ul>
<li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li>
</ul>
<p>参数pattern是一个字符串，代表日期时间的自定义格式。</p>
<h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><p>常用的格式规则为：</p>
<table>
<thead>
<tr>
<th>标识字母（区分大小写）</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>时</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody></table>
<blockquote>
<p>备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。</p>
</blockquote>
<p>创建SimpleDateFormat对象的代码如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02SimpleDateFormat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 对应的日期格式如：2018-01-16 15:06:38</span><br>        DateFormat format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>DateFormat类的常用方法有：</p>
<ul>
<li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li>
<li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li>
</ul>
<h4 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h4><p>使用format方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 把Date对象转换成String</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03DateFormatMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Date date = <span class="hljs-keyword">new</span> Date();<br>        <span class="hljs-comment">// 创建日期格式化对象,在获取格式化对象时可以指定风格</span><br>        DateFormat df = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy年MM月dd日"</span>);<br>        String str = df.format(date);<br>        System.out.println(str); <span class="hljs-comment">// 2008年1月23日</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a>parse方法</h4><p>使用parse方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.ParseException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 把String转换成Date对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo04DateFormatMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException </span>&#123;<br>        DateFormat df = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy年MM月dd日"</span>);<br>        String str = <span class="hljs-string">"2018年12月11日"</span>;<br>        Date date = df.parse(str);<br>        System.out.println(date); <span class="hljs-comment">// Tue Dec 11 00:00:00 CST 2018</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-3-练习"><a href="#2-3-练习" class="headerlink" title="2.3 练习"></a>2.3 练习</h2><p>请使用日期时间相关的API，计算出一个人已经出生了多少天。</p>
<p><strong>思路：</strong></p>
<p>1.获取当前时间对应的毫秒值</p>
<p>2.获取自己出生日期对应的毫秒值</p>
<p>3.两个时间相减（当前时间– 出生日期）</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>	System.out.println(<span class="hljs-string">"请输入出生日期 格式 YYYY-MM-dd"</span>);<br>	<span class="hljs-comment">// 获取出生日期,键盘输入</span><br>	String birthdayString = <span class="hljs-keyword">new</span> Scanner(System.in).next();<br>	<span class="hljs-comment">// 将字符串日期,转成Date对象</span><br>	<span class="hljs-comment">// 创建SimpleDateFormat对象,写日期模式</span><br>	SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd"</span>);<br>	<span class="hljs-comment">// 调用方法parse,字符串转成日期对象</span><br>	Date birthdayDate = sdf.parse(birthdayString);	<br>	<span class="hljs-comment">// 获取今天的日期对象</span><br>	Date todayDate = <span class="hljs-keyword">new</span> Date();	<br>	<span class="hljs-comment">// 将两个日期转成毫秒值,Date类的方法getTime</span><br>	<span class="hljs-keyword">long</span> birthdaySecond = birthdayDate.getTime();<br>	<span class="hljs-keyword">long</span> todaySecond = todayDate.getTime();<br>	<span class="hljs-keyword">long</span> secone = todaySecond-birthdaySecond;	<br>	<span class="hljs-keyword">if</span> (secone &lt; <span class="hljs-number">0</span>)&#123;<br>		System.out.println(<span class="hljs-string">"还没出生呢"</span>);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		System.out.println(secone/<span class="hljs-number">1000</span>/<span class="hljs-number">60</span>/<span class="hljs-number">60</span>/<span class="hljs-number">24</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-4-Calendar类"><a href="#2-4-Calendar类" class="headerlink" title="2.4 Calendar类"></a>2.4 Calendar类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>日历我们都见过</p>
<p><code>java.util.Calendar</code>是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p>
<h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：</p>
<p>Calendar静态方法</p>
<ul>
<li><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo06CalendarInit</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Calendar cal = Calendar.getInstance();<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><p>根据Calendar类的API文档，常用方法有：</p>
<ul>
<li><code>public int get(int field)</code>：返回给定日历字段的值。</li>
<li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li>
<li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li>
<li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</li>
</ul>
<p>Calendar类中提供很多成员常量，代表给定的日历字段：</p>
<table>
<thead>
<tr>
<th>字段值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>年</td>
</tr>
<tr>
<td>MONTH</td>
<td>月（从0开始，可以+1使用）</td>
</tr>
<tr>
<td>DAY_OF_MONTH</td>
<td>月中的天（几号）</td>
</tr>
<tr>
<td>HOUR</td>
<td>时（12小时制）</td>
</tr>
<tr>
<td>HOUR_OF_DAY</td>
<td>时（24小时制）</td>
</tr>
<tr>
<td>MINUTE</td>
<td>分</td>
</tr>
<tr>
<td>SECOND</td>
<td>秒</td>
</tr>
<tr>
<td>DAY_OF_WEEK</td>
<td>周中的天（周几，周日为1，可以-1使用）</td>
</tr>
</tbody></table>
<h4 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get/set方法"></a>get/set方法</h4><p>get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalendarUtil</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建Calendar对象</span><br>        Calendar cal = Calendar.getInstance();<br>        <span class="hljs-comment">// 设置年 </span><br>        <span class="hljs-keyword">int</span> year = cal.get(Calendar.YEAR);<br>        <span class="hljs-comment">// 设置月</span><br>        <span class="hljs-keyword">int</span> month = cal.get(Calendar.MONTH) + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 设置日</span><br>        <span class="hljs-keyword">int</span> dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);<br>        System.out.print(year + <span class="hljs-string">"年"</span> + month + <span class="hljs-string">"月"</span> + dayOfMonth + <span class="hljs-string">"日"</span>);<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo07CalendarMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Calendar cal = Calendar.getInstance();<br>        cal.set(Calendar.YEAR, <span class="hljs-number">2020</span>);<br>        System.out.print(year + <span class="hljs-string">"年"</span> + month + <span class="hljs-string">"月"</span> + dayOfMonth + <span class="hljs-string">"日"</span>); <span class="hljs-comment">// 2020年1月17日</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo08CalendarMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Calendar cal = Calendar.getInstance();<br>        System.out.print(year + <span class="hljs-string">"年"</span> + month + <span class="hljs-string">"月"</span> + dayOfMonth + <span class="hljs-string">"日"</span>); <span class="hljs-comment">// 2018年1月17日</span><br>        <span class="hljs-comment">// 使用add方法</span><br>        cal.add(Calendar.DAY_OF_MONTH, <span class="hljs-number">2</span>); <span class="hljs-comment">// 加2天</span><br>        cal.add(Calendar.YEAR, -<span class="hljs-number">3</span>); <span class="hljs-comment">// 减3年</span><br>        System.out.print(year + <span class="hljs-string">"年"</span> + month + <span class="hljs-string">"月"</span> + dayOfMonth + <span class="hljs-string">"日"</span>); <span class="hljs-comment">// 2015年1月18日; </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="getTime方法"><a href="#getTime方法" class="headerlink" title="getTime方法"></a>getTime方法</h4><p>Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo09CalendarMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Calendar cal = Calendar.getInstance();<br>        Date date = cal.getTime();<br>        System.out.println(date); <span class="hljs-comment">// Tue Jan 16 16:03:09 CST 2018</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>​     西方星期的开始为周日，中国为周一。</p>
<p>​     在Calendar类中，月份的表示是以0-11代表1-12月。</p>
<p>​     日期是有大小关系的，时间靠后，时间越大。</p>
</blockquote>
<h1 id="第三章-System类"><a href="#第三章-System类" class="headerlink" title="第三章 System类"></a>第三章 System类</h1><p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：</p>
<ul>
<li><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。</li>
<li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li>
</ul>
<h2 id="3-1-currentTimeMillis方法"><a href="#3-1-currentTimeMillis方法" class="headerlink" title="3.1 currentTimeMillis方法"></a>3.1 currentTimeMillis方法</h2><p>实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       	<span class="hljs-comment">//获取当前时间毫秒值</span><br>        System.out.println(System.currentTimeMillis()); <span class="hljs-comment">// 1516090531144</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>验证for循环打印数字1-9999所需要使用的时间（毫秒）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemTest1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            System.out.println(i);<br>        &#125;<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">"共耗时毫秒："</span> + (end - start));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-2-arraycopy方法"><a href="#3-2-arraycopy方法" class="headerlink" title="3.2 arraycopy方法"></a>3.2 arraycopy方法</h2><ul>
<li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li>
</ul>
<p>数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：</p>
<table>
<thead>
<tr>
<th>参数序号</th>
<th>参数名称</th>
<th>参数类型</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>src</td>
<td>Object</td>
<td>源数组</td>
</tr>
<tr>
<td>2</td>
<td>srcPos</td>
<td>int</td>
<td>源数组索引起始位置</td>
</tr>
<tr>
<td>3</td>
<td>dest</td>
<td>Object</td>
<td>目标数组</td>
</tr>
<tr>
<td>4</td>
<td>destPos</td>
<td>int</td>
<td>目标数组索引起始位置</td>
</tr>
<tr>
<td>5</td>
<td>length</td>
<td>int</td>
<td>复制元素个数</td>
</tr>
</tbody></table>
<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo11SystemArrayCopy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] src = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-keyword">int</span>[] dest = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;<br>        System.arraycopy( src, <span class="hljs-number">0</span>, dest, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>        <span class="hljs-comment">/*代码运行后：两个数组中的元素发生了变化</span><br><span class="hljs-comment">         src数组元素[1,2,3,4,5]</span><br><span class="hljs-comment">         dest数组元素[1,2,3,9,10]</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="第四章-StringBuilder类"><a href="#第四章-StringBuilder类" class="headerlink" title="第四章 StringBuilder类"></a>第四章 StringBuilder类</h1><h2 id="4-1-字符串拼接问题"><a href="#4-1-字符串拼接问题" class="headerlink" title="4.1 字符串拼接问题"></a>4.1 字符串拼接问题</h2><p>由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s = <span class="hljs-string">"Hello"</span>;<br>        s += <span class="hljs-string">"World"</span>;<br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。</p>
<p>根据这句话分析我们的代码，其实总共产生了三个字符串，即<code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>和<code>&quot;HelloWorld&quot;</code>。引用变量s首先指向<code>Hello</code>对象，最终指向拼接出来的新字符串对象，即<code>HelloWord</code> 。</p>
<p>由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用<code>java.lang.StringBuilder</code>类。</p>
<h2 id="4-2-StringBuilder概述"><a href="#4-2-StringBuilder概述" class="headerlink" title="4.2 StringBuilder概述"></a>4.2 StringBuilder概述</h2><p>查阅<code>java.lang.StringBuilder</code>的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p>
<p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p>
<p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)</p>
<p><img src="..%5Cimg%5C01_StringBuilder%E7%9A%84%E5%8E%9F%E7%90%86.bmp" alt="01-StringBuilder的原理"></p>
<h2 id="4-3-构造方法"><a href="#4-3-构造方法" class="headerlink" title="4.3 构造方法"></a>4.3 构造方法</h2><p>根据StringBuilder的API文档，常用构造方法有2个：</p>
<ul>
<li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li>
<li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBuilderDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        StringBuilder sb1 = <span class="hljs-keyword">new</span> StringBuilder();<br>        System.out.println(sb1); <span class="hljs-comment">// (空白)</span><br>        <span class="hljs-comment">// 使用带参构造</span><br>        StringBuilder sb2 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"itcast"</span>);<br>        System.out.println(sb2); <span class="hljs-comment">// itcast</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-4-常用方法"><a href="#4-4-常用方法" class="headerlink" title="4.4 常用方法"></a>4.4 常用方法</h2><p>StringBuilder常用的方法有2个：</p>
<ul>
<li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li>
<li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li>
</ul>
<h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><p>append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02StringBuilder</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">//创建对象</span><br>		StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();<br>		<span class="hljs-comment">//public StringBuilder append(任意类型)</span><br>		StringBuilder builder2 = builder.append(<span class="hljs-string">"hello"</span>);<br>		<span class="hljs-comment">//对比一下</span><br>		System.out.println(<span class="hljs-string">"builder:"</span>+builder);<br>		System.out.println(<span class="hljs-string">"builder2:"</span>+builder2);<br>		System.out.println(builder == builder2); <span class="hljs-comment">//true</span><br>	    <span class="hljs-comment">// 可以添加 任何类型</span><br>		builder.append(<span class="hljs-string">"hello"</span>);<br>		builder.append(<span class="hljs-string">"world"</span>);<br>		builder.append(<span class="hljs-keyword">true</span>);<br>		builder.append(<span class="hljs-number">100</span>);<br>		<span class="hljs-comment">// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。</span><br>        <span class="hljs-comment">// 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下</span><br>		<span class="hljs-comment">//链式编程</span><br>		builder.append(<span class="hljs-string">"hello"</span>).append(<span class="hljs-string">"world"</span>).append(<span class="hljs-keyword">true</span>).append(<span class="hljs-number">100</span>);<br>		System.out.println(<span class="hljs-string">"builder:"</span>+builder);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>备注：StringBuilder已经覆盖重写了Object当中的toString方法。</p>
</blockquote>
<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo16StringBuilder</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 链式创建</span><br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"Hello"</span>).append(<span class="hljs-string">"World"</span>).append(<span class="hljs-string">"Java"</span>);<br>        <span class="hljs-comment">// 调用方法</span><br>        String str = sb.toString();<br>        System.out.println(str); <span class="hljs-comment">// HelloWorldJava</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="第五章-包装类"><a href="#第五章-包装类" class="headerlink" title="第五章 包装类"></a>第五章 包装类</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应的包装类（位于java.lang包中）</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h2 id="5-2-装箱与拆箱"><a href="#5-2-装箱与拆箱" class="headerlink" title="5.2 装箱与拆箱"></a>5.2 装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p>
<ul>
<li><p><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</p>
</li>
<li><p><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</p>
</li>
</ul>
<p>用Integer与 int为例：（看懂代码即可）</p>
<p>基本数值—-&gt;包装对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer i = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用构造函数函数</span><br>Integer iii = Integer.valueOf(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用包装类中的valueOf方法</span><br></code></pre></td></tr></table></figure>

<p>包装对象—-&gt;基本数值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = i.intValue();<br></code></pre></td></tr></table></figure>
<h2 id="5-3自动装箱与自动拆箱"><a href="#5-3自动装箱与自动拆箱" class="headerlink" title="5.3自动装箱与自动拆箱"></a>5.3自动装箱与自动拆箱</h2><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer i = <span class="hljs-number">4</span>;<span class="hljs-comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span><br>i = i + <span class="hljs-number">5</span>;<span class="hljs-comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span><br><span class="hljs-comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span><br></code></pre></td></tr></table></figure>

<h2 id="5-3-基本类型与字符串之间的转换"><a href="#5-3-基本类型与字符串之间的转换" class="headerlink" title="5.3 基本类型与字符串之间的转换"></a>5.3 基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><p>   基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： </p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><code class="hljs lsl">基本类型直接与””相连接即可；如：<span class="hljs-number">34</span>+<span class="hljs-string">""</span><br></code></pre></td></tr></table></figure>

<p>String转换成对应的基本类型 </p>
<p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p>
<ul>
<li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li>
<li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li>
<li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li>
<li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li>
<li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li>
<li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li>
<li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li>
</ul>
<p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo18WrapperParse</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> num = Integer.parseInt(<span class="hljs-string">"100"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p>
</blockquote>
]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/2020/04/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="我的博客编写"><a href="#我的博客编写" class="headerlink" title="我的博客编写"></a>我的博客编写</h1><a id="more"></a>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用标题时需要#</p>
<h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>这是第一段<br>这是第二段</p>
<h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><p>这是一段引用</p>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="https://www.baidu.com/?tn=44004473_17_oem_dg&ctsutp8=14" target="_blank" rel="noopener">百度</a>  </p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="https://dss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3778173668,1422088699&fm=26&gp=0.jpg" alt="风景"> </p>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul>
<li>无序列表  </li>
<li>无序列表  </li>
</ul>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>1.有序1<br>2.尤须2  </p>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
