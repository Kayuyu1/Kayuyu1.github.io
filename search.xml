<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>面试一</title>
    <url>/2020/06/06/%E9%9D%A2%E8%AF%95%E4%B8%80/</url>
    <content><![CDATA[<h1 id="1、请你谈谈java"><a href="#1、请你谈谈java" class="headerlink" title="1、请你谈谈java"></a>1、请你谈谈java</h1><p>一般面试可能一开始会问这个问题，可以从以下方面阐述</p>
<ul>
<li>跨平台性：一次编译到处运行</li>
<li>GC：不用手动回收</li>
<li>语言特性：lamda，泛型，反射</li>
<li>面向对象：封装，继承，多态</li>
<li>类库：自带的集合和并发库。</li>
<li>异常体系</li>
</ul>
<h1 id="2、java如何实现跨平台"><a href="#2、java如何实现跨平台" class="headerlink" title="2、java如何实现跨平台"></a>2、java如何实现跨平台</h1><p>​        <strong>java源码文件由javac编译成class文件，这个class文件就是java实现跨平台的基础，java在不同的平台都有相应的JVM，JVM可以将class文件转换成具体平台的机器指令。</strong></p>
<h1 id="3、JVM如何加载Class文件"><a href="#3、JVM如何加载Class文件" class="headerlink" title="3、JVM如何加载Class文件"></a>3、JVM如何加载Class文件</h1><h1 id="4、什么是反射"><a href="#4、什么是反射" class="headerlink" title="4、什么是反射"></a>4、什么是反射</h1>]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx</title>
    <url>/2020/06/05/nginx/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>JUC探索下</title>
    <url>/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/</url>
    <content><![CDATA[<h1 id="1、函数式接口"><a href="#1、函数式接口" class="headerlink" title="1、函数式接口"></a>1、函数式接口</h1><blockquote>
<p><strong>什么是函数式接口？</strong></p>
<p>函数式接口是指只有一个抽象方法的接口。</p>
<p><strong>使用函数式接口的好处？</strong></p>
<p>使用函数式接口，能让我们脱离面向对象的条条框框，只注重参数和方法体的编写。</p>
</blockquote>
<a id="more"></a>

<h1 id="2、流式编程"><a href="#2、流式编程" class="headerlink" title="2、流式编程"></a>2、流式编程</h1><p>流式思想类似于工厂车间的“<strong>生产流水线</strong>”。我们将原本分开的操作组合成一组“模型“统一执行。</p>
<p>当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结 </p>
<p>果。</p>
<p>之前学习过流，这里就做两个小demo复习</p>
<p>要求：留下所有姓张的人，选择第二和第三个元素，并将姓张的替换成姓刘。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(strings,<span class="string">"张无忌"</span>,<span class="string">"张三丰"</span>,<span class="string">"张翠山"</span>,<span class="string">"赵敏"</span>,<span class="string">"周芷若"</span>);</span><br><span class="line"></span><br><span class="line">        strings.stream().filter(s -&gt; s.startsWith(<span class="string">"张"</span>))</span><br><span class="line">                .skip(<span class="number">1</span>)</span><br><span class="line">                .map(s -&gt; s.replace(<span class="string">'张'</span>,<span class="string">'刘'</span>))</span><br><span class="line">                .forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要求：找到姓名里有”三“的人,并将其转换为老师，根据年龄从小到大输出前两个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">"张三"</span>,<span class="number">15</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">"李三"</span>,<span class="number">16</span>);</span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">"王2"</span>,<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(students,student1,student2,student3);</span><br><span class="line"></span><br><span class="line">        students.stream().filter(student -&gt; student.getName().contains(<span class="string">"三"</span>))</span><br><span class="line">                .limit(<span class="number">2</span>)</span><br><span class="line">                .map(student -&gt; <span class="keyword">new</span> Teacher(student.getName(),student.getAge()))</span><br><span class="line">                .sorted((s1,s2)-&gt;s1.getAge()-s2.getAge())</span><br><span class="line">                .forEach(teacher -&gt; System.out.println(teacher));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3、ForkJoin"><a href="#3、ForkJoin" class="headerlink" title="3、ForkJoin"></a>3、ForkJoin</h1><h2 id="3-1、什么是ForkJoin"><a href="#3-1、什么是ForkJoin" class="headerlink" title="3.1、什么是ForkJoin"></a>3.1、什么是ForkJoin</h2><p>在古代，皇帝要想办成一件事肯定不会自己亲自去动手，而是把任务细分发给下面的大臣，下面的大臣也懒呀，于是把任务继续分成几个部分，继续下发，于是到了最后最终负责的人就完成了一个小功能。上面的领导再把这些结果一层一层汇总，最终返回给皇帝。这就是分而治之的思想，也是就是ForkJoin。</p>
<img src="/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/1.png" class="" title="分治思想">

<p>ForkJoin中最重要的特性是<strong>工作窃取</strong>。比如，大家都是很勤快的人，有的人工作不熟悉，完成的慢；有的人是老鸟，完成的快，完成的快的人不会闲着没事做，他会从未完成任务的人手里拿任务继续工作。这就是工作窃取。</p>
<h2 id="3-2、ForkJoin如何使用"><a href="#3-2、ForkJoin如何使用" class="headerlink" title="3.2、ForkJoin如何使用"></a>3.2、ForkJoin如何使用</h2><ol>
<li>继承RecursiveTask<V>或者RecursiveAction实现compute()；</li>
<li>创建ForkJoinPool；</li>
<li>用ForkJoinPool执行实现类；</li>
</ol>
<p>使用ForkJoin，流计算，普通代码执行求和效率对比</p>
<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long start;</span><br><span class="line">    <span class="keyword">private</span> Long end;</span><br><span class="line">    <span class="keyword">private</span> Long temp=<span class="number">10000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinDemo</span><span class="params">(Long start, Long end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((end-start)&gt;temp)</span><br><span class="line">        &#123;</span><br><span class="line">            Long sum=<span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (Long i=start;i&lt;end;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Long middle=(end-start)/<span class="number">2</span>;</span><br><span class="line">            ForkJoinDemo forkJoinDemo1 = <span class="keyword">new</span> ForkJoinDemo(start, middle);</span><br><span class="line">            forkJoinDemo1.fork();</span><br><span class="line">            ForkJoinDemo forkJoinDemo2 = <span class="keyword">new</span> ForkJoinDemo(middle, start);</span><br><span class="line">            forkJoinDemo2.fork();</span><br><span class="line">            <span class="keyword">return</span> forkJoinDemo1.join()+forkJoinDemo2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">        test2();</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Long start=System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//rangeClosed是(]</span></span><br><span class="line">        <span class="comment">//range是()</span></span><br><span class="line">        <span class="keyword">long</span> sum = LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">1000000000L</span>).parallel().reduce(<span class="number">0</span>,Long::sum);</span><br><span class="line">        Long end=System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"执行时间"</span>+(end-start)+<span class="string">"结果"</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Long start=System.currentTimeMillis();</span><br><span class="line">        Long sum=<span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (Long i=<span class="number">0L</span>;i&lt;<span class="number">1000000000L</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        Long end=System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"执行时间"</span>+(end-start)+<span class="string">"结果"</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Long start=System.currentTimeMillis();</span><br><span class="line">        ForkJoinDemo forkJoinDemo = <span class="keyword">new</span> ForkJoinDemo(<span class="number">0L</span>,<span class="number">1000000000L</span>);</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(forkJoinDemo);</span><br><span class="line">        <span class="comment">//获取执行结果</span></span><br><span class="line">        Long sum = submit.get();</span><br><span class="line"></span><br><span class="line">        Long end=System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"执行时间"</span>+(end-start)+<span class="string">"结果"</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/2.png" class="" title="分治思想">

<p>哇哇哇！！！！，震惊并行流计算居然如此之快！</p>
<blockquote>
<p>补充： 类型::方法名 中的::在Java 8中被用作<strong>方法引用</strong>，方法引用是与lambda表达式相关的一个重要特性。它提供了一种不执行方法的方法。有关方法引用为啥不用加参数，我一直都不是很明白。感兴趣的可以看看这篇博文<a href="https://blog.csdn.net/lsmsrc/article/details/41747159。" target="_blank" rel="noopener">https://blog.csdn.net/lsmsrc/article/details/41747159。</a></p>
</blockquote>
<h1 id="4、JMM"><a href="#4、JMM" class="headerlink" title="4、JMM"></a>4、JMM</h1><h2 id="4-1、引出JMM"><a href="#4-1、引出JMM" class="headerlink" title="4.1、引出JMM"></a>4.1、引出JMM</h2><blockquote>
<p>提问：请你谈谈Volatile。</p>
</blockquote>
<p>Volatile是java中的关键字，是java虚拟机提供的<strong>轻量级同步机制</strong>。它有三个特性</p>
<ul>
<li>可见性</li>
<li><strong>不保证原子性</strong></li>
<li>禁止指令重排</li>
</ul>
<blockquote>
<p>提问：它是如何保证可见性的。</p>
</blockquote>
<p>要明白如何保证可见性就必须理解JMM。</p>
<h2 id="4-2、什么是JMM"><a href="#4-2、什么是JMM" class="headerlink" title="4.2、什么是JMM"></a>4.2、什么是JMM</h2><p>首先我们来看看线程与主内存之间的交互：</p>
<img src="/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/3.png" class="" title="线程与主内存">

<p><strong>内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）</strong></p>
<ul>
<li>lock   （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态</li>
<li>unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>
<li>read  （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load   （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中</li>
<li>use   （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令</li>
<li>assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中</li>
<li>store  （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用</li>
<li>write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</li>
</ul>
<p><strong>JMM对这八种指令的使用，制定了如下规则：</strong></p>
<ul>
<li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</li>
<li>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</li>
<li>不允许一个线程将没有assign的数据从工作内存同步回主内存</li>
<li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</li>
<li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</li>
<li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</li>
<li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</li>
<li>对一个变量进行unlock操作之前，必须把此变量同步回主内存</li>
</ul>
<p><strong>总结：JMM是java内存模型，它不是真实存在的，它是一种概念，是一些规范。它定义了一些内存读写的规则，目的在于解决缓存一致问题。</strong></p>
<h1 id="5、Volatile"><a href="#5、Volatile" class="headerlink" title="5、Volatile"></a>5、Volatile</h1><h2 id="5-1、可见性"><a href="#5-1、可见性" class="headerlink" title="5.1、可见性"></a>5.1、可见性</h2><blockquote>
<p>虽然我们明白了什么是JMM，但还是不知道Volatile的可见性是什么意思</p>
</blockquote>
<p>下面我们通过对下面这段代码来理解可见性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Juc2Demo02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer num=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (num==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        num=<span class="number">1</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/4.png" class="" title="结果">

<p>我们发现，程序一直在运行，可是我们已经修改了num的值了啊，为啥线程不停止。</p>
<p><strong>这是因为主线程和线程之间不可见，他们无法互相感知值的改变，通过对前面的线程与主内存交互，我们发现store后write是单程操作，如果一个线程先改变了值放入主内存，但另外一个线程没接收到值已经改变的通知，就会出现这种结果。</strong></p>
<p>给num加上volatile就可以使线程之间的值可见，可以相互感知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Integer num=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<img src="/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/5.png" class="" title="结果">

<h2 id="5-2、不保证原子性"><a href="#5-2、不保证原子性" class="headerlink" title="5.2、不保证原子性"></a>5.2、不保证原子性</h2><p>原子性：一组不可分割的操作，要么都执行，要么都不执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JucDemo03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Integer num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)<span class="comment">//主线程和gc，当线程存活数目大于2的时候礼让。</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们期望的结果是2000，但最终程序结果却差很多。</p>
<img src="/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/6.png" class="" title="结果">

<p><strong>为什么我们执行一行num++，都不是原子级的操作吗？</strong></p>
<p>让我们反编译看看一行num++到底在计算机里走了几步：</p>
<img src="/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/7.png" class="" title="反编译">

<p>原来走了那么多步，操作可分割啊，没有保证原子性，怪不得会多线程会执行不同步，一个线程已经计算了，但另外一个线程还拿着未处理的值。</p>
<p><strong>如何解决？</strong></p>
<p><strong>1.使用synchronized关键字，和lock锁</strong></p>
<p><strong>2.使用原子类</strong></p>
<img src="/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/8.png" class="" title="原子类">

<p>改造代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JucDemo03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger num=<span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       num.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3、指令重排"><a href="#5-3、指令重排" class="headerlink" title="5.3、指令重排"></a>5.3、指令重排</h2><p>编译器会将优化指令顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">1</span>;<span class="comment">//1</span></span><br><span class="line"><span class="keyword">int</span> y=<span class="number">2</span>;<span class="comment">//2</span></span><br><span class="line">x++;<span class="comment">//3</span></span><br><span class="line">y++;<span class="comment">//4</span></span><br><span class="line">x*y<span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<p>我们期望的执行顺序是12345，但编译器指令重排的顺序可能是21345，23415。。</p>
<p><strong>指令重排要考虑数据的依赖</strong></p>
<p>所以5必须在最后。</p>
<p>指令重排在并发下可能造成的数据期望不符合。</p>
<p>x,y,a,b初始值均为0</p>
<table>
<thead>
<tr>
<th>线程a</th>
<th>线程b</th>
</tr>
</thead>
<tbody><tr>
<td>x=a</td>
<td>y=b</td>
</tr>
<tr>
<td>b=1</td>
<td>a=2</td>
</tr>
</tbody></table>
<p>期望结果：x=0，y=0，a=1,b=2;</p>
<p>发生指令重排：</p>
<table>
<thead>
<tr>
<th>线程a</th>
<th>线程b</th>
</tr>
</thead>
<tbody><tr>
<td>b=1</td>
<td>a=2</td>
</tr>
<tr>
<td>x=a</td>
<td>y=b</td>
</tr>
</tbody></table>
<p>执行结果：x=2，y=1,a=2,b=1;</p>
<p><strong>如何解决？</strong></p>
<p><strong>有一个内存屏障的概念，他会阻止指令重排。当加上Volatile关键字后，它会在内存的代码两边加上内存屏障。</strong></p>
<h1 id="6、彻底玩转单例模式"><a href="#6、彻底玩转单例模式" class="headerlink" title="6、彻底玩转单例模式"></a>6、彻底玩转单例模式</h1><blockquote>
<p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p>
</blockquote>
<h2 id="6-1、饿汉式"><a href="#6-1、饿汉式" class="headerlink" title="6.1、饿汉式"></a>6.1、饿汉式</h2><p>非常饥渴，一上来就初始化实例，也不管你调不调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungerMan</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungerMan</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungerMan hungerMan=<span class="keyword">new</span> HungerMan();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungerMan <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungerMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：保证线程安全</p>
<p>缺点：因为一上来就初始化实例，如果不用就会占用内存。</p>
<h2 id="6-2、懒汉式"><a href="#6-2、懒汉式" class="headerlink" title="6.2、懒汉式"></a>6.2、懒汉式</h2><p>线程安全的懒汉式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMan</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyMan</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyMan lazyMan;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazyMan <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyMan==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            lazyMan=<span class="keyword">new</span> LazyMan();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：解决了饿汉的缺点，懒汉式是在程序调用的时候才会初始化，延迟加载。</p>
<p>缺点：每次调用创建实例的方法，都会产生同步开销。</p>
<h2 id="6-3、双重检查（DCL）"><a href="#6-3、双重检查（DCL）" class="headerlink" title="6.3、双重检查（DCL）"></a>6.3、双重检查（DCL）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheck</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheck</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleCheck doubleCheck;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> DoubleCheck <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (doubleCheck==<span class="keyword">null</span>)<span class="comment">//线程1，2，3到达。线程1先拿锁，先实例化完成。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(DoubleCheck<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (doubleCheck==<span class="keyword">null</span>)<span class="comment">//如果不判断，线程2 .3就还会自己实例化。</span></span><br><span class="line">                &#123;</span><br><span class="line">                    doubleCheck=<span class="keyword">new</span> DoubleCheck();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> doubleCheck;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：线程安全，节省了同步开销。</p>
<p>缺点：第一次加载比较慢。</p>
<p><strong>为什么需要两个if？</strong></p>
<p>第一个if是为了去掉不必要的同步开销，第二个if是doubleCheck为null的情况下创建实例。举一个例子：</p>
<p>假如有3个线程一同走到了第一个if判断，线程1先拿到锁，线程23等待，线程1创建玩实例退出，如果没有第二个if判断实例是否为空，那线程23将会再次实例化对象，这违背了单例的规定。</p>
<p><a href="https://blog.csdn.net/weixin_38983929/article/details/103006376" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38983929/article/details/103006376</a></p>
<p><strong>为什么要使用volatile</strong>？</p>
<p>为了保证线程间的可见性，还有禁止指令重排。</p>
<h2 id="6-4、静态内部类"><a href="#6-4、静态内部类" class="headerlink" title="6.4、静态内部类"></a>6.4、静态内部类</h2><p>首先我们要明白静态内部类的加载时机：</p>
<p>之前我一直以为静态内部类也会随着类的加载而加载，直到我看见了这一句话：<strong>外部类初次加载，会初始化静态变量、静态代码块、静态方法，但不会加载内部类和静态内部类，静态内部类被调用的时候才会加载</strong>。我悟了:smile:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticSingle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticSingle</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerSingle</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> StaticSingle staticSingle=<span class="keyword">new</span> StaticSingle();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticSingle <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerSingle.staticSingle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：线程安全，延迟加载，没有同步开销。（推荐使用）</p>
<p>缺点：能被反射暴力破解（其实上面的都能被反射破解）</p>
<h2 id="6-5、枚举"><a href="#6-5、枚举" class="headerlink" title="6.5、枚举"></a>6.5、枚举</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">     INSTANCE;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>优点：代码简单，不会被反射破解</p>
<p>缺点：可读性差，</p>
<h2 id="6-7、总结"><a href="#6-7、总结" class="headerlink" title="6.7、总结"></a>6.7、总结</h2><ul>
<li>一个核心原理就是私有构造,并且通过静态方法获取一个实例。</li>
<li>在这个过程中必须保证线程的安全性。</li>
<li>推荐用静态内部内实现单例或加了Volatile关键字的双重检查单例</li>
</ul>
<h1 id="7、CAS"><a href="#7、CAS" class="headerlink" title="7、CAS"></a>7、CAS</h1><blockquote>
<p><strong>概念：</strong></p>
<p>CAS（Compare-and-Swap），即比较并替换，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。CAS也是现在面试经常问的问题，本文将深入的介绍CAS的原理。CAS是乐观锁的一种实现。</p>
</blockquote>
<p>CAS实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/9.png" class="" title="CAS">

<p><strong>UnSafe类</strong></p>
<p>通过才看compareAndSet源码我们发现使用了UnSafe类。</p>
<img src="/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/10.png" class="" title="compareAndSet">

<p>再看UnSafe类源码，我们发现它全使用了native关键字。</p>
<img src="/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/11.png" class="" title="UnSafe">

<p>这说明UnSafe类是java的后门类，也就是说Unsafe类都是直接调用操作系统底层资源执行任务。</p>
<p><strong>java中的CAS</strong></p>
<p>** java.util.concurrent **完全建立在CAS之上，CAS有三个操作数，内存值V、旧的预期值A、要修改的值B，如果 V == A, 那么 V =B，返回true；否则什么都不做返回false。</p>
<p>CAS 的全称 Compare-And-Swap，它是一条 CPU 并发<br>CAS 说白了就是使用真实值和期望值进行比较，如果相等的话，进行修改成功，否则修改失败。<br>在Java中 CAS 底层使用的就是自旋锁 + UnSafe类。</p>
<p><strong>AtomicInteger.getAndIncrement() 进行分析</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>this是 AtomicInteger实例对象；</li>
<li>valueOffset是基于该实例对象的偏移量；</li>
<li>1是需要加的值<br>然后调用的是 UnSafe类 的 getAndAddInt方法。</li>
</ol>
<p><strong>UnSafe 的 getAndAddInt</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>var1 AtomicInteger 对象本身。</li>
<li>var2 内存地址偏移量。</li>
<li>var4 要进行加多少。</li>
<li>var5 在通过var1 var2 找出了主物理内存上面真实的值 用当前该对象的值比较var5 如果相同更新var5 + var4 并返回true。</li>
<li>如果不同，继续取值然后再比较，直至更新完成(自旋锁)。</li>
</ol>
<p><strong>CAS缺点？</strong></p>
<ol>
<li>循环时间长开销大；<br>如果线程数比较多的话，CAS请求失败会一直循环下去，这样的话CPU带来的开销就比较大。</li>
<li>只能保证一个共享变量的原子操作；<br>对于多个共享变量操作时，循环 CAS 就无法保证操作的原子性。</li>
<li>会出现ABA问题。</li>
</ol>
<h1 id="8、什么是ABA"><a href="#8、什么是ABA" class="headerlink" title="8、什么是ABA"></a>8、什么是ABA</h1><p><strong>一句话总结：开头和结尾是一样的，中间的过程会发生变化。</strong></p>
<p>举例说明：有两个人A、B，桌子上有一个耳机，然后A去拿耳机用，桌子上换成饼干，耳机用完，桌子上又换回了耳机。对于桌子而言状态变化：耳机 — 饼干 — 耳机。然后B同学去桌子拿耳机用，在B看来桌子上的耳机没有变化，但是过程中耳机已经被使用过了，这就是ABA问题。</p>
<p>ABA实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            atomicInteger.compareAndSet(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">            atomicInteger.compareAndSet(<span class="number">6</span>,<span class="number">5</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">            System.out.println(atomicInteger.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/12.png" class="" title="结果">

<p>第二个线程不知道atomicInteger经历了改变。</p>
<p><strong>解决方法：原子引用加版本号（时间戳）</strong></p>
<p>原子引用：</p>
<p><strong>AtomicReference</strong> 对于一个类而言可以使用原子引用进行封装。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicReference&lt;User&gt; are = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>以上就完成了保证User类原子性。</p>
<p>原子引用加版本号（时间戳）:</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicStampedReference&lt;Integer&gt; atomicInteger = <span class="keyword">new</span> AtomicStampedReference(<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            atomicInteger.compareAndSet(<span class="number">5</span>,<span class="number">6</span>,</span><br><span class="line">                    atomicInteger.getStamp(),atomicInteger.getStamp()+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            atomicInteger.compareAndSet(<span class="number">6</span>,<span class="number">5</span>,</span><br><span class="line">                    atomicInteger.getStamp(),atomicInteger.getStamp()+<span class="number">1</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">                 <span class="number">1</span>,atomicInteger.getStamp()+<span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">"版本号=》"</span>+atomicInteger.getStamp());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>第一个线程修改了两次值，导致时间戳变为了3，所以第二个线程期望的时间戳与实际的不符，我们就知道有人偷偷修改了值。这就解决了ABA问题。</strong></p>
<img src="/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/13.png" class="" title="结果">

<h1 id="9、各种锁的理解"><a href="#9、各种锁的理解" class="headerlink" title="9、各种锁的理解"></a>9、各种锁的理解</h1><h2 id="9-1、公平锁-非公平锁"><a href="#9-1、公平锁-非公平锁" class="headerlink" title="9.1、公平锁/非公平锁"></a>9.1、公平锁/非公平锁</h2><p>公平锁：非抢占式，先来后到不能插队，效率不高。</p>
<p>非公平锁：抢占式，允许按照一定规则插队，效率高。</p>
<h2 id="9-2、可重入锁：当获取外锁时，就能获取内锁。"><a href="#9-2、可重入锁：当获取外锁时，就能获取内锁。" class="headerlink" title="9.2、可重入锁：当获取外锁时，就能获取内锁。"></a>9.2、可重入锁：当获取外锁时，就能获取内锁。</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;phone.send()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"send"</span>);</span><br><span class="line">            call();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"call"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/14.png" class="" title="结果">

<p>ReentrantLock和synchronized都是可重入锁。</p>
<h2 id="9-3、独享锁-共享锁"><a href="#9-3、独享锁-共享锁" class="headerlink" title="9.3、独享锁/共享锁"></a>9.3、独享锁/共享锁</h2><p>独享锁是指该锁一次只能被一个线程所持有。<br>共享锁是指该锁可被多个线程所持有。</p>
<p>对于Java <code>ReentrantLock</code>而言，其是独享锁。但是对于Lock的另一个实现类<code>ReadWriteLock</code>，其读锁是共享锁，其写锁是独享锁。<br>读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。<br>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。<br>对于<code>Synchronized</code>而言，当然是独享锁。</p>
<h2 id="9-4、互斥锁-读写锁"><a href="#9-4、互斥锁-读写锁" class="headerlink" title="9.4、互斥锁/读写锁"></a>9.4、互斥锁/读写锁</h2><p>上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。<br>互斥锁在Java中的具体实现就是<code>ReentrantLock</code><br>读写锁在Java中的具体实现就是<code>ReadWriteLock</code></p>
<h2 id="9-5、乐观锁-悲观锁"><a href="#9-5、乐观锁-悲观锁" class="headerlink" title="9.5、乐观锁/悲观锁"></a>9.5、乐观锁/悲观锁</h2><p>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。<br>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。</p>
<p>乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。<strong>乐观锁的概念中其实已经阐述了它的具体实现细节。主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是CAS(Compare and Swap)。</strong></p>
<p>从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。<br>悲观锁在Java中的使用，就是利用各种锁。<br>乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</p>
<p><a href="https://www.jianshu.com/p/d2ac26ca6525" target="_blank" rel="noopener">https://www.jianshu.com/p/d2ac26ca6525</a></p>
<h2 id="9-6、自旋锁"><a href="#9-6、自旋锁" class="headerlink" title="9.6、自旋锁"></a>9.6、自旋锁</h2><p>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p>
<p><strong>手写自旋锁</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference=<span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();<span class="comment">//获取当前线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//期望值为null，更新值为当前线程,如果不是，循环等待</span></span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>,thread))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="comment">//期望值为当前线程，更新值为null</span></span><br><span class="line">        atomicReference.compareAndSet(thread,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLoackTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLock myLock = <span class="keyword">new</span> MyLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            myLock.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"lock"</span>);</span><br><span class="line"></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"unlock"</span>);</span><br><span class="line">                myLock.myUnLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            myLock.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"lock"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"unlock"</span>);</span><br><span class="line">                myLock.myUnLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程0先获取锁，线程1后自旋等待线程0释放锁。</p>
<img src="/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/15.png" class="" title="结果">

<h1 id="10、死锁"><a href="#10、死锁" class="headerlink" title="10、死锁"></a>10、死锁</h1><p>死锁产生的条件：</p>
<p>1.互斥条件。一个资源只能被一个进程占用</p>
<p>2.不可剥夺条件。某个进程占用了资源，就只能他自己去释放。</p>
<p>3.请求和保持条件。某个经常之前申请了资源，我还想再申请资源，之前的资源还是我占用着，别人别想动。除非我自己不想用了，释放掉。</p>
<p>4.循环等待条件。一定会有一个环互相等待。</p>
<p>模拟死锁：</p>
<img src="/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/17.png" class="" title="死锁">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeathLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeathLock</span><span class="params">(String lockA, String lockB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">        <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeathLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (lockA)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"拥有"</span>+lockA+<span class="string">"想要"</span>+lockB);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"拿到"</span>+lockB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeathLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String lockA=<span class="string">"lockA"</span>;</span><br><span class="line">        String lockB=<span class="string">"lockB"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> DeathLock(lockA,lockB),<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> DeathLock(lockB,lockA),<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/16.png" class="" title="结果">

<p>排查方法：</p>
<p>1.查看日志</p>
<p>2.查看堆栈信息</p>
<ul>
<li><p><code>jps -l</code>查看进程号</p>
<img src="/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/18.png" class="" title="查看进程号">
</li>
<li><p><code>jstack 进程号</code>查看信息</p>
<img src="/2020/06/01/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8B/19.png" class="" title="发现问题">

</li>
</ul>
]]></content>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql的事务隔离级别</title>
    <url>/2020/05/31/mysql%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h1 id="1、首先了解什么是事务以及它的特性"><a href="#1、首先了解什么是事务以及它的特性" class="headerlink" title="1、首先了解什么是事务以及它的特性"></a>1、首先了解什么是事务以及它的特性</h1><p><a href="https://www.cnblogs.com/Kevin-ZhangCG/p/9038371.html" target="_blank" rel="noopener">https://www.cnblogs.com/Kevin-ZhangCG/p/9038371.html</a></p>
<h1 id="2、了解脏读，幻读，不可重复读"><a href="#2、了解脏读，幻读，不可重复读" class="headerlink" title="2、了解脏读，幻读，不可重复读"></a>2、了解脏读，幻读，不可重复读</h1><p><a href="https://www.jianshu.com/p/0cef4c68b8f3" target="_blank" rel="noopener">https://www.jianshu.com/p/0cef4c68b8f3</a></p>
<h1 id="3、事务隔离级别"><a href="#3、事务隔离级别" class="headerlink" title="3、事务隔离级别"></a>3、事务隔离级别</h1><p><a href="https://www.cnblogs.com/yuxiang1/p/11989667.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuxiang1/p/11989667.html</a></p>
<p><a href="https://www.cnblogs.com/QX-Tang/p/11516567.html" target="_blank" rel="noopener">https://www.cnblogs.com/QX-Tang/p/11516567.html</a></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>内存溢出和内存泄露的区别</title>
    <url>/2020/05/30/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="内存溢出-out-of-memory"><a href="#内存溢出-out-of-memory" class="headerlink" title="内存溢出 out of memory"></a><strong>内存溢出 out of memory</strong></h1><p>是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请 了一个integer,但给它存了long才能存下的数，那就是内存溢出。</p>
<h1 id="内存泄露-memory-leak"><a href="#内存泄露-memory-leak" class="headerlink" title="内存泄露 memory leak"></a><strong>内存泄露 memory leak</strong></h1><p>是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。<br><code>memory leak会最终会导致out of memory！
内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。</code></p>
<a id="more"></a>]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>java中堆和栈的区别</title>
    <url>/2020/05/30/java%E4%B8%AD%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>java中堆和栈的区别自然是面试中的常见问题，下面几点就是其具体的区别</p>
<a id="more"></a>

<h3 id="各司其职"><a href="#各司其职" class="headerlink" title="各司其职"></a>各司其职</h3><p>最主要的区别就是栈内存用来存储局部变量和方法调用。<br>而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</p>
<h3 id="独有还是共享"><a href="#独有还是共享" class="headerlink" title="独有还是共享"></a>独有还是共享</h3><p>栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。<br>而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</p>
<h3 id="异常错误"><a href="#异常错误" class="headerlink" title="异常错误"></a>异常错误</h3><p>如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。<br>而如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。</p>
<h3 id="空间大小"><a href="#空间大小" class="headerlink" title="空间大小"></a>空间大小</h3><p>栈的内存要远远小于堆内存</p>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC探索上</title>
    <url>/2020/05/26/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8A/</url>
    <content><![CDATA[<h1 id="1、什么是JUC"><a href="#1、什么是JUC" class="headerlink" title="1、什么是JUC"></a>1、什么是JUC</h1><p>JUC是java.util.concurrent的缩写，它提供了一些在高并发情况下可使用的线程安全的类。</p>
<a id="more"></a>

<h1 id="2、传统的synchronized与Lock锁的区别"><a href="#2、传统的synchronized与Lock锁的区别" class="headerlink" title="2、传统的synchronized与Lock锁的区别"></a>2、传统的synchronized与Lock锁的区别</h1><p>synchronized基本使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ky.juc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: workspace_idea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Kuang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-05-26 14:00</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JucDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Tick tick = <span class="keyword">new</span> Tick();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                tick.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                tick.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                tick.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tick</span> </span>&#123;</span><br><span class="line">        <span class="comment">//票数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"买票第"</span> + num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lock锁基本使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ky.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: workspace_idea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Kuang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-05-26 14:00</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JucDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tick tick = <span class="keyword">new</span> Tick();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                tick.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                tick.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                tick.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tick</span> </span>&#123;</span><br><span class="line">        <span class="comment">//票数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">            lock.lock();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"买票第"</span> + num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>传统的synchronized与Lock锁的区别</strong>：</p>
<ul>
<li>synchronized是关键字；Lock是接口</li>
<li>synchronized有代码锁、方法锁；Lock只用代码锁</li>
<li>synchronized是非公平锁；Lock可以自己设置非公平/公平锁<ul>
<li>非公平锁：是可以插队的一种锁机制，比如一个线程3s执行完，但它排在要3h执行完的线程后面，就可以先执行。（效率高）</li>
<li>公平锁：就是老老实实排队。（效率低）</li>
</ul>
</li>
<li>synchronized会自动释放锁；Lock必须手动释放，不然会死锁</li>
<li>synchronized适合少量的同步代码；Lock适合大量的同步代码</li>
<li>synchronized操作比较固定；Lock相对灵活</li>
</ul>
<blockquote>
<p><code>补充</code>：请简述wait()与sleep()的区别</p>
<p>1.wait()的根类是Object()，sleep()的的根类是Thread</p>
<p>2.wait()会释放锁，sleep()会抱着锁睡觉</p>
<p>3.wait()必须在同步代码块/同步方法里面，而sleep()可以在任意位置</p>
</blockquote>
<h1 id="3、虚假唤醒问题"><a href="#3、虚假唤醒问题" class="headerlink" title="3、虚假唤醒问题"></a>3、虚假唤醒问题</h1><p>什么是虚假唤醒？</p>
<p>线程也可以唤醒，而不会被通知，中断或超时，即所谓的<em>虚假唤醒</em> （这是api上的解释但说的不通俗）。</p>
<p>以下实在别人博客上找到的通俗解释：</p>
<p>当一个条件满足时，很多线程都被唤醒了，但是只有其中部分是有用的唤醒，其它的唤醒都是无用功 </p>
<p><strong>比如说买货，如果商架本来没有货物，突然进了一件商品，这是所有的线程都被唤醒了 ，但是只能一个人买，所以其他人都是假唤醒，获取不到对象的锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: workspace_idea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Kuang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-05-26 20:36</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JucDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+num);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="comment">//唤醒</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">decrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+num);</span><br><span class="line">        num--;</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/26/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8A/1.png" class="" title="结果">

<p>在上面代码中我们有两个消费者，两个生产者，但生产资料却出现了负数。这是为什么了</p>
<p><strong>原因：if语句只执行一次，执行完毕后或执行外面的语句，这就导致无论你是否wait()了线程他都会执行notifyAll()唤醒线程。</strong></p>
<img src="/2020/05/26/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8A/2.png" class="" title="原因">

<p><strong>解决：将if换成while，因为while直到条件满足才会向下执行while（）外边的。</strong></p>
<h1 id="4、使用JUC实现生产者与消费者"><a href="#4、使用JUC实现生产者与消费者" class="headerlink" title="4、使用JUC实现生产者与消费者"></a>4、使用JUC实现生产者与消费者</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JucDemo04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data4</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   Condition condition=lock.newCondition();</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(num!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+num);</span><br><span class="line">            num++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">decrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(num==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                condition.signalAll();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+num);</span><br><span class="line">            num--;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过对比我们发现： lock.lock();lock.unlock();代替了synchronized,  condition.await();代替了wait(),condition.signalAll();代替notifyAll()Lock替换synchronized方法和语句的使用， Condition取代了对象监视器方法的使用。</strong></p>
<blockquote>
<p>Condition的优势：传统的线程通知是随机的，Condition可以精准通知线程。</p>
</blockquote>
<h2 id="4-1、实验：使用多线程循环打印ABC"><a href="#4-1、实验：使用多线程循环打印ABC" class="headerlink" title="4.1、实验：使用多线程循环打印ABC"></a>4.1、实验：使用多线程循环打印ABC</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ky.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: workspace_idea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:通过不同的监视器解决指定唤醒</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Kuang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-05-27 11:40</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JucDemo05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Data5 data5 = <span class="keyword">new</span> Data5();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                data5.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                data5.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                data5.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断-&gt;业务-&gt;通知</span></span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">1</span>) &#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            num = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">2</span>) &#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            num = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">3</span>) &#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/26/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8A/3.png" class="" title="循环结果">

<p>图解流程：</p>
<img src="/2020/05/26/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8A/4.png" class="" title="流程">

<h1 id="5、锁现象测试"><a href="#5、锁现象测试" class="headerlink" title="5、锁现象测试"></a>5、锁现象测试</h1><p>测试模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: workspace_idea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:模板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Kuang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-05-27 15:29</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="comment">//发短信</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           phone1.sendmsg();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">//休息一秒保证打电话先拿到锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打电话</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone1.call();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">sendmsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-1、测试"><a href="#5-1、测试" class="headerlink" title="5.1、测试"></a>5.1、测试</h2><p><strong>问题一：如果在执行sendmsg()方法的时候休眠4秒，那么发短信和打电话谁先执行</strong></p>
<p>修改<code>sendmsg()</code>代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">sendmsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>结果：4秒后发短信先执行</p>
<img src="/2020/05/26/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8A/5.png" class="" title="结果">

<p>原因：因为非静态的synchronized方法，锁的是调用的对象，又因为两个线程共用对象phone1，而且两个线程在main方法中启动的先后不同时，所以在第一个线程抢到锁，就必须等它执行完<code>sendmsg()</code>释放锁后，下一个线程才能拿到锁执行，无论同步代码块中是否有休眠。</p>
<p><strong>问题二：如果将<code>call()</code>方法上的关键字去掉结果如何？</strong></p>
<p>修改<code>call()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果：打电话先打印，4秒后发短信打印</p>
<img src="/2020/05/26/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8A/6.png" class="" title="结果">

<p>原因：没有了sychronized也就没有了锁，不存在抢占，又因为<code>phone1.sendmsg()</code>会休眠4秒，所以打电话先打印。</p>
<p><strong>问题三：如果再加入一个phone2对象，第一个线程执行 phone1.sendmsg();第二个线程执行 phone2.call()。请问发短信和打电话谁先打印？</strong></p>
<p>添加phone2对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Phone phone2 = <span class="keyword">new</span> Phone();</span><br></pre></td></tr></table></figure>

<p>结果：打电话先打印，4秒后发短信打印</p>
<img src="/2020/05/26/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8A/6.png" class="" title="结果">

<p>原因：锁的对象不同，<code>phone1.sendmsg()</code>与<code>phone2.call()</code>无关，并不会出现抢锁现象，又因为<code>phone1.sendmsg()</code>会休眠4秒，所以打电话先打印。</p>
<p><strong>问题四：在问题三的基础上将所有的sychronized方法改为静态的，又如何。</strong></p>
<p>修改代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">sendmsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果：4秒后发短信先执行</p>
<img src="/2020/05/26/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8A/5.png" class="" title="结果">

<p>原因：被static修饰的关键字从属于类，因为无论有多少个实例对象，类模板都只有一个，所以第一个线程和第二个线程的锁是相同的,所以在第一个线程抢到锁，就必须等它执行完<code>sendmsg()</code>释放锁后，下一个线程才能拿到锁执行</p>
<h1 id="6、List，Set集合类不安全"><a href="#6、List，Set集合类不安全" class="headerlink" title="6、List，Set集合类不安全"></a>6、List，Set集合类不安全</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JucDemo06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">30</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                strings.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">3</span>));</span><br><span class="line">                strings.forEach(s -&gt; System.out.print(s));</span><br><span class="line">                System.out.println(<span class="string">" "</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多线程的情况下会报并发修改异常<code>java.util.ConcurrentModificationException</code></p>
<p><strong>解决方案：</strong></p>
<ul>
<li>List<String> strings = new Vector&lt;&gt;();</li>
<li>List<String> strings = Collections.synchronizedList(new ArrayList&lt;&gt;());</li>
<li>List<String> strings = new CopyOnWriteArrayList&lt;&gt;();</li>
</ul>
<p><strong>写时复制思想：</strong></p>
<p>CopyOnWrite简称COW，写入时复制（CopyOnWrite，简称COW）思想是计算机程序设计领域中的一种优化策略，它的核心思想是当修改资源的时候调用者修改的是副本，其他调用者看到的仍然是原始数据。</p>
<p><strong>CopyOnWriteXXX的add()方法源码分析：</strong></p>
<ol>
<li><p>CopyOnWriteArrayList的add方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>它在进行元素添加的时候，会先将原数组复制并长度加一<code>Object[] newElements = Arrays.copyOf(elements, len + 1);</code>再将待添加的元素加入新数组中，最后setArray(newElements)将原容器的引用指向新容器。这样做的好处是避免了写入时覆盖。</p>
<p>2.使用了lock锁，保证了多线程添加下的线程安全。</p>
<p><strong>使用场景:</strong></p>
<p>在读多，写少的情况下适用。比如白名单，黑名单等场景。</p>
<p><strong>CopyOnWriteXXX的优点</strong></p>
<ol>
<li>读写分离</li>
<li>线程安全</li>
</ol>
<p><strong>CopyOnWriteXXX的两个缺点</strong></p>
<ol>
<li>因为采用了写时复制，所以CopyOnWriteXXX在添加的时候会多一次复制操作，这增加系统资源的消耗。</li>
<li>CopyOnWriteXXX只能保证最终数据的一致性，不能保证实时数据一致性。</li>
</ol>
<blockquote>
<p>补充回顾：</p>
<p>HashSet的底层是HashMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashSet的add()方法本质是用的HashMap的put()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();<span class="comment">//静态不变类</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="7、Map集合类不安全"><a href="#7、Map集合类不安全" class="headerlink" title="7、Map集合类不安全"></a>7、Map集合类不安全</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JucDemo06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">30</span> ; i++) &#123;</span><br><span class="line">            Integer num=i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                hashMap.put(Thread.currentThread().getName(),String.valueOf(num));</span><br><span class="line">                System.out.println(hashMap);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多线程的情况下会报并发修改异常<code>java.util.ConcurrentModificationException</code></p>
<p><strong>解决方案：</strong></p>
<ul>
<li>Map&lt;String,String&gt; hashMap = new Hashtable&lt;&gt;();</li>
<li>Map&lt;String,String&gt; hashMap = Collections.synchronizedMap(new Hashtable&lt;&gt;());</li>
<li>Map&lt;String,String&gt; hashMap = new ConcurrentHashMap&lt;&gt;();</li>
</ul>
<p><strong>回顾hashmap，探究currenthashmap：</strong></p>
<p><a href="https://www.bilibili.com/video/BV1oE411n7ug?from=search&amp;seid=6027548520959686442" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1oE411n7ug?from=search&amp;seid=6027548520959686442</a></p>
<p><a href="https://www.bilibili.com/video/BV1N4411d7pm?from=search&amp;seid=6027548520959686442" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1N4411d7pm?from=search&amp;seid=6027548520959686442</a></p>
<p><a href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/" target="_blank" rel="noopener">https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/</a></p>
<h1 id="8、CountDownLatch"><a href="#8、CountDownLatch" class="headerlink" title="8、CountDownLatch"></a>8、CountDownLatch</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JucDemo07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">6</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"Go"</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">            ).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"关门"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/26/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8A/7.png" class="" title="结果">

<p>CountDownLatch相当于一个守门人，<code>countDownLatch.countDown();</code>每当有一个人出门就-1， <code>countDownLatch.await();</code>规定当人走完即减为0后，才执行下面的语句。</p>
<h1 id="9、CyclicBarrier"><a href="#9、CyclicBarrier" class="headerlink" title="9、CyclicBarrier"></a>9、CyclicBarrier</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JucDemo08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; System.out.println(<span class="string">"召唤神龙"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">7</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp=i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"第"</span>+temp+<span class="string">"颗"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/26/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8A/8.png" class="" title="结果">

<p><code>CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; System.out.println(&quot;召唤神龙&quot;));</code>设定了线程执行的个数，以及所以线程执行完后的结果。</p>
<p>注意 :<code>cyclicBarrier.await();</code>在线程内，而<code>countDownLatch.await();</code>在线程外。</p>
<p><strong>CountDownLatch与CyclicBarrier的区别</strong></p>
<table>
<thead>
<tr>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
</tr>
</thead>
<tbody><tr>
<td>减数方式</td>
<td>加数方式</td>
</tr>
<tr>
<td>计算为0时释放所有等待的线程</td>
<td>计数达到指定值时释放所有等待线程</td>
</tr>
<tr>
<td>计数为0时，无法重置</td>
<td>计数达到指定值时，计数置为0重新开始</td>
</tr>
<tr>
<td>调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响</td>
<td>调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞</td>
</tr>
<tr>
<td>CountDownLatch的下一步的动作实施者是调用者</td>
<td>CyclicBarrier的下一步动作实施者还是“其他线程”本身</td>
</tr>
<tr>
<td>不可重复利用</td>
<td>可重复利用</td>
</tr>
</tbody></table>
<h1 id="10、Semaphore"><a href="#10、Semaphore" class="headerlink" title="10、Semaphore"></a>10、Semaphore</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JucDemo09</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3个停车场</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6俩车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">6</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();<span class="comment">//得到停车位</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"进入"</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                semaphore.release();<span class="comment">//释放停车位</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"离开"</span>);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Semaphore semaphore = new Semaphore(3);</code>定义最大线程执行个数</p>
<p><code>semaphore.acquire();</code>得到信号量</p>
<p><code>semaphore.release();</code>释放信号量</p>
<p>作用：并发限流。</p>
<h1 id="11、读写锁，ReadWriteLock"><a href="#11、读写锁，ReadWriteLock" class="headerlink" title="11、读写锁，ReadWriteLock"></a>11、读写锁，ReadWriteLock</h1><p>要求：写的时候只能一个写入，读的时候可以多个人读取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JucDemo10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            String temp=String.valueOf(i);</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">               myCache.writer(temp,temp+<span class="string">"k"</span>);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            String temp=String.valueOf(i);</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                myCache.read(temp);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock=<span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">(String key,String value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"正在写入"</span>);</span><br><span class="line">            map.put(key,value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"写完"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"正在读取"</span>);</span><br><span class="line">            String value = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"读取完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/26/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8A/9.png" class="" title="结果">

<p><code>readWriteLock.writeLock()</code>属于独占锁，只允许一个线程占有锁，就是要修改数据，外人连想进来读数据都不行，完全霸占数据使用权。</p>
<p><code>readWriteLock.readLock()</code>属于共享锁，允许多个线程使用锁，且只允许读取资源，如果想修改必须等读锁释放。</p>
<p><strong>注意：由于在main线程中已经实现了读写分离，所以加不加读锁结果也符合。那为什么读取写不分离地方必须要加读锁？是因为要==避免脏读==（你读取的时候，别人正在修改，你读取的就是别人修改的数据，但如果别人因为某种原因回滚，你读取的就是无效的数据，这就是脏读）</strong></p>
<h1 id="12-线程池"><a href="#12-线程池" class="headerlink" title="12.线程池"></a>12.线程池</h1><h2 id="12-1、池化技术"><a href="#12-1、池化技术" class="headerlink" title="12.1、池化技术"></a>12.1、池化技术</h2><p>对象池，线程池，连接池…..</p>
<p>为了避免资源的消耗而出现的技术，其核心思想是<strong>减少每次获取资源的消耗，提高对资源的利用率</strong>。</p>
<h2 id="12-2、线程池的好处"><a href="#12-2、线程池的好处" class="headerlink" title="12.2、线程池的好处"></a>12.2、线程池的好处</h2><ul>
<li>减少资源消耗</li>
<li>提高了响应速度</li>
<li>方便管理</li>
</ul>
<p><strong>==线程复用、控制最大并发数、方便管理==</strong></p>
<h2 id="12-3、使用Executors四种创建线程池的方式"><a href="#12-3、使用Executors四种创建线程池的方式" class="headerlink" title="12.3、使用Executors四种创建线程池的方式"></a>12.3、使用Executors四种创建线程池的方式</h2><ul>
<li>Executors.newFixedThreadPool(X)</li>
<li>Executors.newCachedThreadPool()</li>
<li>Executors.newSingleThreadExecutor()</li>
<li>Executors.newScheduledThreadPool(x)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JucDemo11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建有固定线程数量的线程池</span></span><br><span class="line">        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//创建可伸缩线程池</span></span><br><span class="line">        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//创建只有一个线程的线程池</span></span><br><span class="line">        ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="comment">//创建一个可定期或者延时执行任务的定长线程池，支持定时及周期性任务执行</span></span><br><span class="line">        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* for (int i = 0; i &lt;10 ; i++) &#123;</span></span><br><span class="line"><span class="comment">            final Integer temp=i;</span></span><br><span class="line"><span class="comment">            fixedThreadPool.submit(()-&gt; System.out.println(Thread.currentThread().getName()+"-&gt;"+temp));</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">       <span class="comment">/* for (int i = 0; i &lt;10 ; i++) &#123;</span></span><br><span class="line"><span class="comment">            final Integer temp=i;</span></span><br><span class="line"><span class="comment">            cachedThreadPool.submit(()-&gt; System.out.println(Thread.currentThread().getName()+"-&gt;"+temp));</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*      for (int i = 0; i &lt;10 ; i++) &#123;</span></span><br><span class="line"><span class="comment">            final Integer temp=i;</span></span><br><span class="line"><span class="comment">            singleThreadExecutor.submit(()-&gt; System.out.println(Thread.currentThread().getName()+"-&gt;"+temp));</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> Integer temp=i;</span><br><span class="line">            scheduledExecutorService.schedule(()-&gt; System.out.println(Thread.currentThread().</span><br><span class="line">                    getName()+<span class="string">"-&gt;"</span>+temp),<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在阿里巴巴开发手册中不建议使用Executors,</strong>原因如下：</p>
<img src="/2020/05/26/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8A/10.png" class="" title="阿里巴巴">

<h2 id="12-4、七大参数"><a href="#12-4、七大参数" class="headerlink" title="12.4、七大参数"></a>12.4、七大参数</h2><blockquote>
<p>查看创建线程池的源码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过源码观察，我们发现线程池创建的四个方法中有三与ThreadPoolExecutor有直接关系（ScheduledThreadPoolExecutor其实继承了ThreadPoolExecutor），所以它们本质都是ThreadPoolExecutor。</p>
<blockquote>
<p>查看ThreadPoolExecutor</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">          maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">          maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">          keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">      <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">      <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">      <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">      <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">      <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">      <span class="keyword">this</span>.handler = handler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>int corePoolSize：基本线程个数</strong></li>
<li><strong>int maximumPoolSize：最大线程个数</strong></li>
<li><strong>long keepAliveTime：超时等待时间</strong></li>
<li><strong>TimeUnit unit：等待时间单位</strong></li>
<li><strong>BlockingQueue<Runnable> workQueue,：阻塞队列</strong></li>
<li><strong>ThreadFactory threadFactory：创造线程的工厂</strong></li>
<li><strong>RejectedExecutionHandler handler：拒绝策略</strong></li>
</ul>
<p>通过模拟银行业务来理解：</p>
<ol>
<li><p>当人不多的时候，只开启两个窗口（corePoolSize），其他人在接待处等着（workQueue）</p>
<img src="/2020/05/26/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8A/11.png" class="" title="人不多">
</li>
<li><p>当人多，接待处满了，就会开启其他窗口。</p>
<img src="/2020/05/26/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8A/12.png" class="" title="人多">
</li>
<li><p>当人很多的时候，窗口也满了，接待区也满了，进来的人要么站在等，要么就不进来，这就是拒绝策略生效。</p>
<img src="/2020/05/26/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8A/13.png" class="" title="爆满">

</li>
</ol>
<p>窗口相当于我们要开启的线程、窗口初始数量相当于corePoolSize、窗口最大数量相当于maximumPoolSize、接待处相当于workQueue</p>
<p>人爆满后的的执行策略就相当于 handler。</p>
<h2 id="12-5、四种拒绝策略"><a href="#12-5、四种拒绝策略" class="headerlink" title="12.5、四种拒绝策略"></a>12.5、四种拒绝策略</h2><img src="/2020/05/26/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8A/14.png" class="" title="四种拒绝策略">

<blockquote>
<p>最大承载数=队列容量+最大线程数</p>
</blockquote>
<ul>
<li>AbortPolicy():当线程池到达最大承载数，如果还有线程要求就会抛出异常java.util.concurrent.RejectedExecutionException。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JucDemo12</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        <span class="comment">//最大承载数=Queue.size+maximumPoolSize</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp=i;</span><br><span class="line">            threadPoolExecutor.execute(()-&gt; </span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"-&gt;"</span>+temp))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上代码的最大承载数为8，我们选择执行9和线程</p>
<img src="/2020/05/26/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8A/15.png" class="" title="AbortPolicy">

<ul>
<li>CallerRunsPolicy():当线程池到达最大承载数，如果还有线程要求就会将任务返还给调用者线程执行,<strong>俗称从哪来回哪去</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy()</span><br></pre></td></tr></table></figure>

<img src="/2020/05/26/JUC%E6%8E%A2%E7%B4%A2%E4%B8%8A/16.png" class="" title="CallerRunsPolicy">

<ul>
<li>DiscardPolicy():当线程池到达最大承载数，如果还有线程要求就不执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy()</span><br></pre></td></tr></table></figure>



<ul>
<li>DiscardOldestPolicy():尝试与第一个线程争抢，争抢到就执行，争抢不到就不执行</li>
</ul>
<p><strong>总结：</strong></p>
<p><strong>这四种策略是独立无关的，是对任务拒绝处理的四中表现形式。最简单的方式就是直接丢弃任务。但是却有两种方式，到底是该丢弃哪一个任务，比如可以丢弃当前将要加入队列的任务本身（DiscardPolicy）或者丢弃任务队列中最旧任务（DiscardOldestPolicy）。丢弃最旧任务也不是简单的丢弃最旧的任务，而是有一些额外的处理。除了丢弃任务还可以直接抛出一个异常（RejectedExecutionException），这是比较简单的方式。抛出异常的方式（AbortPolicy）尽管实现方式比较简单，但是由于抛出一个RuntimeException，因此会中断调用者的处理过程。除了抛出异常以外还可以不进入线程池执行，在这种方式（CallerRunsPolicy）中任务将有调用者线程去执行。</strong> </p>
<blockquote>
<p>补充：到底如何定义多大的线程数量才合理</p>
<p>如果是IO密集型应用，则线程池大小设置为<strong>2N+1；</strong></p>
<p>如果是CPU密集型应用，则线程池大小设置为<strong>N+1</strong>；</p>
<p><strong>N代表CPU的核数</strong></p>
</blockquote>
]]></content>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>hashmap普通分析</title>
    <url>/2020/05/24/hashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>HashMap是面试的重点，要是一个HashMap能讲一个小时，估计就稳了哦（听某大佬说的）</p>
</blockquote>
<h1 id="1-提问"><a href="#1-提问" class="headerlink" title="1.提问"></a>1.提问</h1><ul>
<li><p>HashMap的初始化容量为多少?</p>
</li>
<li><p>HashMap的初始化容量又为什么是2的幂次方？</p>
</li>
<li><p>HashMap的负载因子为什么为0.75？</p>
</li>
<li><p>JDK1.7中的HashMap有什么安全隐患？</p>
</li>
<li><p>JDK1.8中的HashMap与JDK1.7中的HashMap有啥不同？</p>
<a id="more"></a>

</li>
</ul>
<h2 id="HashMap的初始化容量？"><a href="#HashMap的初始化容量？" class="headerlink" title="HashMap的初始化容量？"></a>HashMap的初始化容量？</h2><p>查看源码得知初始值为16，且<strong>MUST be a power of two.</strong> 必须是2的幂次方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure>

<h2 id="HashMap的初始化容量又为什么必须是2的幂次方？"><a href="#HashMap的初始化容量又为什么必须是2的幂次方？" class="headerlink" title="HashMap的初始化容量又为什么必须是2的幂次方？"></a>HashMap的初始化容量又为什么必须是2的幂次方？</h2><p>首先我们要知道HashMap是通过对键对象的hash值来计算要放的位置的索引的。上源码</p>
<img src="/2020/05/24/hashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png" class="" title="putval方法">

<p>因为n永远是2的次幂，所以n的二进制表达式就为100000或者1000，而n-1的二进制表达式就为11111或者111</p>
<p><strong>重点来了</strong><code>(n - 1) &amp; hash]</code>我们设置n为16，它的二进制是10000，接下来于不同的hash值做与运算</p>
<img src="/2020/05/24/hashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2.png" class="" title="hash运算">

<p>上面四种情况我们可以看出，不同的hash值，和(n-1)进行位运算后，能够得出不同的值，使得添加的元素能够均匀分布在集合中不同的位置上，避免hash碰撞。</p>
<p>下面就来看一下HashMap的容量不是2的n次幂的情况，当容量为10时，二进制为01010，(n-1)的二进制是01001，向里面添加同样的元素，结果为：</p>
<img src="/2020/05/24/hashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/3.png" class="" title="hash运算">

<p>可以看出，有三个不同的元素进过&amp;运算得出了同样的结果，严重的hash碰撞了。</p>
<p><a href="https://blog.csdn.net/apeopl/article/details/88935422" target="_blank" rel="noopener">https://blog.csdn.net/apeopl/article/details/88935422</a></p>
<p><strong>总结:HashMap的初始化容量必须是2的幂次方是为了使元素在hashmap上均匀分布，尽量避免hash碰撞</strong></p>
<h2 id="HashMap的负载因子为什么为0-75？"><a href="#HashMap的负载因子为什么为0-75？" class="headerlink" title="HashMap的负载因子为什么为0.75？"></a>HashMap的负载因子为什么为0.75？</h2><p>首先我们要明白负载因子如何影响HashMap</p>
<p>负载因子高的话，链表会增多，数组的长度会变小（空间变小），又因为链表是一个查询慢的数据结构，多了自然会影响整个hash表的查找性能。小则反之。</p>
<p>所以负载因子如果高的话，减少了空间的浪费但是增加了查找的消耗。如果负载因子小的话增加了空间的浪费但是减少了查找的消耗。</p>
<p><strong>总结：提高空间利用率和减少查询成本的折中，通过泊松分布分布分析，0.75的话hash碰撞最小，</strong></p>
<h2 id="JDK1-7中的HashMap有什么安全隐患？"><a href="#JDK1-7中的HashMap有什么安全隐患？" class="headerlink" title="JDK1.7中的HashMap有什么安全隐患？"></a>JDK1.7中的HashMap有什么安全隐患？</h2><ul>
<li>可能会形成循环链表，从而引发死锁</li>
<li>可以通过精心构造的恶意请求引发dos攻击（就是通过大量的hash值相同的值，将hash表退化为链表，这样服务器查询性能会大大降低）</li>
</ul>
<h2 id="JDK1-8中的HashMap与JDK1-7中的HashMap有啥不同？"><a href="#JDK1-8中的HashMap与JDK1-7中的HashMap有啥不同？" class="headerlink" title="JDK1.8中的HashMap与JDK1.7中的HashMap有啥不同？"></a>JDK1.8中的HashMap与JDK1.7中的HashMap有啥不同？</h2><table>
<thead>
<tr>
<th>JDK1.8中的HashMap</th>
<th>JDK1.7中的HashMap</th>
</tr>
</thead>
<tbody><tr>
<td>数组+链表/红黑书</td>
<td>数组+链表</td>
</tr>
<tr>
<td>插入元素链表尾插</td>
<td>插入元素链表头插</td>
</tr>
<tr>
<td>节点是Node</td>
<td>节点是Entry</td>
</tr>
<tr>
<td>hash算法相对简化</td>
<td>hash算法相对复杂</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的4种线程池</title>
    <url>/2020/05/23/%E5%B8%B8%E8%A7%81%E7%9A%844%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h4 id="1、newFixedThreadPool-定长线程池"><a href="#1、newFixedThreadPool-定长线程池" class="headerlink" title="1、newFixedThreadPool  定长线程池"></a>1、newFixedThreadPool  定长线程池</h4><p>一个有指定的线程数的线程池，有核心的线程，里面有固定的线程数量，响应的速度快。正规的并发线程，多用于服务器。固定的线程数由系统资源设置。核心线程是没有超时机制的，队列大小没有限制，除非线程池关闭了核心线程才会被回收。</p>
<a id="more"></a>

<h4 id="2、newCachedThreadPool-可缓冲线程池"><a href="#2、newCachedThreadPool-可缓冲线程池" class="headerlink" title="2、newCachedThreadPool 可缓冲线程池"></a>2、newCachedThreadPool 可缓冲线程池</h4><p>只有非核心线程，最大线程数很大，每新来一个任务，当没有空余线程的时候就会重新创建一个线程，这边有一个超时机制，当空闲的线程超过60s内没有用到的话，就会被回收，它可以一定程序减少频繁创建/销毁线程,减少系统开销，适用于执行时间短并且数量多的任务场景。</p>
<h4 id="3、ScheduledThreadPool-周期线程池"><a href="#3、ScheduledThreadPool-周期线程池" class="headerlink" title="3、ScheduledThreadPool  周期线程池"></a>3、ScheduledThreadPool  周期线程池</h4><p>创建一个定长线程池，支持定时及周期性任务执行，通过过schedule方法可以设置任务的周期执行</p>
<h4 id="4、newSingleThreadExecutor-单任务线程池"><a href="#4、newSingleThreadExecutor-单任务线程池" class="headerlink" title="4、newSingleThreadExecutor 单任务线程池"></a>4、newSingleThreadExecutor 单任务线程池</h4><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行，每次任务到来后都会进入阻塞队列，然后按指定顺序执行。</p>
<p>作者：维特无忧堡<br>链接：<a href="https://www.jianshu.com/p/6eb9217a2af9" target="_blank" rel="noopener">https://www.jianshu.com/p/6eb9217a2af9</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是RPC</title>
    <url>/2020/05/22/%E4%BB%80%E4%B9%88%E6%98%AFRPC/</url>
    <content><![CDATA[<h1 id="借用别人的文章《如何给老婆解释RPC》"><a href="#借用别人的文章《如何给老婆解释RPC》" class="headerlink" title="借用别人的文章《如何给老婆解释RPC》"></a>借用别人的文章《如何给老婆解释RPC》</h1><blockquote>
<p>文章后续看的不是明白，但这个故事，我笑着笑着就哭了！</p>
</blockquote>
<p>一个阳光明媚的早晨，老婆又在翻看我订阅的技术杂志。</p>
<p>“老公，什么是RPC呀，为什么你们程序员那么多黑话！”，老婆还是一如既往的好奇。<a id="more"></a></p>
<p>“RPC，就是<strong>Remote Procedure Call</strong>的简称呀，翻译成中文就是<strong>远程过程调用</strong>嘛”，我一边看着书，一边漫不经心的回答着。<br>“啥？你在说啥？谁不知道翻译成中文是什么意思？你个废柴，快给我滚去洗碗！”<br>“我去。。。”，我如梦初醒，我对面坐着的可不是一个程序员，为了不去洗碗，我瞬间调动起全部脑细胞，星辰大海在我脑中汇聚，灵感涌现……</p>
<p>“是这样，远程过程调用，自然是相对于本地过程调用来说的嘛。”<br>“嗯哼，那先给老娘讲讲，本地过程调用是啥子？”<br>“本地过程调用，就好比你现在在家里，你要想洗碗，那你直接把碗放进洗碗机，打开洗碗机开关就可以洗了。这就叫本地过程调用。”</p>
<p>“哎呦，我可不干，那啥是远程过程调用？”<br>“远程嘛，那就是你现在不在家，跟姐妹们浪去了，突然发现碗还没洗，打了个电话过来，叫我去洗碗，这就是远程过程调用啦”，多么通俗易懂的解释，我真是天才！</p>
<p>“哦！我明白了”，说着，老婆开始收拾包包。<br>“你这是干啥去哦”<br>“我？我要出门浪去呀，待会记得接收我的远程调用哦，哦不，咱们要专业点，应该说，待会记得接收我的RPC哦！”</p>
<p>后续：<a href="https://zhuanlan.zhihu.com/p/36427583" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36427583</a></p>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot自动装配原理</title>
    <url>/2020/05/16/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM初探</title>
    <url>/2020/05/16/JVM%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="面试提问"><a href="#面试提问" class="headerlink" title="面试提问"></a>面试提问</h1><ul>
<li>什么是OOM，什么是栈溢出StackOverFlowError？怎么分析？</li>
<li>JVM的常用调优参数有哪些？</li>
<li>内存的快照如何抓取，怎么分析Dump文件？知道吗？</li>
<li>谈谈JVM中，类加载器？<a id="more"></a></li>
</ul>
<h1 id="JVM探究"><a href="#JVM探究" class="headerlink" title="JVM探究"></a>JVM探究</h1><h3 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h3><img src="/2020/05/16/JVM%E5%88%9D%E6%8E%A2/3.png" class="" title="JVM位置">

<blockquote>
<p>jvm是运行class文件的虚拟进程</p>
</blockquote>
<h3 id="JVM的体系结构"><a href="#JVM的体系结构" class="headerlink" title="JVM的体系结构"></a>JVM的体系结构</h3><img src="/2020/05/16/JVM%E5%88%9D%E6%8E%A2/2.png" class="" title="JVM的体系结构">

<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>作用：加载Class文件生产Class模板</p>
<img src="/2020/05/16/JVM%E5%88%9D%E6%8E%A2/1.png" class="" title="类加载器功能">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Car car1 = <span class="keyword">new</span> Car();</span><br><span class="line">        Car car2 = <span class="keyword">new</span> Car();</span><br><span class="line">        Car car3 = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">        System.out.println(car1.hashCode());</span><br><span class="line">        System.out.println(car2.hashCode());</span><br><span class="line">        System.out.println(car3.hashCode());</span><br><span class="line"></span><br><span class="line">        Class&lt;? extends Car&gt; aClass1 = car1.getClass();</span><br><span class="line">        Class&lt;? extends Car&gt; aClass2 = car2.getClass();</span><br><span class="line">        Class&lt;? extends Car&gt; aClass3 = car3.getClass();</span><br><span class="line"></span><br><span class="line">        System.out.println(aClass1.hashCode());</span><br><span class="line">        System.out.println(aClass2.hashCode());</span><br><span class="line">        System.out.println(aClass3.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/16/JVM%E5%88%9D%E6%8E%A2/4.png" class="" title="结果">

<blockquote>
<p>有以上代码可知道，car1，car2，car3虽然是不同对象，但用的模板相同</p>
</blockquote>
<p>java默认的三种类加载器</p>
<p><strong>启动类加载器(Bootstrap classLoader):又称为引导类加载器，由C++编写，无法通过程序得到。主要负责加载JAVA中的 一些核心类库，主要是位于<JAVA_HOME>/lib/rt.jar中。</strong></p>
<p><strong>拓展类加载器(Extension classLoader):主要加载JAVA中的一些拓展类，位于<JAVA_HOME>/lib/ext中,是启动类加载器的子类。</strong></p>
<p><strong>系统类加载器(AppClassLoader)</strong>：<strong>加载当前应用的classpath的所有类</strong></p>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>什么是双亲委派机制：</p>
<p><strong>当一个类向自己的类加载器发送加载请求的时候，这个类加载器会先去委托上一级类加载器加载类，依次递归，直到委托启动类加载器(Bootstrap classLoader)，如果上一级没有这个类，便会允许下一级加载，直到找能加载这个类的加载器未知。</strong></p>
<img src="/2020/05/16/JVM%E5%88%9D%E6%8E%A2/5.png" class="" title="双亲委派机制">

<p>这种机制就好比：一个普通百姓打一个大官司，当地官员觉得事情大，先请示上级，上级又觉得事情大，要先请示上级，直到请示到皇上，但是皇上说，我不管，你们看着办，就又扔给下级，下级也不管，依次递归，直到一个想管的官员出现。</p>
<p>双亲委派机制的作用和好处：防止重复加载同一个<code>.class</code>，保证核心<code>.class</code>不能被篡改。</p>
<h3 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当方法被native修饰的时候，意味着调用本地方法（本地方法可能是c，或者其他语言写的，java程序不能直接调用）。</p>
</blockquote>
<p>过程：</p>
<ul>
<li>将方法压入本地方法栈</li>
<li>本地方法栈调用本地方法接口JNI</li>
<li>JNI调用本地方法库</li>
</ul>
<img src="/2020/05/16/JVM%E5%88%9D%E6%8E%A2/6.png" class="" title="过程">

<p>为什么会有这种机制：</p>
<p>在java刚出来的时候，流行的是C和C++，为了抢夺市场就不得不融合其他语言，扩展功能。所以就出现了这种机制。</p>
<p><strong>好处：可融合其他语言，增强了java的功能扩展</strong></p>
<p>趋势：现在用Native的越来越少了，除了硬件功能的调用如java程序驱动打印机还在使用，在企业级应用中都很少见了</p>
<p>因为现在异构领域的通信都很发达，如Socket等。</p>
<h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><p>每个线程都有一个程序计数器，是线程私有的,就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区被所有线程共享，它存放了类信息，静态变量，和常量池，但是实例变量任然存在堆中，与类无关</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">"ky"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/16/JVM%E5%88%9D%E6%8E%A2/7.png" class="" title="第一种">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String s1=<span class="string">"abc"</span>;</span><br><span class="line">    String s2=<span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">    String s3=s2.intern();</span><br><span class="line"></span><br><span class="line">    System.out.println(s1==s2);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s1==s3);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/16/JVM%E5%88%9D%E6%8E%A2/8.png" class="" title="第二种">

<blockquote>
<p>intern方法，这个方法首先在常量池中查找是否存在一份equal相等的字符串如果有的话就返回该字符串的引用，没有的话就将它加入到字符串常量池中。</p>
</blockquote>
<h3 id="java虚拟栈"><a href="#java虚拟栈" class="headerlink" title="java虚拟栈"></a>java虚拟栈</h3><p>在java中，栈主管程序的运行，一个栈对应一个线程，栈生命周期与程序的线程相同。<strong>对于栈来说，不存在垃圾回收</strong>。栈中存放了基本数据类型，和引用数据类型的引用地址，以及方法的引用</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈的功能和特点类似于虚拟机栈，均具有线程隔离的特点以及都能抛出StackOverflowError和OutOfMemoryError异常。本地方法栈服务的对象是JVM执行的native方法。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆主要存放类实例化的真实对象。堆里面又分为新生代，老年代，和永久代（jdk1.8后改为元空间），垃圾回收主要发生在新生代和老年代。</p>
<h3 id="新生代，老年代，永久代（元空间）"><a href="#新生代，老年代，永久代（元空间）" class="headerlink" title="新生代，老年代，永久代（元空间）"></a>新生代，老年代，永久代（元空间）</h3><p>新生代：一般对象的诞生的地方</p>
<p>老年代：对象躲过15次GC（一般默认15次，可以自己设置）之后进入的地方</p>
<p>永久代（元空间）：java8后用元空间替代了永久代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存</strong>。</p>
<img src="/2020/05/16/JVM%E5%88%9D%E6%8E%A2/9.png" class="" title="堆模型">

<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>在jvm中一般将GC分为三种类：<strong>新生代 GC（Minor GC），老年代 GC（Major GC），全局 Full GC</strong></p>
<p>Minor GC指新生代GC，即发生在新生代（包括Eden区和Survivor区）的垃圾回收操作，当新生代无法为新生对象分配内存空间的时候，会触发Minor GC。因为新生代中大多数对象的生命周期都很短，所以发生Minor GC的频率很高，虽然它会触发stop-the-world，但是它的回收速度很快。</p>
<p>Major GC清理Tenured区，用于回收老年代，出现Major GC通常会出现至少一次Minor GC。</p>
<p>Full GC是针对整个新生代、老生代、元空间（metaspace，java8以上版本取代perm gen）的全局范围的GC</p>
<ol>
<li><p>常用算法</p>
<ul>
<li>引用计数法</li>
<li>标记清除法</li>
<li>复制算法</li>
<li>标记压缩算法</li>
</ul>
<p><a href="https://www.bilibili.com/video/BV1iJ411d7jS?p=13具体的算法讲解在p10-p13" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1iJ411d7jS?p=13具体的算法讲解在p10-p13</a></p>
</li>
</ol>
<h3 id="JMM浅谈"><a href="#JMM浅谈" class="headerlink" title="JMM浅谈"></a>JMM浅谈</h3><ol>
<li><p>什么是JMM</p>
<p>​    JMM是Java Memory Model（java内存模型）的缩写</p>
</li>
<li><p>为什么需要它，它的作用是什么</p>
<p>首先我们要明白在java中只有一个主内存，线程要从主内存中复制一份当作工作内存使用。</p>
<img src="/2020/05/16/JVM%E5%88%9D%E6%8E%A2/10.png" class="" title="内存">

<p>如图所示。当其他线程中的数据改变的时候，导致了数据的不一致性</p>
<p>而JMM就是为了解决这个问题，<strong>它类似缓存一致性协议，是用于定义数据读写的规则</strong></p>
</li>
</ol>
<h3 id="深究JVM"><a href="#深究JVM" class="headerlink" title="深究JVM"></a>深究JVM</h3><p><a href="https://www.bilibili.com/video/BV1PJ411n7xZ?from=search&amp;seid=7159976456518541220" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1PJ411n7xZ?from=search&amp;seid=7159976456518541220</a></p>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件事件绑定Vue实例事件</title>
    <url>/2020/05/12/Vue%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9AVue%E5%AE%9E%E4%BE%8B%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p><strong>首先，我们要知道Vue中的组件不能直接绑定Vue实例的事件，只能间接的绑定</strong><a id="more"></a></p>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>vue9<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">todiv</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">totitle</span> <span class="attr">slot</span>=<span class="string">"totitle"</span> <span class="attr">:title</span>=<span class="string">"tilte"</span>&gt;</span><span class="tag">&lt;/<span class="name">totitle</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">todata</span> <span class="attr">slot</span>=<span class="string">"todata"</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in items"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">:item</span>=<span class="string">"item"</span> <span class="attr">:index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">v-on:remove</span>=<span class="string">"removeItem(index)"</span> &gt;</span><span class="tag">&lt;/<span class="name">todata</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">todiv</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    Vue.component(<span class="string">"todiv"</span>, &#123;</span></span><br><span class="line"><span class="actionscript">        template: <span class="string">'&lt;div&gt;'</span> +</span></span><br><span class="line"><span class="handlebars"><span class="xml">            '<span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"totitle"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span>' +</span></span></span><br><span class="line"><span class="actionscript">            <span class="string">'&lt;ul&gt;'</span> +</span></span><br><span class="line"><span class="handlebars"><span class="xml">            '<span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"todata"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span>' +</span></span></span><br><span class="line"><span class="actionscript">            <span class="string">'&lt;/ul&gt;'</span> +</span></span><br><span class="line"><span class="actionscript">            <span class="string">'&lt;/div&gt;'</span></span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">    Vue.component(<span class="string">"totitle"</span>, &#123;</span></span><br><span class="line"><span class="actionscript">        props: [<span class="string">'tilte'</span>],</span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123;tilte&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    Vue.component(<span class="string">"todata"</span>, &#123;</span></span><br><span class="line"><span class="actionscript">        props: [<span class="string">'item'</span>,<span class="string">'index'</span>],</span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: '<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><span class="template-variable">&#123;&#123;item&#125;&#125;</span><span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"remove"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>',</span></span></span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="actionscript">            remove:<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.$emit(<span class="string">'remove'</span>)<span class="comment">//触发自定义事件</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">"#app"</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            tilte: <span class="string">"ky写java"</span>,</span></span><br><span class="line"><span class="actionscript">            items: [<span class="string">"java"</span>, <span class="string">"运维"</span>, <span class="string">"linux"</span>]</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="actionscript">            removeItem:<span class="function"><span class="keyword">function</span> <span class="params">(index)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"删除了"</span>+index)</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.items.splice(index,<span class="number">1</span>)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>组件布局</li>
</ul>
<img src="/2020/05/12/Vue%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9AVue%E5%AE%9E%E4%BE%8B%E7%BB%84%E4%BB%B6/1.png" class="" title="组件布局">

<ul>
<li>自定义事件分发绑定</li>
</ul>
<img src="/2020/05/12/Vue%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9AVue%E5%AE%9E%E4%BE%8B%E7%BB%84%E4%BB%B6/2.png" class="" title="自定义事件分发绑定">]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>基本类型和引用类型传参区别</title>
    <url>/2020/05/11/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="基本数据类型和引用数据类型作为参数的区别"><a href="#基本数据类型和引用数据类型作为参数的区别" class="headerlink" title="基本数据类型和引用数据类型作为参数的区别"></a>基本数据类型和引用数据类型作为参数的区别</h1><p>基本数据类型的变量中直接存放数据值本身，所以改的时候改的是数据值本身；<br>但是引用类型不同的地方在于真正的数据并没有在栈区的变量中保存，而是在堆区里面保存着，所以虽然也拷贝了一份，也是副本，但是二者指向的是同一块堆区。</p>
<a id="more"></a>

<blockquote>
<p>引用数据类型就好比如说，两位同学使用的是同一份复习资料，其中一人把资料撕毁了，另一人当然也会受到影响。<br>而基本数据类型就好比复印了一份，其中一人将自己的资料撕了，并不影响别人。</p>
</blockquote>
<h2 id="1、当使用基本类型作为方法的参数时候，在方法体中对形参的修改不会影响到实际参数"><a href="#1、当使用基本类型作为方法的参数时候，在方法体中对形参的修改不会影响到实际参数" class="headerlink" title="1、当使用基本类型作为方法的参数时候，在方法体中对形参的修改不会影响到实际参数"></a>1、当使用基本类型作为方法的参数时候，在方法体中对形参的修改不会影响到实际参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">        doSomething(a);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">      b=<span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/11/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82%E5%8C%BA%E5%88%AB/5.png" class="" title="结果">

<p>基本变量的传递就是复制了一份，操作复制的值并不会影响原来的值</p>
<h2 id="2、当使用引用类型作为方法参数的时候，在方法体中对形参指向的内容修改，则会影响实际参数"><a href="#2、当使用引用类型作为方法参数的时候，在方法体中对形参指向的内容修改，则会影响实际参数" class="headerlink" title="2、当使用引用类型作为方法参数的时候，在方法体中对形参指向的内容修改，则会影响实际参数"></a>2、当使用引用类型作为方法参数的时候，在方法体中对形参指向的内容修改，则会影响实际参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> arr[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">       arr[<span class="number">0</span>]=<span class="number">100</span>;</span><br><span class="line">        doSomething(arr);</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span>[] integer)</span> </span>&#123;</span><br><span class="line">      integer[<span class="number">0</span>]=<span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/11/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82%E5%8C%BA%E5%88%AB/1.png" class="" title="结果">

<img src="/2020/05/11/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82%E5%8C%BA%E5%88%AB/2.png" class="" title="分析">

<h2 id="3、当使用引用类型作为方法参数的时候，在方法体中对形参指向修改，则不会影响实际参数"><a href="#3、当使用引用类型作为方法参数的时候，在方法体中对形参指向修改，则不会影响实际参数" class="headerlink" title="3、当使用引用类型作为方法参数的时候，在方法体中对形参指向修改，则不会影响实际参数"></a>3、当使用引用类型作为方法参数的时候，在方法体中对形参指向修改，则不会影响实际参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> arr[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">       arr[<span class="number">0</span>]=<span class="number">100</span>;</span><br><span class="line">        doSomething(arr);</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span>[] integer)</span> </span>&#123;</span><br><span class="line">      integer=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">      integer[<span class="number">0</span>]=<span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/11/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82%E5%8C%BA%E5%88%AB/3.png" class="" title="结果">

<img src="/2020/05/11/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82%E5%8C%BA%E5%88%AB/4.png" class="" title="分析">]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传和下载</title>
    <url>/2020/05/10/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<blockquote>
<p>准备工作</p>
</blockquote>
<p> 转载与：[狂神说]</p>
<p>文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。</p>
<a id="more"></a>

<p>前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器；</p>
<p><strong>对表单中的 enctype 属性做个详细的说明：</strong></p>
<ul>
<li>application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。</li>
<li>multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。</li>
<li>text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">""</span> enctype=<span class="string">"multipart/form-data"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">   &lt;input type=<span class="string">"file"</span> name=<span class="string">"file"</span>/&gt;</span><br><span class="line">   &lt;input type=<span class="string">"submit"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>一旦设置了enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的HTTP响应。在2003年，Apache Software Foundation发布了开源的Commons FileUpload组件，其很快成为Servlet/JSP程序员上传文件的最佳选择。</p>
<ul>
<li>Servlet3.0规范已经提供方法来处理文件上传，但这种上传需要在Servlet中完成。</li>
<li>而Spring MVC则提供了更简单的封装。</li>
<li>Spring MVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的。</li>
<li>Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类：</li>
<li>CommonsMultipartResolver。因此，SpringMVC的文件上传还需要依赖Apache Commons FileUpload的组件。</li>
</ul>
<blockquote>
<p>文件上传</p>
</blockquote>
<p>1、导入文件上传的jar包，commons-fileupload ， Maven会自动帮我们导入他的依赖包 commons-io包；</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--文件上传--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.3.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--servlet-api导入高版本的--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;4.0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2、配置bean：multipartResolver</p>
<p>【<strong>注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！</strong>】</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--文件上传配置--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"multipartResolver"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span><br><span class="line">   &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-<span class="number">8859</span>-<span class="number">1</span> --&gt;</span><br><span class="line">   &lt;property name=<span class="string">"defaultEncoding"</span> value=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">   &lt;!-- 上传文件大小上限，单位为字节（<span class="number">10485760</span>=<span class="number">10</span>M） --&gt;</span><br><span class="line">   &lt;property name=<span class="string">"maxUploadSize"</span> value=<span class="string">"10485760"</span>/&gt;</span><br><span class="line">   &lt;property name=<span class="string">"maxInMemorySize"</span> value=<span class="string">"40960"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>CommonsMultipartFile 的 常用方法：</p>
<ul>
<li><p><strong>String getOriginalFilename()：获取上传文件的原名</strong></p>
</li>
<li><p><strong>InputStream getInputStream()：获取文件流</strong></p>
</li>
<li><p><strong>void transferTo(File dest)：将上传文件保存到一个目录文件中</strong></p>
<p>我们去实际测试一下</p>
</li>
</ul>
<p>3、编写前端页面</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">"/upload"</span> enctype=<span class="string">"multipart/form-data"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line"> &lt;input type=<span class="string">"file"</span> name=<span class="string">"file"</span>/&gt;</span><br><span class="line"> &lt;input type=<span class="string">"submit"</span> value=<span class="string">"upload"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>4、<strong>Controller</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.commons.CommonsMultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line">   <span class="comment">//@RequestParam("file") 将name=file控件得到的文件封装成CommonsMultipartFile 对象</span></span><br><span class="line">   <span class="comment">//批量上传CommonsMultipartFile则为数组即可</span></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/upload"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">fileUpload</span><span class="params">(@RequestParam(<span class="string">"file"</span>)</span> CommonsMultipartFile file ,HttpServletRequest request) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取文件名 : file.getOriginalFilename();</span></span><br><span class="line">       String uploadFileName = file.getOriginalFilename();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//如果文件名为空，直接回到首页！</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="string">""</span>.equals(uploadFileName))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"redirect:/index.jsp"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       System.out.println(<span class="string">"上传文件名 : "</span>+uploadFileName);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//上传路径保存设置</span></span><br><span class="line">       String path = request.getServletContext().getRealPath(<span class="string">"/upload"</span>);</span><br><span class="line">       <span class="comment">//如果路径不存在，创建一个</span></span><br><span class="line">       File realPath = <span class="keyword">new</span> File(path);</span><br><span class="line">       <span class="keyword">if</span> (!realPath.exists())&#123;</span><br><span class="line">           realPath.mkdir();</span><br><span class="line">      &#125;</span><br><span class="line">       System.out.println(<span class="string">"上传文件保存地址："</span>+realPath);</span><br><span class="line"></span><br><span class="line">       InputStream is = file.getInputStream(); <span class="comment">//文件输入流</span></span><br><span class="line">       OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(realPath,uploadFileName));<span class="comment">//文件输出流</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//读取写出</span></span><br><span class="line">       <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">       <span class="keyword">while</span> ((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">           os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">           os.flush();</span><br><span class="line">      &#125;</span><br><span class="line">       os.close();</span><br><span class="line">       is.close();</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"redirect:/index.jsp"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、测试上传文件，OK！</p>
<p><strong>采用file.Transto 来保存上传的文件</strong></p>
<p>1、编写Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 采用file.Transto 来保存上传的文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/upload2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String  <span class="title">fileUpload2</span><span class="params">(@RequestParam(<span class="string">"file"</span>)</span> CommonsMultipartFile file,HttpServletRequest request) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//上传路径保存设置</span></span><br><span class="line">   String path = request.getServletContext().getRealPath(<span class="string">"/upload"</span>);</span><br><span class="line">   File realPath = <span class="keyword">new</span> File(path);</span><br><span class="line">   <span class="keyword">if</span> (!realPath.exists())&#123;</span><br><span class="line">       realPath.mkdir();</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//上传文件地址</span></span><br><span class="line">   System.out.println(<span class="string">"上传文件保存地址："</span>+realPath);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//通过CommonsMultipartFile的方法直接写文件（注意这个时候）</span></span><br><span class="line">   file.transferTo(<span class="keyword">new</span> File(realPath +<span class="string">"/"</span>+ file.getOriginalFilename()));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="string">"redirect:/index.jsp"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、前端表单提交地址修改</p>
<p>3、访问提交测试，OK！</p>
<blockquote>
<p>文件下载</p>
</blockquote>
<p><strong>文件下载步骤：</strong></p>
<p>1、设置 response 响应头</p>
<p>2、读取文件 – InputStream</p>
<p>3、写出文件 – OutputStream</p>
<p>4、执行操作</p>
<p>5、关闭流 （先开后关）</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/download"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">downloads</span><span class="params">(HttpServletResponse response ,HttpServletRequest request)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">   <span class="comment">//要下载的图片地址</span></span><br><span class="line">   String  path = request.getServletContext().getRealPath(<span class="string">"/upload"</span>);</span><br><span class="line">   String  fileName = <span class="string">"基础语法.jpg"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1、设置response 响应头</span></span><br><span class="line">   response.reset(); <span class="comment">//设置页面不缓存,清空buffer</span></span><br><span class="line">   response.setCharacterEncoding(<span class="string">"UTF-8"</span>); <span class="comment">//字符编码</span></span><br><span class="line">   response.setContentType(<span class="string">"multipart/form-data"</span>); <span class="comment">//二进制传输数据</span></span><br><span class="line">   <span class="comment">//设置响应头</span></span><br><span class="line">   response.setHeader(<span class="string">"Content-Disposition"</span>,</span><br><span class="line">           <span class="string">"attachment;fileName="</span>+URLEncoder.encode(fileName, <span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line">   File file = <span class="keyword">new</span> File(path,fileName);</span><br><span class="line">   <span class="comment">//2、 读取文件--输入流</span></span><br><span class="line">   InputStream input=<span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">   <span class="comment">//3、 写出文件--输出流</span></span><br><span class="line">   OutputStream out = response.getOutputStream();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">byte</span>[] buff =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">   <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">   <span class="comment">//4、执行 写出操作</span></span><br><span class="line">   <span class="keyword">while</span>((index= input.read(buff))!= -<span class="number">1</span>)&#123;</span><br><span class="line">       out.write(buff, <span class="number">0</span>, index);</span><br><span class="line">       out.flush();</span><br><span class="line">  &#125;</span><br><span class="line">   out.close();</span><br><span class="line">   input.close();</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;a href="/download"&gt;点击下载&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>测试，文件下载OK，大家可以和我们之前学习的JavaWeb原生的方式对比一下，就可以知道这个便捷多了!</p>
]]></content>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>有关流的细节</title>
    <url>/2020/05/09/%E6%9C%89%E5%85%B3%E6%B5%81%E7%9A%84%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<h1 id="1-flush-与close的区别"><a href="#1-flush-与close的区别" class="headerlink" title="1.flush()与close的区别"></a>1.flush()与close的区别</h1><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p>
<a id="more"></a>

<ul>
<li><code>flush</code> ：刷新缓冲区到目的文件，流对象可以继续使用。</li>
<li><code>close</code>:先刷新缓冲区到目的文件，然后通知系统释放资源。流对象不可以再被使用了。</li>
</ul>
<h1 id="2-流体系"><a href="#2-流体系" class="headerlink" title="2.流体系"></a>2.流体系</h1><img src="/2020/05/09/%E6%9C%89%E5%85%B3%E6%B5%81%E7%9A%84%E7%BB%86%E8%8A%82/1.png" class="" title="流体系">

<h2 id="2-1-缓冲流概述"><a href="#2-1-缓冲流概述" class="headerlink" title="2.1 .缓冲流概述"></a>2.1 .缓冲流概述</h2><p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p>
<ul>
<li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li>
<li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li>
</ul>
<p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p>
<h2 id="2-3-转换流"><a href="#2-3-转换流" class="headerlink" title="2.3.转换流"></a>2.3.转换流</h2>

<p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<h2 id="2-4-序列化"><a href="#2-4-序列化" class="headerlink" title="2.4.序列化"></a>2.4.序列化</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化</p>


<h2 id="2-5-补充java转义"><a href="#2-5-补充java转义" class="headerlink" title="2.5.补充java转义"></a>2.5.补充java转义</h2><ul>
<li>为什么需要转义：避免二义性，因为java不认识你这个是字符串，还是特殊字符</li>
<li>转义符号:\</li>
</ul>
<p>在Java中，不管是String.split()，还是正则表达式，有一些特殊字符需要转义，</p>
<p>这些字符是</p>
<p><strong><em>\</em>(   [   {   /   ^   -   $   ¦   }   ]   )   ?   *   +   .**</strong> </p>
<h2 id="2-6-排序练习"><a href="#2-6-排序练习" class="headerlink" title="2.6.排序练习"></a>2.6.排序练习</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.这次指导，意义绝不局限在内蒙古一地，对于各地区各部门深入开展主题教育、抓好落实抓出成效都具有十分重要的示范效应，可以说是一堂生动的“公开课”&amp;</span><br><span class="line">4.所谓抓“四个到位”，一是抓思想认识到位，二是抓检视问题到位，三是抓整改落实到位，四是抓组织领导到位。主题教育要取得实际效果，解决实质问题，习近平强调的抓“四个到位”至关重要&amp;</span><br><span class="line">3.不忘初心、牢记使命，思想认识到位是重要前提，思想不深刻认识不到位，就不能直抵灵魂、触及根源；检视问题到位是重要基础，如果搞不清问题是什么、症结在哪里，就拿不出实招、硬招；整改落实到位是成效保障，做不到立查立改、即知即改、盯住不放地改，就成了讲空话、务虚功；组织领导到位是责任保障，各级党委（党组）、主要领导同志组织领导作用发挥得好不好，结果大不一样。只有四个方面都抓到位，主题教育才能取得实效&amp;</span><br><span class="line">1.习近平对如何抓“四个到位”一一作出深入阐述：&amp;</span><br><span class="line">6.抓思想认识到位——把学习贯穿始终，不断深化对主题教育重大意义的认识，深化对党的初心和使命的认识，深化对党面临的风险考验的认识&amp;</span><br><span class="line">5.抓检视问题到位——深入调查研究，把问题找到找准，把根源挖深，明确努力方向和改进措施&amp;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-1仅使用FileReader和FileWriter"><a href="#2-6-1仅使用FileReader和FileWriter" class="headerlink" title="2.6.1仅使用FileReader和FileWriter"></a>2.6.1仅使用FileReader和FileWriter</h3><p>分析：</p>
<ul>
<li>先将读取的数据接受</li>
<li>根据&amp;分段</li>
<li>根据.分割</li>
<li>写入hashmap</li>
<li>再排序写出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: workspace_idea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Kuang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-05-08 22:17</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoDemo10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File file1 = <span class="keyword">new</span> File(<span class="string">"ky\\1.txt"</span>);</span><br><span class="line">        File file2 = <span class="keyword">new</span> File(<span class="string">"ky\\2.txt"</span>);</span><br><span class="line"></span><br><span class="line">        FileReader fileReader = <span class="keyword">new</span> FileReader(file1);</span><br><span class="line">        FileWriter fileWriter = <span class="keyword">new</span> FileWriter(file2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个StringBuffer接受读取</span></span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">//用hashMap存储</span></span><br><span class="line">        HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> buf[]=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len=fileReader.read(buf))!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stringBuffer=stringBuffer.append(buf);</span><br><span class="line">            <span class="comment">//一行结束</span></span><br><span class="line">            <span class="keyword">if</span> (stringBuffer.toString().endsWith(<span class="string">"&amp;"</span>))</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//System.out.println(stringBuffer.toString());</span></span><br><span class="line">                <span class="comment">//分割一行的序号和段子</span></span><br><span class="line">                String[] split = stringBuffer.toString().split(<span class="string">"\\."</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//操，为啥分割第一个会有换行符号？测试代码不用管</span></span><br><span class="line">                System.out.print(split[<span class="number">0</span>].toString().replaceAll(<span class="string">"\r\n"</span>,<span class="string">""</span>)+<span class="string">"."</span>);</span><br><span class="line">                System.out.println(split[<span class="number">1</span>]);</span><br><span class="line">                </span><br><span class="line">                hashMap.put(split[<span class="number">0</span>].toString().replaceAll(<span class="string">"\r\n"</span>,<span class="string">""</span>),split[<span class="number">1</span>]);</span><br><span class="line">                <span class="comment">//清空</span></span><br><span class="line">                stringBuffer.delete(<span class="number">0</span>,stringBuffer.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; keySet = hashMap.keySet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=hashMap.size();i++) &#123;</span><br><span class="line">            String key=String.valueOf(i);</span><br><span class="line">           fileWriter.write(key+<span class="string">"."</span>+hashMap.get(key)+<span class="string">"\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写数据</span></span><br><span class="line">        fileReader.close();</span><br><span class="line">        fileWriter.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我擦，我要骂娘，为啥split[0]会带一个换行符号，搞了半天，头都晕了，我估计是StringBuffer的原因。</p>
</blockquote>
<h3 id="2-6-2使用BufferedReader和BufferedWriter"><a href="#2-6-2使用BufferedReader和BufferedWriter" class="headerlink" title="2.6.2使用BufferedReader和BufferedWriter"></a>2.6.2使用BufferedReader和BufferedWriter</h3><p>分析：</p>
<ul>
<li>使用BufferedReader的readLine方法读取一行</li>
<li>根据.分割每一行</li>
<li>用hashmap存储</li>
<li>再排序写出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: workspace_idea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Kuang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-05-08 21:05</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoDemo09</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        File file1 = <span class="keyword">new</span> File(<span class="string">"ky\\1.txt"</span>);</span><br><span class="line">        File file2 = <span class="keyword">new</span> File(<span class="string">"ky\\2.txt"</span>);</span><br><span class="line"></span><br><span class="line">        FileReader fileReader = <span class="keyword">new</span> FileReader(file1);</span><br><span class="line">        FileWriter fileWriter = <span class="keyword">new</span> FileWriter(file2);</span><br><span class="line"></span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">        BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(fileWriter);</span><br><span class="line"></span><br><span class="line">        String s=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        <span class="keyword">while</span> ((s=bufferedReader.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="comment">//每读取一行，分割一行</span></span><br><span class="line">            String[] split = s.split(<span class="string">"\\."</span>);</span><br><span class="line">            hashMap.put(split[<span class="number">0</span>],split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=hashMap.size() ; i++) &#123;</span><br><span class="line">            String key=String.valueOf(i);</span><br><span class="line">            String value = hashMap.get(key);</span><br><span class="line">            bufferedWriter.write(key+<span class="string">"."</span>+value);</span><br><span class="line">            bufferedWriter.newLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM配置文件整合</title>
    <url>/2020/05/08/SSM%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<p>代码贴多了也累，这次就画一个图吧</p>
<a id="more"></a>

<img src="/2020/05/08/SSM%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%95%B4%E5%90%88/1.png" class="" title="ssm">]]></content>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>out中的lib没有jar包的问题</title>
    <url>/2020/05/07/out%E4%B8%AD%E7%9A%84lib%E6%B2%A1%E6%9C%89jar%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在idea中的out目录中我们可以看到部署到tomcat的web项目</p>
<a id="more"></a>

<img src="/2020/05/07/out%E4%B8%AD%E7%9A%84lib%E6%B2%A1%E6%9C%89jar%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98/1.png" class="" title="结构">

<p>有时候我们明明通过maven配置了相关的jar包，但部署到tomcat的项目的lib下却没有</p>
<p>如下：</p>
<img src="/2020/05/07/out%E4%B8%AD%E7%9A%84lib%E6%B2%A1%E6%9C%89jar%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98/2.png" class="" title="maven">

<p>甚至连lib都没有</p>
<img src="/2020/05/07/out%E4%B8%AD%E7%9A%84lib%E6%B2%A1%E6%9C%89jar%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98/3.png" class="" title="lib">

<p>这时候我们就要打开Project Settings-&gt;Artifacts</p>
<p>选择没有lib的项目点击创建</p>
 <img src="/2020/05/07/out%E4%B8%AD%E7%9A%84lib%E6%B2%A1%E6%9C%89jar%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98/4.png" class="" title="lib">

<p>导入jar包</p>
 <img src="/2020/05/07/out%E4%B8%AD%E7%9A%84lib%E6%B2%A1%E6%9C%89jar%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98/5.png" class="" title="jar">

<p>再次启动tomcat或者idea就能看到lib和里面的jar包了</p>
<img src="/2020/05/07/out%E4%B8%AD%E7%9A%84lib%E6%B2%A1%E6%9C%89jar%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98/6.png" class="" title="出现了">]]></content>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么web-inf下的资源不能重定向</title>
    <url>/2020/05/06/%E4%B8%BA%E4%BB%80%E4%B9%88web-inf%E4%B8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E4%B8%8D%E8%83%BD%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    <content><![CDATA[<h1 id="为什么web-inf下的资源不能重定向"><a href="#为什么web-inf下的资源不能重定向" class="headerlink" title="为什么web-inf下的资源不能重定向?"></a>为什么web-inf下的资源不能重定向?</h1><blockquote>
<p>最近学springmvc，突然记起这个问题，但一直没知道原理，今天就在网上查了一下</p>
</blockquote>
<a id="more"></a>

<ol>
<li>首先web-inf下的内容只能服务器级别才能访问,而客户端级别是不能访问的。</li>
<li>然后我们再来解释一下请求转发和重定向</li>
</ol>
<ul>
<li>请求转发</li>
</ul>
<p>就比如：我们设计好了一个项目，然后找A公司实现，A公司不会做，但他偷偷找外包B公司来做。到最后，我们以为是A公司做的，就对外宣传这是A公司做的。（所以我们就相当于只对A发 送了一次请求，URL地址栏里依然是A公司）。</p>
<img src="/2020/05/06/%E4%B8%BA%E4%BB%80%E4%B9%88web-inf%E4%B8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E4%B8%8D%E8%83%BD%E9%87%8D%E5%AE%9A%E5%90%91/1.png" class="" title="请求转发">

<p>简单来说请求转发是在服务器内部转发，这是属于服务器的行为。</p>
<ul>
<li>重定向：</li>
</ul>
<p>同样是找A公司，但他不会偷偷找外包了而是接着告诉我们去找B公司。（所以我们就发送了两次请求，URL地址栏里就变成了B公司）</p>
<img src="/2020/05/06/%E4%B8%BA%E4%BB%80%E4%B9%88web-inf%E4%B8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E4%B8%8D%E8%83%BD%E9%87%8D%E5%AE%9A%E5%90%91/2.png" class="" title="重定向">

<p>重定向就是通过客户端转发，是属于客户端行为</p>
<p><strong>总结：</strong></p>
<p><strong>因为重定向属于客户端行为，而web-inf下的内容只能服务器级别才能访问，所以web-inf下的资源不能重定向</strong></p>
<h1 id="补充：有关form表单的action属性开头加-与不加-的区别"><a href="#补充：有关form表单的action属性开头加-与不加-的区别" class="headerlink" title="补充：有关form表单的action属性开头加/与不加/的区别"></a>补充：有关form表单的action属性开头加/与不加/的区别</h1><p>设置tomcat的url：</p>
<img src="/2020/05/06/%E4%B8%BA%E4%BB%80%E4%B9%88web-inf%E4%B8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E4%B8%8D%E8%83%BD%E9%87%8D%E5%AE%9A%E5%90%91/3.png" class="" title="url">

<ul>
<li>第一种开头不加：</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">"user/test1"</span> method=<span class="string">"post"</span>&gt;</span><br></pre></td></tr></table></figure>

<p>​    请求的地址栏为：</p>
<p>​    <img src="/2020/05/06/%E4%B8%BA%E4%BB%80%E4%B9%88web-inf%E4%B8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E4%B8%8D%E8%83%BD%E9%87%8D%E5%AE%9A%E5%90%91/4.png" class="" title="地址栏"></p>
<ul>
<li>第二种加/</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">"/user/test1"</span> method=<span class="string">"post"</span>&gt;</span><br></pre></td></tr></table></figure>

<p>​    请求的地址栏为：</p>
<p>​    <img src="/2020/05/06/%E4%B8%BA%E4%BB%80%E4%B9%88web-inf%E4%B8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E4%B8%8D%E8%83%BD%E9%87%8D%E5%AE%9A%E5%90%91/5.png" class="" title="地址栏"></p>
<p><strong>分析总结</strong>：第一种不加/会在当前部署好的项目下查找资源，第二种加/则会在tomcat根路径下查找资源</p>
]]></content>
      <tags>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC的原理</title>
    <url>/2020/05/06/SpringMVC%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="1、SpringMVC演示"><a href="#1、SpringMVC演示" class="headerlink" title="1、SpringMVC演示"></a>1、SpringMVC演示</h1><ul>
<li><p>导入包</p>
<a id="more"></a>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：这里我们先导入Controller接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//ModelAndView 模型和视图</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装对象，放在ModelAndView中。Model</span></span><br><span class="line">        mv.addObject(<span class="string">"msg"</span>,<span class="string">"HelloSpringMVC!"</span>);</span><br><span class="line">        <span class="comment">//封装要跳转的视图，放在ModelAndView中</span></span><br><span class="line">        mv.setViewName(<span class="string">"hello"</span>); <span class="comment">//: /WEB-INF/jsp/hello.jsp</span></span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建spring-servlet-xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--注册HandlerMapping和HandlerAdapter--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="attr">id</span>=<span class="string">"InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--前缀--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--后缀--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Handler--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"/hello"</span> <span class="attr">class</span>=<span class="string">"com.ky.controller.HelloController"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注册DispatcherServlet</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.注册DispatcherServlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--启动级别-1 跟随服务器启动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建jsp</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;ky&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">$&#123;msg&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/06/SpringMVC%E7%9A%84%E5%8E%9F%E7%90%86/1.png" class="" title="结果">

</li>
</ul>
<h1 id="2、图解原理"><a href="#2、图解原理" class="headerlink" title="2、图解原理"></a>2、图解原理</h1><img src="/2020/05/06/SpringMVC%E7%9A%84%E5%8E%9F%E7%90%86/2.png" class="" title="图解原理">

<ul>
<li>1.<strong>DispatcherServlet</strong>拦截用户请求</li>
<li>2.3.4.<strong>HandlerMapping</strong>作用是根据当前请求的找到对应的Handler处理器</li>
<li>5.6.<strong>HandlerAdapter</strong>找到具体的Controller并让其执行</li>
<li>7.8.<strong>Controller</strong>将具体的执行信息返回给DispatcherServlet,如ModelAndView</li>
<li>9.10.<strong>DispatcherServlet</strong>调用视图解析器处理传过来的逻辑视图名后，调用具体视图返回</li>
<li>11.最终视图呈现给用户</li>
</ul>
<p>对于<strong>HandlerMapping</strong>和<strong>HandlerAdapter</strong>个人理解是：HandlerMapping是根据url找到对应的处理器名字，</p>
<p>比如：<a href="http://localhost:8080/SpringMVCDemo02/hello" target="_blank" rel="noopener">http://localhost:8080/SpringMVCDemo02/hello</a> 找的就是/hello。</p>
<p>HandlerAdapter则是找到具体的处理器。</p>
<h1 id="3、补充-与-的区别"><a href="#3、补充-与-的区别" class="headerlink" title="3、补充/*与/的区别"></a>3、补充/*与/的区别</h1><p>/ 匹配所有的请求；（不包括.jsp）</p>
<p>/* 匹配所有的请求；（包括.jsp）</p>
<p>在SpringMVC中最好用/，因为有一个视图解析器，当jsp被拦截的时候，会被拼接从而出现404错误。</p>
]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之适配</title>
    <url>/2020/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D/</url>
    <content><![CDATA[<h1 id="1、什么是适配器模式"><a href="#1、什么是适配器模式" class="headerlink" title="1、什么是适配器模式"></a>1、什么是适配器模式</h1><p>定义：将一个类的接口转换成客户希望的另外一个接口。<strong><em>Adapter\</em></strong>模式使得原本由于接口不<a href="https://baike.baidu.com/item/兼容" target="_blank" rel="noopener">兼容</a>而不能一起工作的那些类可以一起工作。</p>
<p>角色分析：</p>
<ul>
<li>目标接口：客户所期待的接口，目标可以是具体类或抽象类，也可以是接口</li>
<li>需要适配的类：需要适配的类或者适配的类</li>
<li>适配器：通过包装一个需要适配的对象，吧原接口转换成目标对象</li>
</ul>
<a id="more"></a>

<h1 id="2、实例演示"><a href="#2、实例演示" class="headerlink" title="2、实例演示"></a>2、实例演示</h1><img src="/2020/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D/1.png" class="" title="请实现以上场景">

<p>苹果充电功能接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ky.adapter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChargeIphone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//给Iphone充电</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">chargeIphone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安卓充电线：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Design_pattern</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 安卓充电线</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Kuang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-05-05 15:44</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChargingLine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始充电"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>苹果手机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Design_pattern</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 苹果手机</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Kuang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-05-05 15:43</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入适配器开始充电</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartCharging</span><span class="params">(ChargeIphone adapter)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        adapter.chargeIphone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适配器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Design_pattern</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 适配器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Kuang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-05-05 15:44</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">ChargeIphone</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ChargingLine chargingLine;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接充电线</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChargingLine</span><span class="params">(ChargingLine chargingLine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chargingLine = chargingLine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chargeIphone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"能给Iphone充电了"</span>);</span><br><span class="line">        chargingLine.charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Design_pattern</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Kuang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-05-05 15:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ChargingLine chargingLine = <span class="keyword">new</span> ChargingLine();</span><br><span class="line"></span><br><span class="line">        Adapter adapter = <span class="keyword">new</span> Adapter();</span><br><span class="line">        <span class="comment">//连接充电线</span></span><br><span class="line">        adapter.setChargingLine(chargingLine);</span><br><span class="line"></span><br><span class="line">        Iphone iphone = <span class="keyword">new</span> Iphone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//插入适配器开始充电</span></span><br><span class="line">        iphone.StartCharging(adapter);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D/2.png" class="" title="测试结果">

<p>上面这一种适配器叫做组合适配器</p>
<p>还有一种类适配器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Design_pattern</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 适配器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Kuang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-05-05 15:44</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">ChargingLine</span> <span class="keyword">implements</span> <span class="title">ChargeIphone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chargeIphone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"能给Iphone充电了"</span>);</span><br><span class="line">        <span class="keyword">super</span>.charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两者的区别就在于：组合适配器更加灵活，不必继承，只需设置要连接的另一个对象即可。</p>
<p><strong>小结</strong>：</p>
<p>适配器的好处：提高了代码的复用，降低了耦合</p>
<p>缺点：过多使用适配器，可能会使代码变得复杂</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>根据需求选集合</title>
    <url>/2020/05/05/%E6%A0%B9%E6%8D%AE%E9%9C%80%E6%B1%82%E9%80%89%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>根据需求选用合适的集合</p>
<a id="more"></a>

<img src="/2020/05/05/%E6%A0%B9%E6%8D%AE%E9%9C%80%E6%B1%82%E9%80%89%E9%9B%86%E5%90%88/%E6%A0%B9%E6%8D%AE%E9%9C%80%E6%B1%82%E9%80%89%E9%9B%86%E5%90%88.png" class="" title="根据需求选集合">]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring整合MyBatis</title>
    <url>/2020/05/04/Spring%E6%95%B4%E5%90%88MyBatis/</url>
    <content><![CDATA[<h1 id="1、原生的MyBatis"><a href="#1、原生的MyBatis" class="headerlink" title="1、原生的MyBatis"></a>1、原生的MyBatis</h1><h2 id="1-1、回顾演示"><a href="#1-1、回顾演示" class="headerlink" title="1.1、回顾演示"></a>1.1、回顾演示</h2><ul>
<li><p>导入包</p>
<a id="more"></a>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>编写配置文件</p>
<p>druid.properties:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">jdbcUrl</span>=<span class="string">jdbc:mysql:///mybatis?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p>mybatis-config.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入外部配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"druid.properties"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志设置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--别名扫描包下的实体类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.ky.pojo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"com.ky.utils.DruidUtils"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;driverClass&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbcUrl&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.ky.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写工具类加载配置文件：</p>
<p>生产SqlSession的工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//默认提交</span></span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建数据源的工具类：</p>
<p>虽然Druid提供了一个同名的DruidDataSourceFactory类，但是不能在MyBatis中直接使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidUtils</span> <span class="keyword">extends</span> <span class="title">PooledDataSourceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DruidUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写dao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.ky.dao.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAll"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    select *from mybatis.user_tab;</span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取sqlsseion</span></span><br><span class="line">    <span class="keyword">private</span> SqlSession sqlSession=<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//getMapper;</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper mapper =<span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sqlSession = MyBatisUtils.getSqlSession();</span><br><span class="line">        mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            List&lt;User&gt; users = mapper.getAll();</span><br><span class="line">            <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">                System.out.println(user);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="1-2、图解过程"><a href="#1-2、图解过程" class="headerlink" title="1.2、图解过程"></a>1.2、图解过程</h2><img src="/2020/05/04/Spring%E6%95%B4%E5%90%88MyBatis/1.png" class="" title="MyBatis使用图解">

<h1 id="2、Spring整合MyBatis"><a href="#2、Spring整合MyBatis" class="headerlink" title="2、Spring整合MyBatis"></a>2、Spring整合MyBatis</h1><h2 id="2-1、演示"><a href="#2-1、演示" class="headerlink" title="2.1、演示"></a>2.1、演示</h2><ul>
<li><p>导入包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：版本要一致</p>
<img src="/2020/05/04/Spring%E6%95%B4%E5%90%88MyBatis/2.png" class="" title="MyBatis-Spring版本对应">
</li>
<li><p>编写配置文件</p>
<p>druid.properties:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">jdbcUrl</span>=<span class="string">jdbc:mysql:///mybatis?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p>mybatis-config.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志设置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--别名扫描包下的实体类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.ky.pojo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>spring-dao.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--DateSource:使用Spring的数据源代替MyBatis的配置 c3p0 dbcp druid</span></span><br><span class="line"><span class="comment">    我们这里使用阿里巴巴的duid--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载db.properties文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:druid.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--注册数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;driverClass&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbcUrl&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;user&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--SqlSessionFactory--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--绑定数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--绑定mybatis配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--绑定mapper.xml--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/ky/dao/*.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--SqlSessionTemple:就是我们使用的sqlSeesion--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSession"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过构造器注入SqlSessionFactory因为他没有set方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注入实现类因为接口不能注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userMapperImp"</span> <span class="attr">class</span>=<span class="string">"com.ky.dao.UserMapperImp"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSession"</span> <span class="attr">ref</span>=<span class="string">"sqlSession"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;user&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果druid.配置文件中的用户的键尽量为username，以免出现</p>
<blockquote>
<p><strong>Access denied for user ‘Administrator’@‘localhost’ (using password: YES) 错误！！！！</strong></p>
</blockquote>
<p>网上的原因是:<strong>properties 中不能用 username 作为变量，这种方式会注入自己的系统环境变量的 用户名，本来是 root ，不应是那个 windows 用户名</strong></p>
<p>(但是我以前用username就没有没遇到这个问题)</p>
</li>
<li><p>编写dao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.ky.dao.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAll"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    select *from mybatis.user_tab;</span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperImp</span> <span class="keyword">implements</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//SqlSessionTemplate就是原先的SqlSession</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionTemplate sqlSession;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSession</span><span class="params">(SqlSessionTemplate sqlSession)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> mapper.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//获取ioc容器   </span></span><br><span class="line">     ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring-dao.xml"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取实现类</span></span><br><span class="line">        UserMapper userMapperImp = applicationContext.getBean(<span class="string">"userMapperImp"</span>, UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; users = userMapperImp.findAll();</span><br><span class="line"></span><br><span class="line">        users.forEach(user -&gt; System.out.println(user));</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="2-2、图解"><a href="#2-2、图解" class="headerlink" title="2.2、图解"></a>2.2、图解</h2><img src="/2020/05/04/Spring%E6%95%B4%E5%90%88MyBatis/3.png" class="" title="spring-mybatis整合">

<p>通过对比分析我们发现：</p>
<ul>
<li>Spring将数据源，SqlSessionFactory，SqlSessionTemple（SqlSession）全都注入到IOC容器中了</li>
<li>Spring还比Myabtis原生方法多了一个Mapper实现类//也可以不注入直接获取SqlSessionTemple再获取Mapper实现类</li>
</ul>
<h2 id="2-3、简化（不注入SqlSessionTemple）"><a href="#2-3、简化（不注入SqlSessionTemple）" class="headerlink" title="2.3、简化（不注入SqlSessionTemple）"></a>2.3、简化（不注入SqlSessionTemple）</h2><p>修改实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperImp2</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        SqlSession sqlSession = getSqlSession();</span></span><br><span class="line"><span class="comment">//        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span></span><br><span class="line"><span class="comment">//        List&lt;User&gt; users = mapper.findAll();</span></span><br><span class="line">        <span class="keyword">return</span> getSqlSession().getMapper(UserMapper<span class="class">.<span class="keyword">class</span>).<span class="title">findAll</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改spring-dao.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userMapperImp2"</span> <span class="attr">class</span>=<span class="string">"com.ky.dao.UserMapperImp2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>分析：这里我们就不用注入SqlSessionTemple，因为我们继承了SqlSessionDaoSupport，而SqlSessionDaoSupport有一个属性SqlSessionTemplate和一个setSqlSessionFactory方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SqlSessionTemplate sqlSessionTemplate;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionTemplate == <span class="keyword">null</span> || sqlSessionFactory != <span class="keyword">this</span>.sqlSessionTemplate.getSqlSessionFactory()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.sqlSessionTemplate = <span class="keyword">this</span>.createSqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>SqlSessionTemple已经是实现类的一个属性了，只需要set一个sqlSessionFactory就可以赋值，然后调用getSqlSession就可以返回</strong></p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之代理</title>
    <url>/2020/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="1、代理模式简介"><a href="#1、代理模式简介" class="headerlink" title="1、代理模式简介"></a>1、代理模式简介</h1><p><strong>代理模式的定义：</strong>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。</p>
<a id="more"></a>

<img src="/2020/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86/2.png" class="" title="代理模式">

<p>代理模式分为两大类：</p>
<ul>
<li>静态代理：由一个类文件描述代理</li>
<li>动态代理：在内存中形成代理类</li>
</ul>
<h1 id="2、静态代理："><a href="#2、静态代理：" class="headerlink" title="2、静态代理："></a>2、静态代理：</h1><img src="/2020/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86/1.png" class="" title="租房">

<p>实现以上场景</p>
<p>功能接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真实对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"出租房子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Host host)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        seeHouse();</span><br><span class="line">        host.Rent();</span><br><span class="line">        hetong();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seeHouse</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"看房"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hetong</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"签合同"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户租房子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Host host = <span class="keyword">new</span> Host();</span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy(host);</span><br><span class="line">        proxy.Rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86/3.png" class="" title="功能实现">

<p><strong>分析：</strong>在以上代码中，我们并没有直接接触房东，而是通过中介完成了租房工作，这就是代理模式。</p>
<p>优点：</p>
<ul>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时变得更加集中和方便 .</li>
</ul>
<p>缺点 :</p>
<ul>
<li>类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 .</li>
</ul>
<p>我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !</p>
<h1 id="3、动态代理"><a href="#3、动态代理" class="headerlink" title="3、动态代理"></a>3、动态代理</h1><p>功能接口和真实对象与上面相同</p>
<p>获取代理对象的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHost</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Rent <span class="title">getProxy</span><span class="params">(Host host)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 三个参数：</span></span><br><span class="line"><span class="comment">         * 1.真实类的类加载器</span></span><br><span class="line"><span class="comment">         * 2.真实类实现的接口</span></span><br><span class="line"><span class="comment">         * 3.处理器InvocationHandler</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        Rent proxy = (Rent) Proxy.newProxyInstance(host.getClass().getClassLoader(), host.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 代理逻辑编写的代码部分，代理对象调用所有的方法都会触发改方法执行</span></span><br><span class="line"><span class="comment">             * 参数：</span></span><br><span class="line"><span class="comment">             *  1.proxy 代理对象</span></span><br><span class="line"><span class="comment">             *  2.代理对象调用的方法</span></span><br><span class="line"><span class="comment">             *  3.代理对象调用方法所传参数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">"Rent"</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">"看房"</span>);</span><br><span class="line">                    method.invoke(host, args);</span><br><span class="line">                    System.out.println(<span class="string">"签合同"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Host host = <span class="keyword">new</span> Host();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得代理对象</span></span><br><span class="line">        Rent proxy = ProxyHost.getProxy(host);</span><br><span class="line"></span><br><span class="line">        proxy.Rent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86/3.png" class="" title="功能实现">

<p>优点：</p>
<p>静态代理有的它都有，静态代理没有的，它也有！</p>
<ul>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时变得更加集中和方便 .</li>
<li>一个动态代理 , 一般代理某一类业务</li>
<li>一个动态代理可以代理多个类，代理的是接口！</li>
</ul>
<h1 id="4、编写一个动态代理类的模板"><a href="#4、编写一个动态代理类的模板" class="headerlink" title="4、编写一个动态代理类的模板"></a>4、编写一个动态代理类的模板</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: SpringDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 动态代理工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Kuang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-05-03 13:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtils</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要被代理的接口</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObjectProxy</span><span class="params">(Object target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object proxy = Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//填写要处理的的代码</span></span><br><span class="line">        </span><br><span class="line">        Object invoke = method.invoke(target, args);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：两个核心</p>
<ul>
<li>Proxy.newProxyInstance  创建一个代理对象</li>
<li>Object invoke  处理代理对象如何代理</li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring的注解和xml配置bean那一个优先级更高</title>
    <url>/2020/05/02/Spring%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%92%8Cxml%E9%85%8D%E7%BD%AEbean%E9%82%A3%E4%B8%80%E4%B8%AA%E4%BC%98%E5%85%88%E7%BA%A7%E6%9B%B4%E9%AB%98/</url>
    <content><![CDATA[<blockquote>
<p>思考： 刚复习了注解，我就在想Spring的注解和xml配置bean那一个优先级更高？</p>
<a id="more"></a>
</blockquote>
<p>测试：</p>
<ol>
<li><p>实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="comment">//将User注册到IOC容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"kyky"</span>)<span class="comment">//给name赋值</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>xml配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解支持并且开启包扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.ky.pojo"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">&lt;!--在xml注册一个同名的user对象但name不同--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.ky.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"kykyky"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        User user = applicationContext.getBean(<span class="string">"user"</span>, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(user.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/02/Spring%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%92%8Cxml%E9%85%8D%E7%BD%AEbean%E9%82%A3%E4%B8%80%E4%B8%AA%E4%BC%98%E5%85%88%E7%BA%A7%E6%9B%B4%E9%AB%98/1.png" class="" title="测试结果">

</li>
</ol>
<p><strong>结论：</strong>xml配置比注解配置bean的属性优先级高，原因是XML是可以随时修改的，即插即用，不用重新编译！！</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring注解自动装配</title>
    <url>/2020/05/02/Spring%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
    <content><![CDATA[<h1 id="1、Bean注解的自动装配简介"><a href="#1、Bean注解的自动装配简介" class="headerlink" title="1、Bean注解的自动装配简介"></a>1、Bean注解的自动装配简介</h1><ul>
<li>自动装配是使用spring满足bean依赖的一种方法</li>
<li>spring会在应用上下文中为某个bean寻找其依赖的bean</li>
</ul>
<a id="more"></a>

<h2 id="1-1、Spring中bean有三种装配机制"><a href="#1-1、Spring中bean有三种装配机制" class="headerlink" title="1.1、Spring中bean有三种装配机制"></a>1.1、Spring中bean有三种装配机制</h2><p>分别是：</p>
<ol>
<li>在xml中显式配置；</li>
<li>在java中显式配置；</li>
<li>隐式的bean发现机制和自动装配。</li>
</ol>
<p>这里我们主要讲第三种：自动化的装配bean。</p>
<h2 id="1-2、Spring的自动装配需要从两个角度来实现"><a href="#1-2、Spring的自动装配需要从两个角度来实现" class="headerlink" title="1.2、Spring的自动装配需要从两个角度来实现"></a>1.2、Spring的自动装配需要从两个角度来实现</h2><ol>
<li>组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean；</li>
<li>自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI；</li>
</ol>
<p>组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。</p>
<p><strong>推荐不使用自动装配xml配置 , 而使用注解 .</strong></p>
<h2 id="2、测试"><a href="#2、测试" class="headerlink" title="2、测试"></a>2、测试</h2><h2 id="2-1、创建三个实体类Cat，Dog，User，其中User有cat，dog属性"><a href="#2-1、创建三个实体类Cat，Dog，User，其中User有cat，dog属性" class="headerlink" title="2.1、创建三个实体类Cat，Dog，User，其中User有cat，dog属性"></a>2.1、创建三个实体类Cat，Dog，User，其中User有cat，dog属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"miao~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"wang~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Cat cat;</span><br><span class="line">   <span class="keyword">private</span> Dog dog;</span><br><span class="line">   <span class="keyword">private</span> String str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2、编写配置文件"><a href="#2-2、编写配置文件" class="headerlink" title="2.2、编写配置文件"></a>2.2、编写配置文件</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">      xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">      xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=<span class="string">"dog"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span><br><span class="line">   &lt;bean id=<span class="string">"cat"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=<span class="string">"user"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.kuang.pojo.User"</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">"cat"</span> ref=<span class="string">"cat"</span>/&gt;</span><br><span class="line">       &lt;property name=<span class="string">"dog"</span> ref=<span class="string">"dog"</span>/&gt;</span><br><span class="line">       &lt;property name=<span class="string">"str"</span> value=<span class="string">"ky"</span>/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-3、测试"><a href="#2-3、测试" class="headerlink" title="2.3、测试"></a>2.3、测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethodAutowire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">       User user = (User) context.getBean(<span class="string">"user"</span>);</span><br><span class="line">       user.getCat().shout();</span><br><span class="line">       user.getDog().shout();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4、byName"><a href="#2-4、byName" class="headerlink" title="2.4、byName"></a>2.4、byName</h2><p><strong>autowire byName (按名称自动装配)</strong></p>
<p>使用byName要保证spring容器中id唯一</p>
<p><strong>测试：</strong></p>
<ol>
<li><p>修改配置文件:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"user"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.kuang.pojo.User"</span> autowire=<span class="string">"byName"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"str"</span> value=<span class="string">"ky"</span>/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次测试，输出成功</p>
</li>
<li><p>修改setDog的方法名为setPig ，再测试发现报空指针异常</p>
</li>
</ol>
<p><strong>小结：</strong></p>
<p>当一个bean节点带有 autowire byName的属性时。</p>
<ol>
<li>将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。</li>
<li>去spring容器中寻找是否有此字符串名称id的对象。</li>
<li>如果有，就取出注入；如果没有，就报空指针异常。</li>
</ol>
<h2 id="2-5、byType"><a href="#2-5、byType" class="headerlink" title="2.5、byType"></a>2.5、byType</h2><p><strong>autowire byType (按类型自动装配)</strong></p>
<p>使用byType 必须保证在spring容器中类型唯一，否则会报NoUniqueBeanDefinitionException</p>
<p><strong>测试：</strong></p>
<ol>
<li><p>修改配置文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"user"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.kuang.pojo.User"</span> autowire=<span class="string">"byName"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"str"</span> value=<span class="string">"ky"</span>/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次测试，输出成功</p>
</li>
<li><p>注册一个cat2对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"cat2"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试，报错：NoUniqueBeanDefinitionException</p>
</li>
<li><p>删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。</p>
<p>这就是按照类型自动装配！</p>
</li>
</ol>
<h2 id="2-6、-Autowired-Resource-Qualifier"><a href="#2-6、-Autowired-Resource-Qualifier" class="headerlink" title="2.6、@Autowired @Resource @Qualifier"></a>2.6、@Autowired @Resource @Qualifier</h2><h3 id="2-6-1、-Autowired"><a href="#2-6-1、-Autowired" class="headerlink" title="2.6.1、@Autowired"></a>2.6.1、@Autowired</h3><ul>
<li>@Autowired是按类型自动转配的，不支持id匹配。</li>
<li>需要导入 spring-aop的包！</li>
</ul>
<p>测试：</p>
<p>1、将User类中的set方法去掉，使用@Autowired注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> Cat cat;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> Dog dog;</span><br><span class="line">   <span class="keyword">private</span> String str;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Cat <span class="title">getCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> cat;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Dog <span class="title">getDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> dog;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、此时配置文件内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.User"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、测试，成功输出结果！</p>
<p>@Autowired(required=false)  说明：false，对象可以为null；true，对象必须存对象，不能为null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果允许对象为null，设置required = false,默认为true</span></span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="2-6-2、-Qualifier"><a href="#2-6-2、-Qualifier" class="headerlink" title="2.6.2、@Qualifier"></a>2.6.2、@Qualifier</h3><ul>
<li>@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配</li>
<li>@Qualifier<strong>不能单独使用。</strong></li>
</ul>
<p>测试实验步骤：</p>
<p>1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog1"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog2"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat1"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat2"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、没有加Qualifier测试，直接报错</p>
<p>3、在属性上添加Qualifier注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(value = <span class="string">"cat2"</span>)</span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(value = <span class="string">"dog2"</span>)</span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure>

<p>测试，成功输出！</p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h3 id="2-6-3、-Resource"><a href="#2-6-3、-Resource" class="headerlink" title="2.6.3、@Resource"></a>2.6.3、@Resource</h3><ul>
<li>@Resource如有指定的name属性，先按该属性进行byName方式查找装配；</li>
<li>其次再进行默认的byName方式进行装配；</li>
<li>如果以上都不成功，则按byType的方式自动装配。</li>
<li>都不成功，则报异常。</li>
</ul>
<p>实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="comment">//如果允许对象为null，设置required = false,默认为true</span></span><br><span class="line">   <span class="meta">@Resource</span>(name = <span class="string">"cat2"</span>)</span><br><span class="line">   <span class="keyword">private</span> Cat cat;</span><br><span class="line">   <span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> Dog dog;</span><br><span class="line">   <span class="keyword">private</span> String str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>beans.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat1"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat2"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.User"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：结果OK</p>
<p>配置文件2：beans.xml ， 删掉cat2</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat1"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>实体类上只保留注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure>

<p>结果：OK</p>
<p>结论：先进行byName查找，失败；再进行byType查找，成功。</p>
<p><strong>小结：</strong></p>
<p><strong>@Autowired 根据类型注入，</strong> </p>
<p><strong>@Resource 默认根据名字注入，其次按照类型搜索</strong></p>
<p><strong>@Autowired @Qualifie(“userService”) 两个结合起来可以根据名字和类型注入</strong></p>
<p><strong>面试题</strong></p>
<p><strong><em>Spring 为啥把bean默认设计成单例？</em></strong></p>
<p><strong><em>答案：为了提高性能！！！从几个方面，</em></strong></p>
<p><strong><em>少创建实例</em></strong></p>
<p><strong><em>减少垃圾回收</em></strong></p>
<p><strong><em>缓存快速获取</em></strong></p>
<p><strong><em>单例有啥劣势？</em></strong></p>
<p><strong><em>如果是有状态的话在并发环境下线程不安全。</em></strong></p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring简介与IOC思想</title>
    <url>/2020/05/01/Spring%E7%AE%80%E4%BB%8B%E4%B8%8EIOC%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h1 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h1><h2 id="1-1、什么是Spring"><a href="#1-1、什么是Spring" class="headerlink" title="1.1、什么是Spring"></a>1.1、什么是Spring</h2><p>Spring框架是一个开放源代码的<a href="https://baike.baidu.com/item/J2EE/110838" target="_blank" rel="noopener">J2EE</a>应用程序框架，为了解决企业应用开发的复杂性而创建的，由[Rod Johnson](<a href="https://baike.baidu.com/item/Rod" target="_blank" rel="noopener">https://baike.baidu.com/item/Rod</a> Johnson/1423612)发起。</p>
<a id="more"></a>

<h2 id="1-2、Spring的作用"><a href="#1-2、Spring的作用" class="headerlink" title="1.2、Spring的作用"></a>1.2、Spring的作用</h2><p>简化应用程序的开发。</p>
<h2 id="1-3、Spring的特点"><a href="#1-3、Spring的特点" class="headerlink" title="1.3、Spring的特点"></a>1.3、Spring的特点</h2><ul>
<li>Spring是一个开源的免费框架</li>
<li>Spring是一个轻量级的、非入侵的框架</li>
<li>控制反转（IOC），面向切面编程（AOP）</li>
</ul>
<p><strong>总结：</strong>Spring是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的开源框架</p>
<h2 id="1-4、Spring七大组件"><a href="#1-4、Spring七大组件" class="headerlink" title="1.4、Spring七大组件"></a>1.4、Spring七大组件</h2><img src="/2020/05/01/Spring%E7%AE%80%E4%BB%8B%E4%B8%8EIOC%E6%80%9D%E6%83%B3/1.png" class="" title="七大组件">

<h3 id="1-4-1、核心容器（Spring-Code）"><a href="#1-4-1、核心容器（Spring-Code）" class="headerlink" title="1.4.1、核心容器（Spring Code）"></a>1.4.1、核心容器（Spring Code）</h3><p>概念<br>是Spring的核心容器，提供了Spring框架的基本功能；</p>
<p>此模块包含的BeanFactory类是Spring的核心类，负责产生和管理Bean，是工程模式的实现；</p>
<p>采用Factory(工厂模式)实现了IOC（控制反转）将应用的配置和依赖性规范与实际的应用程序代码分开；</p>
<p>Spring以bean的方式组织和管理Java应用中发各个组件及其关系。</p>
<h3 id="1-4-2、应用上下文（Spring-Context）"><a href="#1-4-2、应用上下文（Spring-Context）" class="headerlink" title="1.4.2、应用上下文（Spring Context）"></a>1.4.2、应用上下文（Spring Context）</h3><p>概念<br>是一个配置文件，向Spring框架提供上下文信息；</p>
<p>SpringContext模块继承BeanFactory类，添加了事件处理、国际化、资源装载、透明装载、以及数据校验等功能；</p>
<p>还提供了框架式的Bean的访问方式和企业级的功能，如JNDI访问，支持EJB、远程调用、继承模板框架、Email和定时任务调度等；</p>
<h3 id="1-4-3、面向切面编程（Spring-AOP）"><a href="#1-4-3、面向切面编程（Spring-AOP）" class="headerlink" title="1.4.3、面向切面编程（Spring AOP）"></a>1.4.3、面向切面编程（Spring AOP）</h3><p>概念<br>Spring AOP直接将面向方面的编程功能集成到了Spring框架中，所以很容易的使Spring框架管理的任何对象支持AOP（Spring集成了所有AOP功能。通过事务管理可以使任意Spring管理的对象AOP化）；</p>
<p>Spring AOP为基于Spring的应用程序中的对象提供了事务管理服务；</p>
<p>通过使用Spring AOP，不用依赖EJB组件，就可以将声明性事务管集成到应用程序中。</p>
<h3 id="1-4-4、JDBC和DAO模块（Spring-DAO）"><a href="#1-4-4、JDBC和DAO模块（Spring-DAO）" class="headerlink" title="1.4.4、JDBC和DAO模块（Spring DAO）"></a>1.4.4、JDBC和DAO模块（Spring DAO）</h3><p>概念<br>DAO（DataAccessObject）模式思想是将业务逻辑代码与数据库交互代码分离，降低两者耦合；</p>
<p>通过DAO模式可以使结构变得更为清晰，代码更为简；</p>
<p>DAO模块中的JDBC的抽象层，提供了有意义的异常层次结构，用该结构来管理异常处理，和不同数据库供应商所抛出的错误信息；</p>
<p>异常层次结构简化了数据库厂商的异常错误（不再从SQLException继承大批代码），极大的降低了需要编写的代码数量，并且提供了对声明式事务和编程式事务的支持；</p>
<h3 id="1-4-5、对象实体映射（Spring-ORM）"><a href="#1-4-5、对象实体映射（Spring-ORM）" class="headerlink" title="1.4.5、对象实体映射（Spring ORM）"></a>1.4.5、对象实体映射（Spring ORM）</h3><p>概念：<br>SpringORM模块提供了对现有ORM框架的支持；<br>提供了ORM对象的关系工具，其中包括了Hibernate、JDO和 IBatis SQL Map等，所有的这些都遵从Spring的通用事务和DAO异常层次结构；</p>
<p>注意这里Spring是提供各类的接口（support），目前比较流行的下层数据库封闭映射框架，如ibatis,Hibernate等；</p>
<h3 id="1-4-6、Web模块（Spring-Web）"><a href="#1-4-6、Web模块（Spring-Web）" class="headerlink" title="1.4.6、Web模块（Spring Web）"></a>1.4.6、Web模块（Spring Web）</h3><p>概念：<br>此模块建立在SpringContext基础之上，提供了Servlet监听器的Context和Web应用的上下文；</p>
<p>对现有的Web框架，如JSF、Tapestry、Structs等提供了集成；</p>
<p>SpringWeb模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</p>
<h3 id="1-4-7、MVC模块（Spring-Web-MVC）"><a href="#1-4-7、MVC模块（Spring-Web-MVC）" class="headerlink" title="1.4.7、MVC模块（Spring Web MVC）"></a>1.4.7、MVC模块（Spring Web MVC）</h3><p>概念<br>SpringWebMVC模块建立在Spring核心功能之上，拥有Spring框架的所有特性，能够适应多种多视图、模板技术、国际化和验证服务，实现控制逻辑和业务逻辑的清晰分离；</p>
<p>通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI;</p>
<p>MVC模型:</p>
<p>Servlet控制器为应用程序提供了一个进行前-后端处理的中枢。一方面为输入数据的验证、身份认证、日志及实现国际化编程提供了一个合适的切入点；另一方面也提供了将业务逻辑从JSP文件剥离的可能;</p>
<p>业务逻辑从JSP页面分离后，JSP文件蜕变成一个单纯完成显示任务的东西，这就是常说的View;</p>
<p>而独立出来的事务逻辑变成人们常说的Model，再加上控制器Control本身，就构成了MVC模式</p>
<h1 id="2、IOC理论推导"><a href="#2、IOC理论推导" class="headerlink" title="2、IOC理论推导"></a>2、IOC理论推导</h1><ol>
<li><p>UserDao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoMySql</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现了mysql"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoOracle</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现了Oracle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>UserService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao =<span class="keyword">new</span> UserDaoOracle();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    UserService userService=<span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">    userService.getUser();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>重点:</strong>如果我们此时想要实现MySql的功能,就需要修改UserServiceImpl的UserDao属性，如果涉及的代码量很大，修改的代价也就很大。但如果我们修改一下UserServiceImpl获取UserDao属性获取方式就能极大简化操作。</p>
</blockquote>
</li>
<li><p>修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态获取userDao</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userService=<span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        ((UserServiceImpl) userService).setUserDao(<span class="keyword">new</span> UserDaoMySql());</span><br><span class="line">        userService.getUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>总结：第一种的方式的UserServiceImpl的UserDao属性是固定的，修改控制权在程序员，而第二种的UserDao属性是根据业务需求动态获取的，控制权在用户,降低了系统的耦合。这便是最简单的控制反转（IOC）;</strong></p>
<h1 id="3、ioc本质"><a href="#3、ioc本质" class="headerlink" title="3、ioc本质"></a>3、ioc本质</h1><p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>
<p><strong>IoC是Spring框架的核心内容</strong>，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。</p>
<p>Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。</p>
<img src="/2020/05/01/Spring%E7%AE%80%E4%BB%8B%E4%B8%8EIOC%E6%80%9D%E6%83%B3/2.png" class="" title="SpringIoc">

<p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p>
<p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p>
<h1 id="4、一个Spring简单的使用"><a href="#4、一个Spring简单的使用" class="headerlink" title="4、一个Spring简单的使用"></a>4、一个Spring简单的使用</h1><p>创建实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSpring</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloSpring</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloSpring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStr</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HelloSpring&#123;"</span> +</span><br><span class="line">                <span class="string">"str='"</span> + str + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建beans.xml注册进HelloSpring的对象</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"hello"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.ky.pojo.HelloSpring"</span>&gt;</span><br><span class="line">     &lt;property name=<span class="string">"str"</span> value=<span class="string">"你好Spring"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取Spring容器</span></span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        <span class="comment">//取出bean</span></span><br><span class="line">        HelloSpring hello = (HelloSpring) applicationContext.getBean(<span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(hello);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong>你会发现，在以上代码中我们并没有出现new HelloSpring的代码，就能使用HelloSpring的实例化对象。这是因为我们将对象交给了Spring的IOC容器创建，管理，装配。这个过程就叫控制反转。</p>
<ul>
<li>控制：传统应用程序的对象是由程序本身创建控制，使用Spring后，对象是Spring创建控制</li>
<li>反转：程序本身不创建对象，变成了被动接受对象</li>
<li>依赖：依赖于Spring创建bean对象</li>
<li>注入：就是利用set方法来进行对象bean的属性动态注入</li>
</ul>
</blockquote>
<p><strong>总结：</strong>IOC是一种编程思想，由主动编程创建变成了被动的接受。Spring的IOC就是一句话：对象由Spring创建，管理，装配</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis缓存</title>
    <url>/2020/04/30/MyBatis%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="MyBatis的缓存机制"><a href="#MyBatis的缓存机制" class="headerlink" title="MyBatis的缓存机制"></a>MyBatis的缓存机制</h1><blockquote>
<p>为什么需要缓存？</p>
<p>原因：当访问数据量过大，多个用户读写数据库，会消耗读写资源，甚至可能出现并发问题。所以</p>
<p>引入缓存机制，将一些经常访问但不修改的信息存入缓存中，这样实现读写分离能一定减少性能的消耗</p>
<a id="more"></a>
</blockquote>
<h2 id="1-一级缓存"><a href="#1-一级缓存" class="headerlink" title="1.一级缓存"></a>1.一级缓存</h2><p><strong>一级缓存默认开启，且只在SqlSession中有效，也就是从连接到关闭期间</strong></p>
<p>测试：</p>
<ul>
<li><p>查询相同的数据两次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       SqlSession sqlSession = MyBatisUtils.getSqlSession();</span><br><span class="line">       UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       User userById1 = mapper.getUserById(<span class="number">2</span>);</span><br><span class="line">       System.out.println(userById1);</span><br><span class="line">       System.out.println(<span class="string">"============="</span>);</span><br><span class="line">       User userById2=mapper.getUserById(<span class="number">2</span>);</span><br><span class="line">       System.out.println(userById2);</span><br><span class="line">       sqlSession.close();</span><br><span class="line">  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/04/30/MyBatis%E7%BC%93%E5%AD%98/1.png" class="" title="结果1">
</li>
<li><p>查询不同的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">     SqlSession sqlSession = MyBatisUtils.getSqlSession();</span><br><span class="line">     UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">     User userById1 = mapper.getUserById(<span class="number">2</span>);</span><br><span class="line">     System.out.println(userById1);</span><br><span class="line">     System.out.println(<span class="string">"============="</span>);</span><br><span class="line">     User userById2=mapper.getUserById(<span class="number">3</span>);</span><br><span class="line">     System.out.println(userById2);</span><br><span class="line">     sqlSession.close();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/04/30/MyBatis%E7%BC%93%E5%AD%98/2.png" class="" title="结果2">
</li>
<li><p>查询相同的数据两次，但在当中执行更新或者插入操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">       SqlSession sqlSession = MyBatisUtils.getSqlSession();</span><br><span class="line">       UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       User userById1 = mapper.getUserById(<span class="number">2</span>);</span><br><span class="line">       System.out.println(userById1);</span><br><span class="line">       System.out.println(<span class="string">"============="</span>);</span><br><span class="line">       HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       map.put(<span class="string">"id"</span>,<span class="number">3</span>);</span><br><span class="line">       map.put(<span class="string">"name"</span>,<span class="string">"kyky"</span>);</span><br><span class="line">       mapper.updateNameById(map);</span><br><span class="line">       System.out.println(<span class="string">"============="</span>);</span><br><span class="line">       User userById2=mapper.getUserById(<span class="number">2</span>);</span><br><span class="line">       System.out.println(userById2);</span><br><span class="line">       sqlSession.close();</span><br><span class="line">  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/04/30/MyBatis%E7%BC%93%E5%AD%98/3.png" class="" title="结果3">

<p>总结：</p>
<ol>
<li>一级缓存只在一次连接期间有效</li>
<li>一级缓存默认开启</li>
<li>当有增删改操作的时候，原有缓存会刷新</li>
<li>sqlSession.clearCache()方法;也会清理缓存</li>
</ol>
</li>
</ul>
<h2 id="2-二级缓存"><a href="#2-二级缓存" class="headerlink" title="2.二级缓存"></a>2.二级缓存</h2><ul>
<li>二级缓存也叫全局缓存，一级缓存作用域名太低了所以诞生了二级缓存</li>
<li>二级缓存是namespace级别的，一个名称空间对应一个缓存（一个mapper对应一个缓存）</li>
<li>工作机制<ul>
<li>一个会话查询一条数据，这个数据会被存在一级缓存</li>
<li>会话结束后，一级缓存消失，但数据会保存到二级缓存中</li>
<li>新的会话，可以从二级缓存中获取内容</li>
</ul>
</li>
</ul>
<p>步骤：</p>
<ol>
<li><p>开启全局缓存</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--显式开启二级缓存，默认隐式开启--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在需要二级缓存mapper开启</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在当前mapper开启二级缓存--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以自定义缓存。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">  <span class="attr">eviction</span>=<span class="string">"FIFO"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushInterval</span>=<span class="string">"60000"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">size</span>=<span class="string">"512"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">readOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试：在不同的sqlsess查询相同的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">    SqlSession sqlSession1 = MyBatisUtils.getSqlSession();</span><br><span class="line">    SqlSession sqlSession2 = MyBatisUtils.getSqlSession();</span><br><span class="line">    User userById1= sqlSession1.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>).<span class="title">getUserById</span>(2)</span>;</span><br><span class="line">    System.out.println(<span class="string">"==============="</span>);</span><br><span class="line">    User userById2= sqlSession2.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>).<span class="title">getUserById</span>(2)</span>;</span><br><span class="line">    </span><br><span class="line">    sqlSession1.close();</span><br><span class="line">    sqlSession2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/04/30/MyBatis%E7%BC%93%E5%AD%98/4.png" class="" title="结果4">

<p><strong>注意：</strong></p>
<p>这里二级缓存并没有生效。原因是因为二级缓存是在一级缓存消失的时候才生效，sqlSession1和sqlSession2几乎同时关闭就没法使二级缓存生效.</p>
<p><strong>修改代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">       SqlSession sqlSession1 = MyBatisUtils.getSqlSession();</span><br><span class="line">       SqlSession sqlSession2 = MyBatisUtils.getSqlSession();</span><br><span class="line">       User userById1= sqlSession1.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>).<span class="title">getUserById</span>(2)</span>;</span><br><span class="line">       System.out.println(userById1);</span><br><span class="line">       sqlSession1.close();</span><br><span class="line">       System.out.println(<span class="string">"==============="</span>);</span><br><span class="line">       User userById2= sqlSession2.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>).<span class="title">getUserById</span>(2)</span>;</span><br><span class="line">       System.out.println(userById2);</span><br><span class="line">       sqlSession2.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/04/30/MyBatis%E7%BC%93%E5%AD%98/5.png" class="" title="结果5">

</li>
</ol>
<h1 id="3-缓存原理"><a href="#3-缓存原理" class="headerlink" title="3.缓存原理"></a>3.缓存原理</h1><img src="/2020/04/30/MyBatis%E7%BC%93%E5%AD%98/6.png" class="" title="存的原理图">

<p><strong>注意：</strong>当当二级缓存和一级缓存同时存在的时候，会先查二级缓存，没有再查一级缓存，没有再查数据库</p>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis一对多与多对一</title>
    <url>/2020/04/29/MyBatis%E4%B8%80%E5%AF%B9%E5%A4%9A%E4%B8%8E%E5%A4%9A%E5%AF%B9%E4%B8%80/</url>
    <content><![CDATA[<h1 id="1-多对一"><a href="#1-多对一" class="headerlink" title="1.多对一"></a>1.多对一</h1><p>基本表一个老师多个学生</p>
<a id="more"></a>

<img src="/2020/04/29/MyBatis%E4%B8%80%E5%AF%B9%E5%A4%9A%E4%B8%8E%E5%A4%9A%E5%AF%B9%E4%B8%80/1.png" class="" title="表结构">

<h2 id="（1）第一种按照查询嵌套，子查询"><a href="#（1）第一种按照查询嵌套，子查询" class="headerlink" title="（1）第一种按照查询嵌套，子查询"></a>（1）第一种按照查询嵌套，子查询</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">   &lt;!--按照查询嵌套，子查询--&gt;</span><br><span class="line">&lt;select id=<span class="string">"getStudentTeacher"</span>  resultMap=<span class="string">"StudentMap"</span>&gt;</span><br><span class="line">    select *from mybatis.student;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">"StudentMap"</span> type=<span class="string">"Student"</span>&gt;</span><br><span class="line">        &lt;result column=<span class="string">"id"</span> property=<span class="string">"id"</span>/&gt;</span><br><span class="line">        &lt;result column=<span class="string">"name"</span> property=<span class="string">"name"</span>/&gt;</span><br><span class="line">        &lt;!--根据tid查询teacher--&gt;</span><br><span class="line">        &lt;association property=<span class="string">"teacher"</span> column=<span class="string">"tid"</span>  javaType=<span class="string">"Teacher"</span> select=<span class="string">"getTeacher"</span>/&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">&lt;select id=<span class="string">"getTeacher"</span> resultType=<span class="string">"Teacher"</span>&gt;</span><br><span class="line">    select *from mybatis.teacher where #&#123;id&#125;;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>相当于以下sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *<span class="keyword">from</span> mybatis.student <span class="keyword">where</span> tid <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> mybatis.teacher);</span><br></pre></td></tr></table></figure>

<p><u><strong>注意</strong>：getTeacher中的#{id}是从getStudentTeacher中查询得到的tid</u></p>
<h2 id="（2）第二种按照结果嵌套查询，关联查询"><a href="#（2）第二种按照结果嵌套查询，关联查询" class="headerlink" title="（2）第二种按照结果嵌套查询，关联查询"></a>（2）第二种按照结果嵌套查询，关联查询</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--按照结果嵌套,关联查询--&gt;</span><br><span class="line">&lt;select id=<span class="string">"getStudentTeacher2"</span> resultMap=<span class="string">"StudentMap2"</span>&gt;</span><br><span class="line">    select s.id sid,s.name sname,t.name tname,t.id tid</span><br><span class="line">    from mybatis.student s ,mybatis.teacher t</span><br><span class="line">    where s.tid=t.id;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;resultMap id=<span class="string">"StudentMap2"</span> type=<span class="string">"Student"</span>&gt;</span><br><span class="line">    &lt;result column=<span class="string">"sid"</span> property=<span class="string">"id"</span>/&gt;</span><br><span class="line">    &lt;result column=<span class="string">"sname"</span> property=<span class="string">"name"</span>/&gt;</span><br><span class="line">    &lt;association property=<span class="string">"teacher"</span> javaType=<span class="string">"Teacher"</span>&gt;</span><br><span class="line">        &lt;result column=<span class="string">"tid"</span> property=<span class="string">"id"</span>/&gt;</span><br><span class="line">        &lt;result column=<span class="string">"tname"</span> property=<span class="string">"name"</span>/&gt;</span><br><span class="line">    &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.id <span class="keyword">sid</span>,s.name sname,t.name tname,t.id tid</span><br><span class="line">  <span class="keyword">from</span> mybatis.student s ,mybatis.teacher t</span><br><span class="line">  <span class="keyword">where</span> s.tid=t.id;</span><br></pre></td></tr></table></figure>

<h1 id="2-一对多"><a href="#2-一对多" class="headerlink" title="2.一对多"></a>2.一对多</h1><h2 id="（1）第一种按照查询嵌套，子查询-1"><a href="#（1）第一种按照查询嵌套，子查询-1" class="headerlink" title="（1）第一种按照查询嵌套，子查询"></a>（1）第一种按照查询嵌套，子查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="getTeacherAndStudent2" resultMap="TeacherAndStudent2" parameterType="_int"&gt;</span><br><span class="line"><span class="keyword">select</span> *<span class="keyword">from</span> mybatis.teacher <span class="keyword">where</span> <span class="keyword">id</span>=<span class="comment">#&#123;tid&#125;;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br><span class="line">&lt;resultMap <span class="keyword">id</span>=<span class="string">"TeacherAndStudent2"</span> <span class="keyword">type</span>=<span class="string">"Teacher"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">result</span> property=<span class="string">"id"</span> <span class="keyword">column</span>=<span class="string">"id"</span>/&gt;</span><br><span class="line">    &lt;<span class="keyword">result</span> property=<span class="string">"name"</span> <span class="keyword">column</span>=<span class="string">"name"</span>/&gt;</span><br><span class="line">    &lt;collection property=<span class="string">"students"</span> javaType=<span class="string">"ArrayList"</span> ofType=<span class="string">"Student"</span> <span class="keyword">column</span>=<span class="string">"id"</span> <span class="keyword">select</span>=<span class="string">"getStudent"</span>/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;<span class="keyword">select</span> <span class="keyword">id</span>=<span class="string">"getStudent"</span> resultType=<span class="string">"Student"</span>&gt;</span><br><span class="line">    <span class="keyword">select</span> *<span class="keyword">from</span> mybatis.student <span class="keyword">where</span> tid=<span class="comment">#&#123;id&#125;;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>

<p><u><strong>注意</strong>：getStudent中的#{id}是从getTeacherAndStudent2中查询得到的tid并不是从方法传过来的参数</u></p>
<h2 id="（2）第二种按照结果嵌套查询，关联查询-1"><a href="#（2）第二种按照结果嵌套查询，关联查询-1" class="headerlink" title="（2）第二种按照结果嵌套查询，关联查询"></a>（2）第二种按照结果嵌套查询，关联查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id="getTeacherAndStudent" resultMap="TeacherAndStudent" parameterType="_int"&gt;</span><br><span class="line"><span class="keyword">select</span> t.name tname,t.id,s.name sname,s.id <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">from</span> mybatis.teacher t ,mybatis.student s</span><br><span class="line"><span class="keyword">where</span> s.tid=t.id <span class="keyword">and</span> t.id=<span class="comment">#&#123;tid&#125;;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br><span class="line">&lt;resultMap <span class="keyword">id</span>=<span class="string">"TeacherAndStudent"</span> <span class="keyword">type</span>=<span class="string">"Teacher"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">result</span> property=<span class="string">"id"</span> <span class="keyword">column</span>=<span class="string">"id"</span>/&gt;</span><br><span class="line">    &lt;<span class="keyword">result</span> property=<span class="string">"name"</span> <span class="keyword">column</span>=<span class="string">"tname"</span>/&gt;</span><br><span class="line">    &lt;!<span class="comment">--泛型用ofType--&gt;</span></span><br><span class="line">    &lt;collection property=<span class="string">"students"</span> ofType=<span class="string">"Student"</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">result</span> property=<span class="string">"id"</span> <span class="keyword">column</span>=<span class="string">"sid"</span>/&gt;</span><br><span class="line">        &lt;<span class="keyword">result</span> property=<span class="string">"name"</span> <span class="keyword">column</span>=<span class="string">"sname"</span>/&gt;</span><br><span class="line">        &lt;<span class="keyword">result</span> property=<span class="string">"tid"</span> <span class="keyword">column</span>=<span class="string">"tid"</span>/&gt;</span><br><span class="line">    &lt;/collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>

<h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><p>关联：association【多对一使用关键字】</p>
<p>集合：collection【一对多关键字】</p>
<p>javaType:用来指定实体类的指定类型</p>
<p>ofType：用来指定集合中的约束类型，例如：List<Student>,  ofType就该等于”Student”</p>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis生命周期</title>
    <url>/2020/04/28/mybatis%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="MyBatis生命周期"><a href="#MyBatis生命周期" class="headerlink" title="MyBatis生命周期"></a>MyBatis生命周期</h1><h2 id="1-SqlSessionFactoryBuilder"><a href="#1-SqlSessionFactoryBuilder" class="headerlink" title="1.SqlSessionFactoryBuilder"></a>1.SqlSessionFactoryBuilder</h2><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 </p>
<a id="more"></a>

<h2 id="2-SqlSessionFactory"><a href="#2-SqlSessionFactory" class="headerlink" title="2.SqlSessionFactory"></a>2.SqlSessionFactory</h2><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
<p><strong>（类似连接池）</strong></p>
<h2 id="3-SqlSession"><a href="#3-SqlSession" class="headerlink" title="3.SqlSession"></a>3.SqlSession</h2><p><strong>可以想象成连接池的一次连接请求</strong></p>
<p><strong>SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它最好用完就关闭</strong></p>
<h2 id="4-Mapper"><a href="#4-Mapper" class="headerlink" title="4.Mapper"></a>4.Mapper</h2><p><strong>代表具体的业务实现</strong>，<strong>底层实现是动态代理</strong></p>
<h2 id="5-图示"><a href="#5-图示" class="headerlink" title="5.图示"></a>5.图示</h2><img src="/2020/04/28/mybatis%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/1.png" class="" title="生命周期">

<img src="/2020/04/28/mybatis%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/2.png" class="" title="层次">

]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis配置druid</title>
    <url>/2020/04/27/MyBatis%E9%85%8D%E7%BD%AEdruid/</url>
    <content><![CDATA[<h1 id="MyBatis配置druid步骤"><a href="#MyBatis配置druid步骤" class="headerlink" title="MyBatis配置druid步骤"></a>MyBatis配置druid步骤</h1><h2 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1.导入依赖"></a>1.导入依赖</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="2-创建druid工厂类"><a href="#2-创建druid工厂类" class="headerlink" title="2.创建druid工厂类"></a>2.创建druid工厂类</h2><p>虽然Druid提供了一个同名的DruidDataSourceFactory类，但是不能在MyBatis中直接使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidUtils</span> <span class="keyword">extends</span> <span class="title">PooledDataSourceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DruidUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-创建druid配置文件druid-properties"><a href="#3-创建druid配置文件druid-properties" class="headerlink" title="3.创建druid配置文件druid.properties"></a>3.创建druid配置文件druid.properties</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">username=root</span><br><span class="line">password=<span class="number">123456</span></span><br><span class="line">jdbcUrl=jdbc:mysql:<span class="comment">///mybatis?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8</span></span><br><span class="line">driverClass=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>

<h2 id="4-设置mybatis-config-xml"><a href="#4-设置mybatis-config-xml" class="headerlink" title="4.设置mybatis-config.xml"></a>4.设置mybatis-config.xml</h2><h3 id="1-引入外部文件"><a href="#1-引入外部文件" class="headerlink" title="(1)引入外部文件"></a>(1)引入外部文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--引入外部配置文件--&gt;</span><br><span class="line">&lt;properties resource=<span class="string">"druid.properties"</span>/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-修改属性配置"><a href="#2-修改属性配置" class="headerlink" title="(2)修改属性配置"></a>(2)修改属性配置</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dataSource type=<span class="string">"com.ky.utils.DruidUtils"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"driverClass"</span> value=<span class="string">"$&#123;driverClass&#125;"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"jdbcUrl"</span> value=<span class="string">"$&#123;jdbcUrl&#125;"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"username"</span> value=<span class="string">"$&#123;username&#125;"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"password"</span> value=<span class="string">"$&#123;password&#125;"</span>/&gt;</span><br><span class="line">&lt;/dataSource&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：因为在DruidAbstractDataSource的源码为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> String jdbcUrl;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> String driverClass;</span><br></pre></td></tr></table></figure>

<p>所以设置property的时候尽量以driverClass和jdbcUrl命名，如果以默认driver命名（默认的url不改不会报错，不知道为啥）否则会报错</p>
<p>Caused by: org.apache.ibatis.reflection.ReflectionException: Could not set property ‘driver’ of ‘class com.alibaba.druid.pool.DruidDataSource’ with value ‘com.mysql.jdbc.Driver’ Cause: java.lang.IllegalArgumentException: argument type mismatch </p>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>关于update多个字段的某细节</title>
    <url>/2020/04/26/%E5%85%B3%E4%BA%8Eupdate%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84%E6%9F%90%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<h1 id="在使用update更新多条语句的时候不能使用and连接"><a href="#在使用update更新多条语句的时候不能使用and连接" class="headerlink" title="在使用update更新多条语句的时候不能使用and连接"></a>在使用update更新多条语句的时候不能使用and连接</h1><a id="more"></a>

<p>首先先来看一个现象</p>
<p>这是表的原始数据：</p>
<img src="/2020/04/26/%E5%85%B3%E4%BA%8Eupdate%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84%E6%9F%90%E7%BB%86%E8%8A%82/1.png" class="" title="原始数据">

<p>这是执行语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> <span class="keyword">id</span>=<span class="number">2</span> <span class="keyword">and</span> <span class="keyword">name</span>=<span class="string">'kyky'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>可结果却和预期不同：</p>
<img src="/2020/04/26/%E5%85%B3%E4%BA%8Eupdate%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84%E6%9F%90%E7%BB%86%E8%8A%82/2.png" class="" title="修改">

<p>为什么吗？</p>
<p>来看官方文档：</p>
<img src="/2020/04/26/%E5%85%B3%E4%BA%8Eupdate%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84%E6%9F%90%E7%BB%86%E8%8A%82/update%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3.png" class="" title="官方文档">

<p>assignment_list的格式是以逗号分隔的col_name=value列表 所以不能用and连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> <span class="keyword">id</span>=<span class="number">2</span> <span class="keyword">and</span> <span class="keyword">name</span>=<span class="string">'kyky'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="comment">--相当于以下语句</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> <span class="keyword">id</span>= (<span class="number">2</span> <span class="keyword">and</span> <span class="keyword">name</span>=<span class="string">'kyky'</span>) <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="comment">/*(2 and name='kyky')返回的是一个布尔值flase,子啊数据库中flase为0，所以原本改修改为2的id变成了0，而name不改变。*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么set不能存重复的值</title>
    <url>/2020/04/25/%E4%B8%BA%E4%BB%80%E4%B9%88set%E4%B8%8D%E8%83%BD%E5%AD%98%E9%87%8D%E5%A4%8D%E7%9A%84%E5%80%BC/</url>
    <content><![CDATA[<h1 id="为什么set不能存储重复的值"><a href="#为什么set不能存储重复的值" class="headerlink" title="为什么set不能存储重复的值"></a>为什么set不能存储重复的值</h1><p>首先看一段代码<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Set set=<span class="keyword">new</span> HashSet();</span><br><span class="line">        String str1=<span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        String str2=<span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        String str3=<span class="string">"重地"</span>;</span><br><span class="line">        String str4=<span class="string">"通话"</span>;</span><br><span class="line">        String str5=<span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">        set.add(str1);</span><br><span class="line">        set.add(str2);</span><br><span class="line">        set.add(str3);</span><br><span class="line">        set.add(str4);</span><br><span class="line">        set.add(str5);</span><br><span class="line"></span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/04/25/%E4%B8%BA%E4%BB%80%E4%B9%88set%E4%B8%8D%E8%83%BD%E5%AD%98%E9%87%8D%E5%A4%8D%E7%9A%84%E5%80%BC/%E6%8E%A7%E5%88%B6%E5%8F%B0.png" class="" title="输出">

<p>原因：</p>
<img src="/2020/04/25/%E4%B8%BA%E4%BB%80%E4%B9%88set%E4%B8%8D%E8%83%BD%E5%AD%98%E9%87%8D%E5%A4%8D%E7%9A%84%E5%80%BC/06_Set%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E5%85%83%E7%B4%A0%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%8E%9F%E7%90%86.bmp" class="" title="原理">

<p>补充：</p>
<img src="/2020/04/25/%E4%B8%BA%E4%BB%80%E4%B9%88set%E4%B8%8D%E8%83%BD%E5%AD%98%E9%87%8D%E5%A4%8D%E7%9A%84%E5%80%BC/05_HashSet%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89.bmp" class="" title="HashSet">]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>线程与同步</title>
    <url>/2020/04/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="第一章-线程"><a href="#第一章-线程" class="headerlink" title="第一章 线程"></a>第一章 线程</h1><h2 id="1-1-多线程原理"><a href="#1-1-多线程原理" class="headerlink" title="1. 1 多线程原理"></a>1. 1 多线程原理</h2><h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><a id="more"></a>

<h3 id="自定义线程类："><a href="#自定义线程类：" class="headerlink" title="自定义线程类："></a>自定义线程类：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 利用继承中的特点</span></span><br><span class="line"><span class="comment">* 将线程名称传递 进行设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 重写run方法</span></span><br><span class="line"><span class="comment">* 定义线程要执行的代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =  <span class="number">0</span> ; i &lt;  <span class="number">20</span> ; i++) &#123;</span><br><span class="line"><span class="comment">//getName()方法 来自父亲</span></span><br><span class="line">    <span class="comment">//getName()方法 来自父亲</span></span><br><span class="line">System.out.println(getName()+i);</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试类："><a href="#测试类：" class="headerlink" title="测试类："></a>测试类：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"这里是main线程"</span>);</span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread(<span class="string">"小强"</span>);</span><br><span class="line">mt.start();<span class="comment">//开启了一个新的线程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =  <span class="number">0</span> ; i &lt;  <span class="number">20</span> ; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"旺财:"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h3><img src="/2020/04/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5/%E7%BA%BF%E7%A8%8B%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="" title="线程流程图">

<p>程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的<br>start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。</p>
<p>通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？我们再来讲一讲原理。</p>
<p>多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明：</p>
<img src="/2020/04/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5/%E6%A0%88%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86%E5%9B%BE.bmp" class="" title="栈内存图">

<p>多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。</p>
<h3 id="当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。"><a href="#当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。" class="headerlink" title="当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。"></a>当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。</h3><h2 id="1-2-Thread类"><a href="#1-2-Thread类" class="headerlink" title="1. 2 Thread类"></a>1. 2 Thread类</h2><p>在上一天内容中我们已经可以完成最基本的线程开启，那么在我们完成操作过程中用到了java.lang.Thread类，<br>API中该类中定义了有关线程的一些方法，具体如下：</p>
<p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span>:分配一个新的线程对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String name)</span>:分配一个指定名字的新的线程对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span>:分配一个带有指定目标新的线程对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target,String name)</span>:分配一个带有指定目标新的线程对象并指定名字。</span></span><br></pre></td></tr></table></figure>

<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span>:获取当前线程名称。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span>:导致此线程开始执行</span>; Java虚拟机调用此线程的run方法。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>:此线程要执行的任务在此处定义代码。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span>:使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span>:返回对当前正在执行的线程对象的引用。</span></span><br></pre></td></tr></table></figure>

<p>翻阅API后得知创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式，方式一我<br>们上一天已经完成，接下来讲解方式二实现的方式。</p>
<h2 id="1-3-创建线程方式二"><a href="#1-3-创建线程方式二" class="headerlink" title="1. 3 创建线程方式二"></a>1. 3 创建线程方式二</h2><p>采用java.lang.Runnable也是非常常见的一种，我们只需要重写run方法即可。</p>
<p>步骤如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</span><br><span class="line"><span class="number">2</span>. 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正</span><br><span class="line">的线程对象。</span><br><span class="line"><span class="number">3</span>. 调用线程对象的start()方法来启动线程。</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =  <span class="number">0</span> ; i &lt;  <span class="number">20</span> ; i++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建自定义类对象 线程任务对象</span></span><br><span class="line">MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"><span class="comment">//创建线程对象</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(mr, <span class="string">"小强"</span>);</span><br><span class="line">t.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =  <span class="number">0</span> ; i &lt;  <span class="number">20</span> ; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"旺财 "</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程<br>代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。</p>
<p>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread<br>对象的start()方法来运行多线程代码。</p>
<p>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现<br>Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程<br>编程的基础。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tips:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。</span><br><span class="line">而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。</span><br></pre></td></tr></table></figure>

<h2 id="1-4-Thread和Runnable的区别"><a href="#1-4-Thread和Runnable的区别" class="headerlink" title="1. 4 Thread和Runnable的区别"></a>1. 4 Thread和Runnable的区别</h2><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。</p>
<p>总结：</p>
<p>实现Runnable接口比继承Thread类所具有的优势：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 适合多个相同的程序代码的线程去共享同一个资源。</span><br><span class="line"><span class="number">2</span>. 可以避免java中的单继承的局限性。</span><br><span class="line"><span class="number">3</span>. 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</span><br><span class="line"><span class="number">4</span>. 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</span><br><span class="line">扩充：在java中，每次程序运行至少启动 <span class="number">2</span> 个线程。一个是main线程，一个是垃圾收集线程。因为每当使用</span><br><span class="line">java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进</span><br><span class="line">程。</span><br></pre></td></tr></table></figure>

<h2 id="1-5-匿名内部类方式实现线程的创建"><a href="#1-5-匿名内部类方式实现线程的创建" class="headerlink" title="1. 5 匿名内部类方式实现线程的创建"></a>1. 5 匿名内部类方式实现线程的创建</h2><h3 id="使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。"><a href="#使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。" class="headerlink" title="使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。"></a>使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。</h3><p>使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>^ <span class="class"><span class="keyword">class</span>^ <span class="title">NoNameInnerClassThread</span>^ </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// new Runnable()&#123;</span></span><br><span class="line"><span class="comment">// public void run()&#123;</span></span><br><span class="line"><span class="comment">// for (int i =  0 ; i &lt;  20 ; i++) &#123;</span></span><br><span class="line"><span class="comment">// System.out.println("张宇:"+i);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;; //‐‐‐这个整体 相当于new MyRunnable()</span></span><br><span class="line">Runnable r = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =  <span class="number">0</span> ; i &lt;  <span class="number">20</span> ; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"张宇:"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Thread(r).start();</span><br></pre></td></tr></table></figure>

<h1 id="第二章-线程安全"><a href="#第二章-线程安全" class="headerlink" title="第二章 线程安全"></a>第二章 线程安全</h1><h2 id="2-1-线程安全"><a href="#2-1-线程安全" class="headerlink" title="2. 1 线程安全"></a>2. 1 线程安全</h2><h3 id="如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样"><a href="#如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样" class="headerlink" title="如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样"></a>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样</h3><h3 id="的，而且其他的变量的值也和预期的是一样的，就是线程安全的。"><a href="#的，而且其他的变量的值也和预期的是一样的，就是线程安全的。" class="headerlink" title="的，而且其他的变量的值也和预期的是一样的，就是线程安全的。"></a>的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</h3><h3 id="我们通过一个案例，演示线程的安全问题："><a href="#我们通过一个案例，演示线程的安全问题：" class="headerlink" title="我们通过一个案例，演示线程的安全问题："></a>我们通过一个案例，演示线程的安全问题：</h3><h3 id="电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是-“葫芦娃大战奥特曼”，本次电影的座位共-100-个"><a href="#电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是-“葫芦娃大战奥特曼”，本次电影的座位共-100-个" class="headerlink" title="电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “葫芦娃大战奥特曼”，本次电影的座位共 100 个"></a>电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “葫芦娃大战奥特曼”，本次电影的座位共 100 个</h3><h3 id="本场电影只能卖-100-张票-。"><a href="#本场电影只能卖-100-张票-。" class="headerlink" title="(本场电影只能卖 100 张票)。"></a>(本场电影只能卖 100 张票)。</h3><h3 id="我们来模拟电影院的售票窗口，实现多个窗口同时卖-“葫芦娃大战奥特曼”这场电影票-多个窗口一起卖这-100-张票"><a href="#我们来模拟电影院的售票窗口，实现多个窗口同时卖-“葫芦娃大战奥特曼”这场电影票-多个窗口一起卖这-100-张票" class="headerlink" title="我们来模拟电影院的售票窗口，实现多个窗口同时卖 “葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这 100 张票)"></a>我们来模拟电影院的售票窗口，实现多个窗口同时卖 “葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这 100 张票)</h3><p>需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟</p>
<p>模拟票：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =  <span class="number">0</span> ; i &lt;  <span class="number">20</span> ; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"费玉清:"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ticket =  <span class="number">100</span> ;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 执行卖票操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//每个窗口卖票的操作</span></span><br><span class="line"><span class="comment">//窗口 永远开启</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ticket &gt;  <span class="number">0</span> ) &#123;<span class="comment">//有票 可以卖</span></span><br><span class="line"><span class="comment">//出票操作</span></span><br><span class="line"><span class="comment">//使用sleep模拟一下出票时间</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep( <span class="number">100</span> );</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取当前线程对象的名字</span></span><br><span class="line">String name = Thread.currentThread().getName();</span><br><span class="line">System.out.println(name + <span class="string">"正在卖:"</span> + ticket‐‐);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试类：-1"><a href="#测试类：-1" class="headerlink" title="测试类："></a>测试类：</h3><h3 id="结果中有一部分这样现象："><a href="#结果中有一部分这样现象：" class="headerlink" title="结果中有一部分这样现象："></a>结果中有一部分这样现象：</h3><img src="/2020/04/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.png" class="" title="线程安全问题">

<h3 id="发现程序出现了两个问题："><a href="#发现程序出现了两个问题：" class="headerlink" title="发现程序出现了两个问题："></a>发现程序出现了两个问题：</h3><h3 id="1-相同的票数-比如-5-这张票被卖了两回。"><a href="#1-相同的票数-比如-5-这张票被卖了两回。" class="headerlink" title="1. 相同的票数,比如 5 这张票被卖了两回。"></a>1. 相同的票数,比如 5 这张票被卖了两回。</h3><h3 id="2-不存在的票，比如-0-票与-1-票，是不存在的。"><a href="#2-不存在的票，比如-0-票与-1-票，是不存在的。" class="headerlink" title="2. 不存在的票，比如 0 票与- 1 票，是不存在的。"></a>2. 不存在的票，比如 0 票与- 1 票，是不存在的。</h3><h3 id="这种问题，几个窗口-线程-票数不同步了，这种问题称为线程不安全。"><a href="#这种问题，几个窗口-线程-票数不同步了，这种问题称为线程不安全。" class="headerlink" title="这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。"></a>这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。</h3><h3 id="线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写"><a href="#线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写" class="headerlink" title="线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写"></a>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写</h3><h3 id="操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，"><a href="#操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，" class="headerlink" title="操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，"></a>操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，</h3><h3 id="否则的话就可能影响线程安全。"><a href="#否则的话就可能影响线程安全。" class="headerlink" title="否则的话就可能影响线程安全。"></a>否则的话就可能影响线程安全。</h3><h2 id="2-2-线程同步"><a href="#2-2-线程同步" class="headerlink" title="2. 2 线程同步"></a>2. 2 线程同步</h2><h3 id="当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。"><a href="#当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。" class="headerlink" title="当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。"></a>当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。</h3><p>要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制<br>(synchronized)来解决。</p>
<p>根据案例简述：</p>
<p>为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。</p>
<p>那么怎么去使用呢？有三种方式完成同步操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建线程任务对象</span></span><br><span class="line">Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"><span class="comment">//创建三个窗口对象</span></span><br><span class="line">Thread t <span class="number">1</span>  = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口 1 "</span>);</span><br><span class="line">Thread t <span class="number">2</span>  = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口 2 "</span>);</span><br><span class="line">Thread t <span class="number">3</span>  = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口 3 "</span>);</span><br><span class="line"><span class="comment">//同时卖票</span></span><br><span class="line">t <span class="number">1</span> .start();</span><br><span class="line">t <span class="number">2</span> .start();</span><br><span class="line">t <span class="number">3</span> .start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="窗口-1-线程进入操作的时候，窗口-2-和窗口-3-线程只能在外等着，窗口-1-操作结束，窗口-1-和窗口-2-和窗口-3-才有机会进入代码"><a href="#窗口-1-线程进入操作的时候，窗口-2-和窗口-3-线程只能在外等着，窗口-1-操作结束，窗口-1-和窗口-2-和窗口-3-才有机会进入代码" class="headerlink" title="窗口 1 线程进入操作的时候，窗口 2 和窗口 3 线程只能在外等着，窗口 1 操作结束，窗口 1 和窗口 2 和窗口 3 才有机会进入代码"></a>窗口 1 线程进入操作的时候，窗口 2 和窗口 3 线程只能在外等着，窗口 1 操作结束，窗口 1 和窗口 2 和窗口 3 才有机会进入代码</h3><h3 id="去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU"><a href="#去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU" class="headerlink" title="去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU"></a>去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU</h3><h3 id="资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。"><a href="#资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。" class="headerlink" title="资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。"></a>资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。</h3><h3 id="1-同步代码块。"><a href="#1-同步代码块。" class="headerlink" title="1. 同步代码块。"></a>1. 同步代码块。</h3><h3 id="2-同步方法。"><a href="#2-同步方法。" class="headerlink" title="2. 同步方法。"></a>2. 同步方法。</h3><h3 id="3-锁机制。"><a href="#3-锁机制。" class="headerlink" title="3. 锁机制。"></a>3. 锁机制。</h3><h2 id="2-3-同步代码块"><a href="#2-3-同步代码块" class="headerlink" title="2. 3 同步代码块"></a>2. 3 同步代码块</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">同步代码块：<span class="keyword">synchronized</span>关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</span><br></pre></td></tr></table></figure>

<p>格式:</p>
<h3 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁:"></a>同步锁:</h3><h3 id="对象的同步锁只是一个概念-可以想象为在对象上标记了一个锁"><a href="#对象的同步锁只是一个概念-可以想象为在对象上标记了一个锁" class="headerlink" title="对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁."></a>对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.</h3><h3 id="1-锁对象-可以是任意类型。"><a href="#1-锁对象-可以是任意类型。" class="headerlink" title="1. 锁对象 可以是任意类型。"></a>1. 锁对象 可以是任意类型。</h3><h3 id="2-多个线程对象-要使用同一把锁。"><a href="#2-多个线程对象-要使用同一把锁。" class="headerlink" title="2. 多个线程对象 要使用同一把锁。"></a>2. 多个线程对象 要使用同一把锁。</h3><h3 id="注意-在任何时候-最多允许一个线程拥有同步锁-谁拿到锁就进入代码块-其他的线程只能在外等着"><a href="#注意-在任何时候-最多允许一个线程拥有同步锁-谁拿到锁就进入代码块-其他的线程只能在外等着" class="headerlink" title="注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着"></a>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着</h3><h3 id="BLOCKED-。"><a href="#BLOCKED-。" class="headerlink" title="(BLOCKED)。"></a>(BLOCKED)。</h3><h3 id="使用同步代码块解决代码："><a href="#使用同步代码块解决代码：" class="headerlink" title="使用同步代码块解决代码："></a>使用同步代码块解决代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">需要同步操作的代码</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ticket =  <span class="number">100</span> ;</span><br><span class="line">Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 执行卖票操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//每个窗口卖票的操作</span></span><br><span class="line"><span class="comment">//窗口 永远开启</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line"><span class="keyword">if</span>(ticket&gt; <span class="number">0</span> )&#123;<span class="comment">//有票 可以卖</span></span><br><span class="line"><span class="comment">//出票操作</span></span><br><span class="line"><span class="comment">//使用sleep模拟一下出票时间</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep( <span class="number">50</span> );</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取当前线程对象的名字</span></span><br><span class="line">String name = Thread.currentThread().getName();</span><br><span class="line">System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="当使用了同步代码块后，上述的线程的安全问题，解决了。"><a href="#当使用了同步代码块后，上述的线程的安全问题，解决了。" class="headerlink" title="当使用了同步代码块后，上述的线程的安全问题，解决了。"></a>当使用了同步代码块后，上述的线程的安全问题，解决了。</h3><h2 id="2-4-同步方法"><a href="#2-4-同步方法" class="headerlink" title="2. 4 同步方法"></a>2. 4 同步方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">同步方法:使用<span class="keyword">synchronized</span>修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外</span><br><span class="line">等着。</span><br></pre></td></tr></table></figure>

<p>格式：</p>
<h3 id="同步锁是谁"><a href="#同步锁是谁" class="headerlink" title="同步锁是谁?"></a>同步锁是谁?</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于非<span class="keyword">static</span>方法,同步锁就是<span class="keyword">this</span>。</span><br><span class="line">对于<span class="keyword">static</span>方法,我们使用当前方法所在类的字节码对象(类名<span class="class">.<span class="keyword">class</span>)。</span></span><br></pre></td></tr></table></figure>

<p>使用同步方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ticket =  <span class="number">100</span> ;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 执行卖票操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//每个窗口卖票的操作</span></span><br><span class="line"><span class="comment">//窗口 永远开启</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">sellTicket();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 锁对象 是 谁调用这个方法 就是谁</span></span><br><span class="line"><span class="comment">* 隐含 锁对象 就是 this</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ticket&gt; <span class="number">0</span> )&#123;<span class="comment">//有票 可以卖</span></span><br><span class="line"><span class="comment">//出票操作</span></span><br><span class="line"><span class="comment">//使用sleep模拟一下出票时间</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep( <span class="number">100</span> );</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br></pre></td></tr></table></figure>

<h2 id="2-5-Lock锁"><a href="#2-5-Lock锁" class="headerlink" title="2. 5 Lock锁"></a>2. 5 Lock锁</h2><p>java.util.concurrent.locks.Lock机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,<br>同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。</p>
<p>Lock锁也称同步锁，加锁与释放锁方法化了，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>:加同步锁。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>:释放同步锁。</span></span><br></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>; </span><br><span class="line"></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock(); </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">\* 执行卖票操作 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">//每个窗口卖票的操作 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口 永远开启 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123; </span><br><span class="line"></span><br><span class="line">lock.lock(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;<span class="comment">//有票 可以卖 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//出票操作 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用sleep模拟一下出票时间 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">50</span>); </span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO Auto‐generated catch block </span></span><br><span class="line"></span><br><span class="line">e.printStackTrace(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前线程对象的名字 </span></span><br><span class="line"></span><br><span class="line">String name = Thread.currentThread().getName(); </span><br><span class="line"></span><br><span class="line">System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock.unlock(); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第三章-线程状态"><a href="#第三章-线程状态" class="headerlink" title="第三章 线程状态"></a>第三章 线程状态</h1><h3 id="获取当前线程对象的名字"><a href="#获取当前线程对象的名字" class="headerlink" title="//获取当前线程对象的名字"></a>//获取当前线程对象的名字</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = Thread.currentThread().getName();</span><br><span class="line">System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ticket =  <span class="number">100</span> ;</span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 执行卖票操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//每个窗口卖票的操作</span></span><br><span class="line"><span class="comment">//窗口 永远开启</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">if</span>(ticket&gt; <span class="number">0</span> )&#123;<span class="comment">//有票 可以卖</span></span><br><span class="line"><span class="comment">//出票操作</span></span><br><span class="line"><span class="comment">//使用sleep模拟一下出票时间</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep( <span class="number">50</span> );</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取当前线程对象的名字</span></span><br><span class="line">String name = Thread.currentThread().getName();</span><br><span class="line">System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);</span><br><span class="line">&#125;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程状态-导致状态发生条件"><a href="#线程状态-导致状态发生条件" class="headerlink" title="线程状态 导致状态发生条件"></a>线程状态 导致状态发生条件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NEW(新建) 线程刚被创建，但是并未启动。还没调用start方法。</span><br><span class="line">Runnable(可</span><br><span class="line">运行)</span><br><span class="line">线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操</span><br><span class="line">作系统处理器。</span><br><span class="line">Blocked(锁阻</span><br><span class="line">塞)</span><br><span class="line">当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状</span><br><span class="line">态；当该线程持有锁时，该线程将变成Runnable状态。</span><br><span class="line">Waiting(无限</span><br><span class="line">等待)</span><br><span class="line">一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个</span><br><span class="line">状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。</span><br><span class="line">Timed</span><br><span class="line">Waiting(计时</span><br><span class="line">等待)</span><br><span class="line">同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态</span><br><span class="line">将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、</span><br><span class="line">Object.wait。</span><br><span class="line">Teminated(被</span><br><span class="line">终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</span><br></pre></td></tr></table></figure>

<h2 id="3-1-线程状态概述"><a href="#3-1-线程状态概述" class="headerlink" title="3. 1 线程状态概述"></a>3. 1 线程状态概述</h2><h3 id="当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，"><a href="#当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，" class="headerlink" title="当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，"></a>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，</h3><p>有几种状态呢？在API中java.lang.Thread.State这个枚举中给出了六种线程状态：</p>
<img src="/2020/04/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5/%E7%8A%B6%E6%80%81.png" class="" title="六种状态">

<p>这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析</p>
<h3 id="我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几"><a href="#我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几" class="headerlink" title="我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几"></a>我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几</h3><p>个状态呢，新建与被终止还是很容易理解的，我们就研究一下线程从Runnable（可运行）状态与非运行状态之间<br>的转换问题。</p>
<h2 id="3-2-Timed-Waiting（计时等待）"><a href="#3-2-Timed-Waiting（计时等待）" class="headerlink" title="3. 2 Timed Waiting（计时等待）"></a>3. 2 Timed Waiting（计时等待）</h2><p>Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。单独<br>的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？</p>
<p>在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就<br>强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。</p>
<p>其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等<br>待)，那么我们通过一个案例加深对该状态的一个理解。</p>
<p>实现一个计数器，计数到 100 ，在每个数字之间暂停 1 秒，每隔 10 个数字输出一个字符串</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =  <span class="number">0</span> ; i &lt;  <span class="number">100</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((i) %  <span class="number">10</span>  ==  <span class="number">0</span> ) &#123;</span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐‐"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">  System.out.print(i);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep( <span class="number">1000</span> );</span><br><span class="line">System.out.print(<span class="string">" 线程睡眠 1 秒！\n"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> MyThread().start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过案例可以发现，sleep方法的使用还是很简单的。我们需要记住下面几点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协</span><br><span class="line">作关系。</span><br><span class="line"><span class="number">2</span>. 为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程</span><br><span class="line">中会睡眠</span><br><span class="line"><span class="number">3</span>. sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。</span><br><span class="line">小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就</span><br><span class="line">开始立刻执行。</span><br></pre></td></tr></table></figure>

<p>Timed Waiting 线程状态图：</p>
<img src="/2020/04/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5/%E8%AE%A1%E6%97%B6%E7%AD%89%E5%BE%85.png" class="" title="计时等待">

<h2 id="3-3-BLOCKED（锁阻塞）"><a href="#3-3-BLOCKED（锁阻塞）" class="headerlink" title="3. 3 BLOCKED（锁阻塞）"></a>3. 3 BLOCKED（锁阻塞）</h2><p>Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。</p>
<p>我们已经学完同步机制，那么这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获<br>取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。</p>
<p>这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态，而<br>这部分内容作为扩充知识点带领大家了解一下。</p>
<p>Blocked 线程状态图</p>
<img src="/2020/04/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5/%E9%94%81%E9%98%BB%E5%A1%9E.png" class="" title="锁阻塞">



<h2 id="3-4-Waiting（无限等待）"><a href="#3-4-Waiting（无限等待）" class="headerlink" title="3. 4 Waiting（无限等待）"></a>3. 4 Waiting（无限等待）</h2><p>Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。</p>
<p>那么我们之前遇到过这种状态吗？答案是并没有，但并不妨碍我们进行一个简单深入的了解。我们通过一段代码来<br>学习一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitingTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 演示waiting</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println( Thread.currentThread().getName() +<span class="string">"=== 获取到锁对</span></span><br></pre></td></tr></table></figure>

<p>通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的<br>Object.notify()方法 或 Object.notifyAll()方法。</p>
<p>其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，<br>多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞<br>争，但更多时候你们更多是一起合作以完成某些任务。</p>
<p>当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入<br>了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了<br>notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入<br>Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。</p>
<p>Waiting 线程状态图</p>
<img src="/2020/04/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5/%E6%97%A0%E9%99%90%E7%AD%89%E5%BE%85.png" class="" title="无限等待">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitingTest</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object(); <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 演示waiting new Thread(new Runnable() &#123; @Override public void run() &#123; while (true)&#123; synchronized (obj)&#123; try &#123;System.out.println( Thread.currentThread().getName() +"=== 获取到锁对</span></span><br><span class="line">象，调用wait方法，进入waiting状态，释放锁对象<span class="string">");</span></span><br><span class="line"><span class="string">obj.wait(); //无限等待</span></span><br><span class="line"><span class="string">//obj.wait( 5000 ); //计时等待,  5 秒 时间到，自动醒来</span></span><br><span class="line"><span class="string">&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="string">e.printStackTrace();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">System.out.println( Thread.currentThread().getName() + "</span>=== 从waiting状</span><br><span class="line">态醒来，获取到锁对象，继续执行了<span class="string">");</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;,"</span>等待线程<span class="string">").start();</span></span><br><span class="line"><span class="string">new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="string">@Override</span></span><br><span class="line"><span class="string">public void run() &#123;</span></span><br><span class="line"><span class="string">// while (true)&#123; //每隔 3 秒 唤醒一次</span></span><br><span class="line"><span class="string">try &#123;</span></span><br><span class="line"><span class="string">System.out.println( Thread.currentThread().getName() +"</span>‐‐‐‐‐ 等待 <span class="number">3</span> 秒钟<span class="string">");</span></span><br><span class="line"><span class="string">Thread.sleep( 3000 );</span></span><br><span class="line"><span class="string">&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="string">e.printStackTrace();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">synchronized (obj)&#123;</span></span><br><span class="line"><span class="string">System.out.println( Thread.currentThread().getName() +"</span>‐‐‐‐‐ 获取到锁对</span><br><span class="line">象,调用notify方法，释放锁对象<span class="string">");</span></span><br><span class="line"><span class="string">obj.notify();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// &#125;</span></span><br><span class="line"><span class="string">&#125;,"</span>唤醒线程<span class="string">").start();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-5-补充知识点"><a href="#3-5-补充知识点" class="headerlink" title="3. 5 补充知识点"></a>3. 5 补充知识点</h2><h3 id="到此为止我们已经对线程状态有了基本的认识，想要有更多的了解，详情可以见下图："><a href="#到此为止我们已经对线程状态有了基本的认识，想要有更多的了解，详情可以见下图：" class="headerlink" title="到此为止我们已经对线程状态有了基本的认识，想要有更多的了解，详情可以见下图："></a>到此为止我们已经对线程状态有了基本的认识，想要有更多的了解，详情可以见下图：</h3><img src="/2020/04/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.png" class="" title="线程状态图">

<p>一条有意思的tips:</p>
<p>我们在翻阅API的时候会发现Timed Waiting（计时等待） 与 Waiting（无限等待） 状态联系还是很紧密的，<br>比如Waiting（无限等待） 状态中wait方法是空参的，而timed waiting（计时等待） 中wait方法是带参的。<br>这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是<br>如果提前得到（唤醒）通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两<br>得。如果没有得到（唤醒）通知，那么线程就处于Timed Waiting状态,直到倒计时完毕自动醒来；如果在倒<br>计时期间得到（唤醒）通知，那么线程从Timed Waiting状态立刻唤醒。</p>
]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>构造代码块与构造器执行顺序</title>
    <url>/2020/04/21/%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="构造代码块与构造器执行顺序"><a href="#构造代码块与构造器执行顺序" class="headerlink" title="构造代码块与构造器执行顺序"></a>构造代码块与构造器执行顺序</h1><p><strong>构造代码块：</strong>定义在类的成员位置，直接使用{ }，在{}中写代码内容。</p>
<p>位置：类中，方法外，和方法并列，和先后位置无关。</p>
<p>执行时机：创建对象的时候执行一次。在构造方法隐式3步的最后一步。当构造代码块执行结束之后，开始执行构造方法本身的代码内容</p>
<a id="more"></a>

<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line">  <span class="comment">// 构造代码块</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 执行语句 </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造代码块和构造方法执行顺序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsCode</span></span>&#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="comment">// 空参构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConsCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//System.out.println("HelloWorld!");</span></span><br><span class="line">  	System.out.println(<span class="string">"11我在构造代码块执行结束之后执行..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 给变量a赋值的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConsCode</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">  	System.out.println(<span class="string">"22我在构造代码块执行结束之后执行..."</span>);</span><br><span class="line">    <span class="comment">//System.out.println("HelloWorld!");</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 给变量ab同时赋值的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConsCode</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">    <span class="comment">//System.out.println("HelloWorld!");</span></span><br><span class="line">  	System.out.println(<span class="string">"33我在构造代码块执行结束之后执行..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 构造代码块</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"构造代码块!。。。。。。。。。。。。。。。"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorCodeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 分别使用3个构造方法创建对象，并运行程序，显示执行3遍HelloWorld！</span></span><br><span class="line">        ConsCode c1 = <span class="keyword">new</span> ConsCode();</span><br><span class="line">        ConsCode c2 = <span class="keyword">new</span> ConsCode(<span class="number">10</span>);</span><br><span class="line">        ConsCode c3 = <span class="keyword">new</span> ConsCode(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2020/04/21/%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/1.png" class="" title="结果">]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2020/04/20/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="内部类总结"><a href="#内部类总结" class="headerlink" title="内部类总结"></a>内部类总结</h1><p>1.普通内部类相当于外部类的一个成员变量，因此内部类可以直接访问外部类的成员，<strong>包括私有</strong>。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	        <span class="comment">//外部类名.内部类名 = 外部类对象.内部类对象</span></span><br><span class="line">	        Outer.Inner oi = <span class="keyword">new</span> Outer().<span class="keyword">new</span> Inner();            <span class="comment">//创建内部类对象</span></span><br><span class="line">	        oi.method();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.内部类有静态方法那么内部类必须是静态的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span><span class="comment">//报错原因 ：内部类不是静态的而方法是静态的 ，相当于盒子里有糖，但盒子却没有打开的方法（static的属性，从属于类）</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.局部变量必须加final修饰符。（随着方法运行完毕，局部变量会被释放，如果此时一个内部类还引用该变量则会报错。说到底就是变量的生命周期比内部类实例要短。而final保证这个变量始终指向一个对象，内部类就可以放心大胆地引用了。其实犯了和C++一样的毛病：返回了局部变量的引用）<br><strong><em>注意:在JDK8版本之中,方法内部类中调用方法中的局部变量,可以不需要修饰为 final,匿名内部类也是一样的，主要是JDK8之后增加了 Effectively final 功能\</em></strong>    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num =<span class="number">20</span>;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			System.out.println(num);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.面试题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要求：使用已知的变量，在控制台输出30，20，10。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num=<span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> num =<span class="number">20</span>;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">			<span class="keyword">int</span> num=<span class="number">30</span>;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">			</span>&#123;</span><br><span class="line">			System.out.println(num);</span><br><span class="line">			System.out.println(<span class="keyword">this</span>.num);</span><br><span class="line">			System.out.println(Outer.<span class="keyword">this</span>.num);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>Integer</title>
    <url>/2020/04/19/Integer/</url>
    <content><![CDATA[<h1 id="Integer的某些特点"><a href="#Integer的某些特点" class="headerlink" title="Integer的某些特点"></a>Integer的某些特点</h1><a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">3</span>;</span><br><span class="line">    Integer b=<span class="number">3</span>;<span class="comment">//等于 Integer b=Integer.valueOf(3);</span></span><br><span class="line">    Integer c=<span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">    Integer d=<span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//a在常量池 Integer会自动装箱拆箱 ==比较值</span></span><br><span class="line">    System.out.println(b.equals(a));<span class="comment">//true</span></span><br><span class="line">    System.out.println(a==b);<span class="comment">//ture</span></span><br><span class="line">    <span class="comment">//两个new出来的对象不会拆箱，==比较的是地址值</span></span><br><span class="line">    System.out.println(c==d);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"============"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Integer e=<span class="number">127</span>;</span><br><span class="line">    Integer f=<span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">    Integer g=<span class="number">128</span>;</span><br><span class="line">    Integer h=<span class="number">128</span>;</span><br><span class="line">    System.out.println(e==f);<span class="comment">//ture</span></span><br><span class="line">    System.out.println(g==h);<span class="comment">//flase</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/04/19/Integer/1.png" class="" title="结果">

<p>看一下源码大家都会明白，对于-128到127之间的数，会进行缓存，Integer e = 127时，会将127进行缓存，下次再写Integer f = 127时，就会直接从缓存中取，就不会new了。而大于127或者小于-128的值就会重新new。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk1.8不支持maven自带的tomcat6</title>
    <url>/2020/04/17/jdk1-8%E4%B8%8D%E6%94%AF%E6%8C%81maven%E8%87%AA%E5%B8%A6%E7%9A%84tomcat6/</url>
    <content><![CDATA[<h1 id="又被坑了啊"><a href="#又被坑了啊" class="headerlink" title="又被坑了啊"></a>又被坑了啊</h1><a id="more"></a>

<img src="/2020/04/17/jdk1-8%E4%B8%8D%E6%94%AF%E6%8C%81maven%E8%87%AA%E5%B8%A6%E7%9A%84tomcat6/%E9%94%99%E8%AF%AF.png" class="" title="错误">

<p>原因：我的maven所自带tomcat版本为6，jdk1.8不支持。</p>
<p>解决：在pom文件中加入以下代码</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">  &lt;configuration&gt;</span><br><span class="line">    &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt;</span><br><span class="line">    &lt;path&gt;/bos&lt;/path&gt;</span><br><span class="line">    &lt;port&gt;8888&lt;/port&gt;</span><br><span class="line">  &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意：这段代码是下载tomcat7插件，所以启动的时候要用tomcat7：run命令</strong></p>
]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2020/04/17/redis/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1-概念：-redis是一款高性能的NOSQL系列的非关系型数据库"><a href="#1-概念：-redis是一款高性能的NOSQL系列的非关系型数据库" class="headerlink" title="1.概念： redis是一款高性能的NOSQL系列的非关系型数据库"></a>1.概念： redis是一款高性能的NOSQL系列的非关系型数据库</h2><a id="more"></a>

<h3 id="1-1-什么是NOSQL"><a href="#1-1-什么是NOSQL" class="headerlink" title="1.1.什么是NOSQL"></a>1.1.什么是NOSQL</h3><p>​        NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。<br>​        随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</p>
<h3 id="1-1-1-NOSQL和关系型数据库比较"><a href="#1-1-1-NOSQL和关系型数据库比较" class="headerlink" title="1.1.1.    NOSQL和关系型数据库比较"></a>1.1.1.    NOSQL和关系型数据库比较</h3><p>​            优点：<br>​                1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。<br>​                2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。<br>​            3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。<br>​            4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。</p>
<p>​            缺点：<br>​            1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。<br>​            2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。<br>​            3）不提供关系型数据库对事务的处理。</p>
<h3 id="1-1-2-非关系型数据库的优势："><a href="#1-1-2-非关系型数据库的优势：" class="headerlink" title="1.1.2.    非关系型数据库的优势："></a>1.1.2.    非关系型数据库的优势：</h3><p>​            1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。<br>​            2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</p>
<h3 id="1-1-3-关系型数据库的优势："><a href="#1-1-3-关系型数据库的优势：" class="headerlink" title="1.1.3.    关系型数据库的优势："></a>1.1.3.    关系型数据库的优势：</h3><p>​            1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。<br>​            2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</p>
<h3 id="1-1-4-总结"><a href="#1-1-4-总结" class="headerlink" title="1.1.4.    总结"></a>1.1.4.    总结</h3><p>​            关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，<br>​            让NoSQL数据库对关系型数据库的不足进行弥补。<br>​            一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据</p>
<h2 id="1-2-主流的NOSQL产品"><a href="#1-2-主流的NOSQL产品" class="headerlink" title="1.2.主流的NOSQL产品"></a>1.2.主流的NOSQL产品</h2><p>​        •    键值(Key-Value)存储数据库<br>​                相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB<br>​                典型应用： 内容缓存，主要用于处理大量数据的高访问负载。<br>​                数据模型： 一系列键值对<br>​                优势： 快速查询<br>​                劣势： 存储的数据缺少结构化<br>​        •    列存储数据库<br>​                相关产品：Cassandra, HBase, Riak<br>​                典型应用：分布式的文件系统<br>​                数据模型：以列簇式存储，将同一列数据存在一起<br>​                优势：查找速度快，可扩展性强，更容易进行分布式扩展<br>​                劣势：功能相对局限<br>​        •    文档型数据库<br>​                相关产品：CouchDB、MongoDB<br>​                典型应用：Web应用（与Key-Value类似，Value是结构化的）<br>​                数据模型： 一系列键值对<br>​                优势：数据结构要求不严格<br>​                劣势： 查询性能不高，而且缺乏统一的查询语法<br>​        •    图形(Graph)数据库<br>​                相关数据库：Neo4J、InfoGrid、Infinite Graph<br>​                典型应用：社交网络<br>​                数据模型：图结构<br>​                优势：利用图结构相关算法。<br>​                劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</p>
<h2 id="1-3-什么是Redis"><a href="#1-3-什么是Redis" class="headerlink" title="1.3 什么是Redis"></a>1.3 什么是Redis</h2><p>​        Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：<br>​            1) 字符串类型 string<br>​            2) 哈希类型 hash<br>​            3) 列表类型 list<br>​            4) 集合类型 set<br>​            5) 有序集合类型 sortedset</p>
<h3 id="1-3-1-redis的应用场景"><a href="#1-3-1-redis的应用场景" class="headerlink" title="1.3.1 redis的应用场景"></a>1.3.1 redis的应用场景</h3><p>​            •    缓存（数据查询、短连接、新闻内容、商品内容等等）<br>​            •    聊天室的在线好友列表<br>​            •    任务队列。（秒杀、抢购、12306等等）<br>​            •    应用排行榜<br>​            •    网站访问统计<br>​            •    数据过期处理（可以精确到毫秒<br>​            •    分布式集群架构中的session分离</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>. 下载安装</span><br><span class="line">	<span class="number">1</span>. 官网：https:<span class="comment">//redis.io</span></span><br><span class="line">	<span class="number">2</span>. 中文网：http:<span class="comment">//www.redis.net.cn/</span></span><br><span class="line">	<span class="number">3</span>. 解压直接可以使用：</span><br><span class="line">		* redis.windows.conf：配置文件</span><br><span class="line">		* redis-cli.exe：redis的客户端</span><br><span class="line">		* redis-server.exe：redis服务器端</span><br><span class="line">	</span><br><span class="line"><span class="number">3</span>. 命令操作</span><br><span class="line">	<span class="number">1</span>. redis的数据结构：</span><br><span class="line">		* redis存储的是：key,value格式的数据，其中key都是字符串，value有<span class="number">5</span>种不同的数据结构</span><br><span class="line">			* value的数据结构：</span><br><span class="line">				<span class="number">1</span>) 字符串类型 string</span><br><span class="line">				<span class="number">2</span>) 哈希类型 hash ： map格式  </span><br><span class="line">				<span class="number">3</span>) 列表类型 list ： linkedlist格式。支持重复元素</span><br><span class="line">				<span class="number">4</span>) 集合类型 set  ： 不允许重复元素</span><br><span class="line">				<span class="number">5</span>) 有序集合类型 sortedset：不允许重复元素，且元素有顺序</span><br><span class="line">	</span><br><span class="line">	<span class="number">2</span>. 字符串类型 string</span><br><span class="line">		<span class="number">1</span>. 存储： set key value</span><br><span class="line">			<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set username zhangsan</span><br><span class="line">			OK</span><br><span class="line">		<span class="number">2</span>. 获取： get key</span><br><span class="line">			<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get username</span><br><span class="line">			<span class="string">"zhangsan"</span></span><br><span class="line">		<span class="number">3</span>. 删除： del key</span><br><span class="line">			<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; del age</span><br><span class="line">			(integer) <span class="number">1</span></span><br><span class="line">	<span class="number">3</span>. 哈希类型 hash</span><br><span class="line">		<span class="number">1</span>. 存储： hset key field value</span><br><span class="line">			<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hset myhash username lisi</span><br><span class="line">			(integer) <span class="number">1</span></span><br><span class="line">			<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hset myhash password <span class="number">123</span></span><br><span class="line">			(integer) <span class="number">1</span></span><br><span class="line">		<span class="number">2</span>. 获取： </span><br><span class="line">			* hget key field: 获取指定的field对应的值</span><br><span class="line">				<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hget myhash username</span><br><span class="line">				<span class="string">"lisi"</span></span><br><span class="line">			* hgetall key：获取所有的field和value</span><br><span class="line">				<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hgetall myhash</span><br><span class="line">				<span class="number">1</span>) <span class="string">"username"</span></span><br><span class="line">				<span class="number">2</span>) <span class="string">"lisi"</span></span><br><span class="line">				<span class="number">3</span>) <span class="string">"password"</span></span><br><span class="line">				<span class="number">4</span>) <span class="string">"123"</span></span><br><span class="line">				</span><br><span class="line">		<span class="number">3</span>. 删除： hdel key field</span><br><span class="line">			<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hdel myhash username</span><br><span class="line">			(integer) <span class="number">1</span></span><br><span class="line">	</span><br><span class="line">	<span class="number">4</span>. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）</span><br><span class="line">		<span class="number">1</span>. 添加：</span><br><span class="line">			<span class="number">1</span>. lpush key value: 将元素加入列表左表</span><br><span class="line">				</span><br><span class="line">			<span class="number">2</span>. rpush key value：将元素加入列表右边</span><br><span class="line">				</span><br><span class="line">				<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush myList a</span><br><span class="line">				(integer) <span class="number">1</span></span><br><span class="line">				<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush myList b</span><br><span class="line">				(integer) <span class="number">2</span></span><br><span class="line">				<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; rpush myList c</span><br><span class="line">				(integer) <span class="number">3</span></span><br><span class="line">		<span class="number">2</span>. 获取：</span><br><span class="line">			* lrange key start end ：范围获取</span><br><span class="line">				<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange myList <span class="number">0</span> -<span class="number">1</span></span><br><span class="line">				<span class="number">1</span>) <span class="string">"b"</span></span><br><span class="line">				<span class="number">2</span>) <span class="string">"a"</span></span><br><span class="line">				<span class="number">3</span>) <span class="string">"c"</span></span><br><span class="line">		<span class="number">3</span>. 删除：</span><br><span class="line">			* lpop key： 删除列表最左边的元素，并将元素返回</span><br><span class="line">			* rpop key： 删除列表最右边的元素，并将元素返回</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>. 集合类型 set ： 不允许重复元素</span><br><span class="line">	<span class="number">1</span>. 存储：sadd key value</span><br><span class="line">		<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd myset a</span><br><span class="line">		(integer) <span class="number">1</span></span><br><span class="line">		<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd myset a</span><br><span class="line">		(integer) <span class="number">0</span></span><br><span class="line">	<span class="number">2</span>. 获取：smembers key:获取set集合中所有元素</span><br><span class="line">		<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers myset</span><br><span class="line">		<span class="number">1</span>) <span class="string">"a"</span></span><br><span class="line">	<span class="number">3</span>. 删除：srem key value:删除set集合中的某个元素	</span><br><span class="line">		<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; srem myset a</span><br><span class="line">		(integer) <span class="number">1</span></span><br><span class="line"><span class="number">6</span>. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个<span class="keyword">double</span>类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</span><br><span class="line"></span><br><span class="line">	<span class="number">1</span>. 存储：zadd key score value</span><br><span class="line">		<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd mysort <span class="number">60</span> zhangsan</span><br><span class="line">		(integer) <span class="number">1</span></span><br><span class="line">		<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd mysort <span class="number">50</span> lisi</span><br><span class="line">		(integer) <span class="number">1</span></span><br><span class="line">		<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd mysort <span class="number">80</span> wangwu</span><br><span class="line">		(integer) <span class="number">1</span></span><br><span class="line">	<span class="number">2</span>. 获取：zrange key start end [withscores]</span><br><span class="line">		<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange mysort <span class="number">0</span> -<span class="number">1</span></span><br><span class="line">		<span class="number">1</span>) <span class="string">"lisi"</span></span><br><span class="line">		<span class="number">2</span>) <span class="string">"zhangsan"</span></span><br><span class="line">		<span class="number">3</span>) <span class="string">"wangwu"</span></span><br><span class="line"></span><br><span class="line">		<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange mysort <span class="number">0</span> -<span class="number">1</span> withscores</span><br><span class="line">		<span class="number">1</span>) <span class="string">"zhangsan"</span></span><br><span class="line">		<span class="number">2</span>) <span class="string">"60"</span></span><br><span class="line">		<span class="number">3</span>) <span class="string">"wangwu"</span></span><br><span class="line">		<span class="number">4</span>) <span class="string">"80"</span></span><br><span class="line">		<span class="number">5</span>) <span class="string">"lisi"</span></span><br><span class="line">		<span class="number">6</span>) <span class="string">"500"</span></span><br><span class="line">	<span class="number">3</span>. 删除：zrem key value</span><br><span class="line">		<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrem mysort lisi</span><br><span class="line">		(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>. 通用命令</span><br><span class="line">	<span class="number">1</span>. keys * : 查询所有的键</span><br><span class="line">	<span class="number">2</span>. type key ： 获取键对应的value的类型</span><br><span class="line">	<span class="number">3</span>. del key：删除指定的key value</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>. 持久化</span><br><span class="line">	<span class="number">1</span>. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。</span><br><span class="line">	<span class="number">2</span>. redis持久化机制：</span><br><span class="line">		<span class="number">1</span>. RDB：默认方式，不需要进行配置，默认就使用这种机制</span><br><span class="line">			* 在一定的间隔时间中，检测key的变化情况，然后持久化数据</span><br><span class="line">			<span class="number">1</span>. 编辑redis.windwos.conf文件</span><br><span class="line">				#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">				save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">				#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">				save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">				#   after 60 sec if at least 10000 keys changed</span><br><span class="line">				save <span class="number">60</span> <span class="number">10000</span></span><br><span class="line">				</span><br><span class="line">			<span class="number">2</span>. 重新启动redis服务器，并指定配置文件名称</span><br><span class="line">				D:\JavaWeb2018\day23_redis\资料\redis\windows-<span class="number">64</span>\redis-<span class="number">2.8</span><span class="number">.9</span>&gt;redis-server.exe redis.windows.conf	</span><br><span class="line">			</span><br><span class="line">		<span class="number">2</span>. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据</span><br><span class="line">			<span class="number">1</span>. 编辑redis.windwos.conf文件</span><br><span class="line">				appendonly no（关闭aof） --&gt; appendonly yes （开启aof）</span><br><span class="line">				</span><br><span class="line">				# appendfsync always ： 每一次操作都进行持久化</span><br><span class="line">				appendfsync everysec ： 每隔一秒进行一次持久化</span><br><span class="line">				# appendfsync no	 ： 不进行持久化</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>. Java客户端 Jedis</span><br><span class="line">	* Jedis: 一款java操作redis数据库的工具.</span><br><span class="line">	* 使用步骤：</span><br><span class="line">		<span class="number">1</span>. 下载jedis的jar包</span><br><span class="line">		<span class="number">2</span>. 使用</span><br><span class="line">			<span class="comment">//1. 获取连接</span></span><br><span class="line">    		Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line">   			<span class="comment">//2. 操作</span></span><br><span class="line">   			jedis.set(<span class="string">"username"</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line">    		<span class="comment">//3. 关闭连接</span></span><br><span class="line">    		jedis.close();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* Jedis操作各种redis中的数据结构</span><br><span class="line">	<span class="number">1</span>) 字符串类型 string</span><br><span class="line">		set</span><br><span class="line">		get</span><br><span class="line">		</span><br><span class="line">		 <span class="comment">//1. 获取连接</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">        <span class="comment">//2. 操作</span></span><br><span class="line">        <span class="comment">//存储</span></span><br><span class="line">        jedis.set(<span class="string">"username"</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line">        <span class="comment">//获取</span></span><br><span class="line">        String username = jedis.get(<span class="string">"username"</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以使用setex()方法存储可以指定过期时间的 key value</span></span><br><span class="line">        jedis.setex(<span class="string">"activecode"</span>,<span class="number">20</span>,<span class="string">"hehe"</span>);<span class="comment">//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line"></span><br><span class="line">	<span class="number">2</span>) 哈希类型 hash ： map格式  </span><br><span class="line">		hset</span><br><span class="line">		hget</span><br><span class="line">		hgetAll</span><br><span class="line">		<span class="comment">//1. 获取连接</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">        <span class="comment">//2. 操作</span></span><br><span class="line">        <span class="comment">// 存储hash</span></span><br><span class="line">        jedis.hset(<span class="string">"user"</span>,<span class="string">"name"</span>,<span class="string">"lisi"</span>);</span><br><span class="line">        jedis.hset(<span class="string">"user"</span>,<span class="string">"age"</span>,<span class="string">"23"</span>);</span><br><span class="line">        jedis.hset(<span class="string">"user"</span>,<span class="string">"gender"</span>,<span class="string">"female"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取hash</span></span><br><span class="line">        String name = jedis.hget(<span class="string">"user"</span>, <span class="string">"name"</span>);</span><br><span class="line">        System.out.println(name);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取hash的所有map中的数据</span></span><br><span class="line">Map&lt;String, String&gt; user = jedis.hgetAll(<span class="string">"user"</span>);</span><br><span class="line">	</span><br><span class="line"><span class="comment">// keyset</span></span><br><span class="line">Set&lt;String&gt; keySet = user.keySet();</span><br><span class="line"><span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">    <span class="comment">//获取value</span></span><br><span class="line">    String value = user.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">":"</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//3. 关闭连接</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>) 列表类型 list ： linkedlist格式。支持重复元素</span><br><span class="line">	lpush / rpush</span><br><span class="line">	lpop / rpop</span><br><span class="line">	lrange start end : 范围获取</span><br><span class="line">	</span><br><span class="line">	 <span class="comment">//1. 获取连接</span></span><br><span class="line">       Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">       <span class="comment">//2. 操作</span></span><br><span class="line">       <span class="comment">// list 存储</span></span><br><span class="line">       jedis.lpush(<span class="string">"mylist"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);<span class="comment">//从左边存</span></span><br><span class="line">       jedis.rpush(<span class="string">"mylist"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);<span class="comment">//从右边存</span></span><br><span class="line">	</span><br><span class="line">       <span class="comment">// list 范围获取</span></span><br><span class="line">       List&lt;String&gt; mylist = jedis.lrange(<span class="string">"mylist"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">       System.out.println(mylist);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// list 弹出</span></span><br><span class="line">       String element1 = jedis.lpop(<span class="string">"mylist"</span>);<span class="comment">//c</span></span><br><span class="line">       System.out.println(element1);</span><br><span class="line">	</span><br><span class="line">       String element2 = jedis.rpop(<span class="string">"mylist"</span>);<span class="comment">//c</span></span><br><span class="line">       System.out.println(element2);</span><br><span class="line">	</span><br><span class="line">       <span class="comment">// list 范围获取</span></span><br><span class="line">       List&lt;String&gt; mylist2 = jedis.lrange(<span class="string">"mylist"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">       System.out.println(mylist2);</span><br><span class="line">	</span><br><span class="line">       <span class="comment">//3. 关闭连接</span></span><br><span class="line">       jedis.close();</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>) 集合类型 set  ： 不允许重复元素</span><br><span class="line">	sadd</span><br><span class="line">	smembers:获取所有元素</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1. 获取连接</span></span><br><span class="line">       Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">       <span class="comment">//2. 操作</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">       <span class="comment">// set 存储</span></span><br><span class="line">       jedis.sadd(<span class="string">"myset"</span>,<span class="string">"java"</span>,<span class="string">"php"</span>,<span class="string">"c++"</span>);</span><br><span class="line">	</span><br><span class="line">       <span class="comment">// set 获取</span></span><br><span class="line">       Set&lt;String&gt; myset = jedis.smembers(<span class="string">"myset"</span>);</span><br><span class="line">       System.out.println(myset);</span><br><span class="line">	</span><br><span class="line">       <span class="comment">//3. 关闭连接</span></span><br><span class="line">       jedis.close();</span><br><span class="line"><span class="number">5</span>) 有序集合类型 sortedset：不允许重复元素，且元素有顺序</span><br><span class="line">	zadd</span><br><span class="line">	zrange</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1. 获取连接</span></span><br><span class="line">       Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">       <span class="comment">//2. 操作</span></span><br><span class="line">       <span class="comment">// sortedset 存储</span></span><br><span class="line">       jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">3</span>,<span class="string">"亚瑟"</span>);</span><br><span class="line">       jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">30</span>,<span class="string">"后裔"</span>);</span><br><span class="line">       jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">55</span>,<span class="string">"孙悟空"</span>);</span><br><span class="line">	</span><br><span class="line">       <span class="comment">// sortedset 获取</span></span><br><span class="line">       Set&lt;String&gt; mysortedset = jedis.zrange(<span class="string">"mysortedset"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">       System.out.println(mysortedset);</span><br><span class="line">		<span class="comment">//3. 关闭连接</span></span><br><span class="line">       jedis.close();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	* jedis连接池： JedisPool</span><br><span class="line">		* 使用：</span><br><span class="line">			<span class="number">1</span>. 创建JedisPool连接池对象</span><br><span class="line">			<span class="number">2</span>. 调用方法 getResource()方法获取Jedis连接</span><br><span class="line">				<span class="comment">//0.创建一个配置对象</span></span><br><span class="line">		        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">		        config.setMaxTotal(<span class="number">50</span>);</span><br><span class="line">		        config.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">		</span><br><span class="line">		        <span class="comment">//1.创建Jedis连接池对象</span></span><br><span class="line">		        JedisPool jedisPool = <span class="keyword">new</span> JedisPool(config,<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line">		</span><br><span class="line">		        <span class="comment">//2.获取连接</span></span><br><span class="line">		        Jedis jedis = jedisPool.getResource();</span><br><span class="line">		        <span class="comment">//3. 使用</span></span><br><span class="line">		        jedis.set(<span class="string">"hehe"</span>,<span class="string">"heihei"</span>);</span><br><span class="line"><span class="comment">//4. 关闭 归还到连接池中</span></span><br><span class="line">		        jedis.close();</span><br><span class="line">		</span><br><span class="line">		* 连接池工具类</span><br><span class="line">			<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">			    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line">			</span><br><span class="line">			    <span class="keyword">static</span>&#123;</span><br><span class="line">			        <span class="comment">//读取配置文件</span></span><br><span class="line">			        InputStream is =   JedisPoolUtils.class.getClassLoader().getResourceAsStream("jedis.properties");</span><br><span class="line">			        <span class="comment">//创建Properties对象</span></span><br><span class="line">			        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">			        <span class="comment">//关联文件</span></span><br><span class="line">			        <span class="keyword">try</span> &#123;</span><br><span class="line">			            pro.load(is);</span><br><span class="line">			        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			            e.printStackTrace();</span><br><span class="line">			        &#125;</span><br><span class="line">			        <span class="comment">//获取数据，设置到JedisPoolConfig中</span></span><br><span class="line">			        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">			        config.setMaxTotal(Integer.parseInt(pro.getProperty(<span class="string">"maxTotal"</span>)));</span><br><span class="line">			        config.setMaxIdle(Integer.parseInt(pro.getProperty(<span class="string">"maxIdle"</span>)));</span><br><span class="line">			</span><br><span class="line">			        <span class="comment">//初始化JedisPool</span></span><br><span class="line">			        jedisPool = <span class="keyword">new</span> JedisPool(config,pro.getProperty(<span class="string">"host"</span>),Integer.parseInt(pro.getProperty(<span class="string">"port"</span>)));</span><br><span class="line">			        &#125;</span><br><span class="line">			        	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">			     * 获取连接方法</span></span><br><span class="line"><span class="comment">			     */</span></span><br><span class="line">			    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">			        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">			    &#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>





<ul>
<li><strong>注意：使用redis缓存一些不经常发生变化的数据。</strong><ul>
<li><strong>数据库的数据一旦发生改变，则需要更新缓存。</strong><ul>
<li><strong>数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入</strong></li>
<li><strong>在service对应的增删改方法中，将redis数据删除。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​    </p>
]]></content>
      <tags>
        <tag>reids</tag>
      </tags>
  </entry>
  <entry>
    <title>Jquery中.value与.val的区别</title>
    <url>/2020/04/16/Jquery%E4%B8%AD-value%E4%B8%8E-val()%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="今天被这个坑了一上午，人傻了"><a href="#今天被这个坑了一上午，人傻了" class="headerlink" title="今天被这个坑了一上午，人傻了"></a>今天被这个坑了一上午，人傻了</h1><p>Juqery中.val()与.value之间的区别<a id="more"></a></p>
<p>先说理论：<br>.val()方法，一个是带参：给输入框赋值，一个是不参数的方法：获取输入框的值<br>.value：获取Dom标签元素的value值，属于原生态JavaScript的写法 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> id=<span class="string">"username"</span> name=<span class="string">"username"</span> placeholder=<span class="string">"请输入用户名"</span> &gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"#username"</span>).blur(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> username = $(<span class="keyword">this</span>).val();</span><br><span class="line">    alert(username)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<img src="/2020/04/16/Jquery%E4%B8%AD-value%E4%B8%8E-val()%E7%9A%84%E5%8C%BA%E5%88%AB/1.png" class="" title="第一种">

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"#username"</span>).blur(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> username = $(<span class="keyword">this</span>).value;</span><br><span class="line">    alert(username)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>因为在input中没有定义value值所以获取出来的是undefined</p>
<img src="/2020/04/16/Jquery%E4%B8%AD-value%E4%B8%8E-val()%E7%9A%84%E5%8C%BA%E5%88%AB/2.png" class="" title="第二种">]]></content>
      <tags>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>Filter</title>
    <url>/2020/04/14/Filter/</url>
    <content><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>1.Filter：过滤器</p>
<p>2.Listener：监听器</p>
<a id="more"></a>


<h1 id="Filter：过滤器"><a href="#Filter：过滤器" class="headerlink" title="Filter：过滤器"></a>Filter：过滤器</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 概念：</span><br><span class="line">	* 生活中的过滤器：净水器,空气净化器，土匪、</span><br><span class="line">	* web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。</span><br><span class="line">	* 过滤器的作用：</span><br><span class="line">		* 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤...</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 快速入门：</span><br><span class="line">	<span class="number">1</span>. 步骤：</span><br><span class="line">		<span class="number">1</span>. 定义一个类，实现接口Filter</span><br><span class="line">		<span class="number">2</span>. 复写方法</span><br><span class="line">		<span class="number">3</span>. 配置拦截路径</span><br><span class="line">			<span class="number">1</span>. web.xml</span><br><span class="line">			<span class="number">2</span>. 注解</span><br><span class="line">	<span class="number">2</span>. 代码：</span><br><span class="line">		<span class="meta">@WebFilter</span>(<span class="string">"/*"</span>)<span class="comment">//访问所有资源之前，都会执行该过滤器</span></span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterDemo1</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">		    <span class="meta">@Override</span></span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">		</span><br><span class="line">		    &#125;</span><br><span class="line">		</span><br><span class="line">		    <span class="meta">@Override</span></span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">		        System.out.println(<span class="string">"filterDemo1被执行了...."</span>);</span><br></pre></td></tr></table></figure>


<p>​            </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>. 过滤器细节：</span><br><span class="line">	<span class="number">1</span>. web.xml配置	</span><br><span class="line">		&lt;filter&gt;</span><br><span class="line">	        &lt;filter-name&gt;demo1&lt;/filter-name&gt;</span><br><span class="line">	        &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">cn</span>.<span class="title">itcast</span>.<span class="title">web</span>.<span class="title">filter</span>.<span class="title">FilterDemo1</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">	    &lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">	    &lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">	        &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">demo1</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;!-- 拦截路径 --&gt;</span></span><br><span class="line"><span class="class">	        &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;    </span></span><br><span class="line"><span class="class">	    &lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">	2. 过滤器执行流程</span></span><br><span class="line"><span class="class">		1. 执行过滤器</span></span><br><span class="line"><span class="class">		2. 执行放行后的资源</span></span><br><span class="line"><span class="class">		3. 回来执行过滤器放行代码下边的代码</span></span><br><span class="line"><span class="class">	3. 过滤器生命周期方法</span></span><br><span class="line">		1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源</span><br><span class="line">		<span class="number">2</span>. doFilter:每一次请求被拦截资源时，会执行。执行多次</span><br><span class="line">		<span class="number">3</span>. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源</span><br><span class="line">	<span class="number">4</span>. 过滤器配置详解</span><br><span class="line">		* 拦截路径配置：</span><br><span class="line">			<span class="number">1</span>. 具体资源路径： /index.jsp   只有访问index.jsp资源时，过滤器才会被执行</span><br><span class="line">			<span class="number">2</span>. 拦截目录： /user<span class="comment">/*	/访问/user下的所有资源时，过滤器都会被执行</span></span><br><span class="line"><span class="comment">			3. 后缀名拦截： *.jsp		访问所有后缀名为jsp资源时，过滤器都会被执行</span></span><br><span class="line"><span class="comment">			4. 拦截所有资源：/*		访问所有资源时，过滤器都会被执行</span></span><br><span class="line"><span class="comment">		* 拦截方式配置：资源被访问的方式</span></span><br><span class="line"><span class="comment">			* 注解配置：</span></span><br><span class="line"><span class="comment">				* 设置dispatcherTypes属性</span></span><br><span class="line"><span class="comment">					1. REQUEST：默认值。浏览器直接请求资源</span></span><br><span class="line"><span class="comment">					2. FORWARD：转发访问资源</span></span><br><span class="line"><span class="comment">					3. INCLUDE：包含访问资源</span></span><br><span class="line"><span class="comment">					4. ERROR：错误跳转资源</span></span><br><span class="line"><span class="comment">					5. ASYNC：异步访问资源</span></span><br><span class="line"><span class="comment">			* web.xml配置</span></span><br><span class="line"><span class="comment">				* 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment">	5. 过滤器链(配置多个过滤器)</span></span><br><span class="line"><span class="comment">		* 执行顺序：如果有两个过滤器：过滤器1和过滤器2</span></span><br><span class="line"><span class="comment">			1. 过滤器1</span></span><br><span class="line"><span class="comment">			2. 过滤器2</span></span><br><span class="line"><span class="comment">			3. 资源执行</span></span><br><span class="line"><span class="comment">			4. 过滤器2</span></span><br><span class="line"><span class="comment">			5. 过滤器1 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		* 过滤器先后顺序问题：</span></span><br><span class="line"><span class="comment">			1. 注解配置：按照类名的字符串比较规则比较，值小的先执行</span></span><br><span class="line"><span class="comment">				* 如： AFilter 和 BFilter，AFilter就先执行了。</span></span><br><span class="line"><span class="comment">			2. web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行</span></span><br><span class="line"><span class="comment">4. 案例：</span></span><br><span class="line"><span class="comment">	1. 案例1_登录验证</span></span><br><span class="line"><span class="comment">		* 需求：</span></span><br><span class="line"><span class="comment">			1. 访问day17_case案例的资源。验证其是否登录</span></span><br><span class="line"><span class="comment">			2. 如果登录了，则直接放行。</span></span><br><span class="line"><span class="comment">			3. 如果没有登录，则跳转到登录页面，提示"您尚未登录，请先登录"。</span></span><br></pre></td></tr></table></figure>


<p>​    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>. 案例<span class="number">2</span>_敏感词汇过滤</span><br><span class="line">	* 需求：</span><br><span class="line">		<span class="number">1</span>. 对day17_case案例录入的数据进行敏感词汇过滤</span><br><span class="line">		<span class="number">2</span>. 敏感词汇参考《敏感词汇.txt》</span><br><span class="line">		<span class="number">3</span>. 如果是敏感词汇，替换为 *** </span><br><span class="line"></span><br><span class="line">	* 分析：</span><br><span class="line">		<span class="number">1</span>. 对request对象进行增强。增强获取参数相关方法</span><br><span class="line">		<span class="number">2</span>. 放行。传递代理对象</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 增强对象的功能：</span><br><span class="line">	* 设计模式：一些通用的解决固定问题的方式</span><br><span class="line">	<span class="number">1</span>. 装饰模式</span><br><span class="line">	<span class="number">2</span>. 代理模式</span><br><span class="line">		* 概念：</span><br><span class="line">			<span class="number">1</span>. 真实对象：被代理的对象</span><br><span class="line">			<span class="number">2</span>. 代理对象：</span><br><span class="line">			<span class="number">3</span>. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的</span><br><span class="line">	 	* 实现方式：</span><br><span class="line">		 	<span class="number">1</span>. 静态代理：有一个类文件描述代理模式</span><br><span class="line">		 	<span class="number">2</span>. 动态代理：在内存中形成代理类</span><br><span class="line">				* 实现步骤：</span><br><span class="line">					<span class="number">1</span>. 代理对象和真实对象实现相同的接口</span><br><span class="line">					<span class="number">2</span>. 代理对象 = Proxy.newProxyInstance();</span><br><span class="line">					<span class="number">3</span>. 使用代理对象调用方法。</span><br><span class="line">					<span class="number">4</span>. 增强方法</span><br><span class="line"></span><br><span class="line">				* 增强方式：</span><br><span class="line">					<span class="number">1</span>. 增强参数列表</span><br><span class="line">					<span class="number">2</span>. 增强返回值类型</span><br><span class="line">					<span class="number">3</span>. 增强方法体执行逻辑</span><br></pre></td></tr></table></figure>


<h2 id="Listener：监听器"><a href="#Listener：监听器" class="headerlink" title="Listener：监听器"></a>Listener：监听器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 概念：web的三大组件之一。</span><br><span class="line">	* 事件监听机制</span><br><span class="line">		* 事件	：一件事情</span><br><span class="line">		* 事件源 ：事件发生的地方</span><br><span class="line">		* 监听器 ：一个对象</span><br><span class="line">		* 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* ServletContextListener:监听ServletContext对象的创建和销毁</span><br><span class="line">	* 方法：</span><br><span class="line">		* <span class="function"><span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> ：ServletContext对象被销毁之前会调用该方法</span></span><br><span class="line"><span class="function">		* <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> ：ServletContext对象创建后会调用该方法</span></span><br><span class="line"><span class="function">	* 步骤：</span></span><br><span class="line"><span class="function">		1. 定义一个类，实现ServletContextListener接口</span></span><br><span class="line"><span class="function">		2. 复写方法</span></span><br><span class="line"><span class="function">		3. 配置</span></span><br><span class="line"><span class="function">			1. web.xml</span></span><br><span class="line"><span class="function">					&lt;listener&gt;</span></span><br><span class="line"><span class="function"> 					 &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt;</span></span><br></pre></td></tr></table></figure>

<pre><code>&lt;/listener&gt;</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		* 指定初始化参数&lt;context-param&gt;</span><br><span class="line"><span class="number">2</span>. 注解：</span><br><span class="line">	* <span class="meta">@WebListener</span></span><br></pre></td></tr></table></figure>

<p>F</p>
]]></content>
      <tags>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title>异常与线程</title>
    <url>/2020/04/12/%E5%BC%82%E5%B8%B8%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li><p>异常、线程</p>
<a id="more"></a>

</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够辨别程序中异常和错误的区别</li>
<li><input disabled="" type="checkbox"> 说出异常的分类</li>
<li><input disabled="" type="checkbox"> 说出虚拟机处理异常的方式</li>
<li><input disabled="" type="checkbox"> 列举出常见的三个运行期异常</li>
<li><input disabled="" type="checkbox"> 能够使用try…catch关键字处理异常</li>
<li><input disabled="" type="checkbox"> 能够使用throws关键字处理异常</li>
<li><input disabled="" type="checkbox"> 能够自定义异常类</li>
<li><input disabled="" type="checkbox"> 能够处理自定义异常类</li>
<li><input disabled="" type="checkbox"> 说出进程的概念</li>
<li><input disabled="" type="checkbox"> 说出线程的概念</li>
<li><input disabled="" type="checkbox"> 能够理解并发与并行的区别</li>
<li><input disabled="" type="checkbox"> 能够开启新线程</li>
</ul>
<h1 id="第一章-异常"><a href="#第一章-异常" class="headerlink" title="第一章    异常"></a>第一章    异常</h1><h2 id="1-1-异常概念"><a href="#1-1-异常概念" class="headerlink" title="1.1 异常概念"></a>1.1 异常概念</h2><p>异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：</p>
<ul>
<li><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</li>
</ul>
<p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。</p>
<blockquote>
<p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.</p>
</blockquote>
<h2 id="1-2-异常体系"><a href="#1-2-异常体系" class="headerlink" title="1.2 异常体系"></a>1.2 异常体系</h2><p>异常机制其实是帮助我们<strong>找到</strong>程序中的问题，异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>。</p>


<p><strong>Throwable体系：</strong></p>
<ul>
<li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。</li>
<li><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。</li>
</ul>
<p><strong>Throwable中的常用方法：</strong></p>
<ul>
<li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p>
<p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
</li>
<li><p><code>public String getMessage()</code>:获取发生异常的原因。</p>
<p><em>提示给用户的时候,就提示错误原因。</em></p>
</li>
<li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p>
</li>
</ul>
<p><strong><em>出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。</em></strong></p>
<h2 id="1-3-异常分类"><a href="#1-3-异常分类" class="headerlink" title="1.3 异常分类"></a>1.3 异常分类</h2><p>我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。</p>
<p><strong>异常(Exception)的分类</strong>:根据在编译时期还是运行时期去检查异常?</p>
<ul>
<li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li>
<li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</li>
</ul>
<p>​    <img src="/2020/04/12/%E5%BC%82%E5%B8%B8%E4%B8%8E%E7%BA%BF%E7%A8%8B/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB.png" class="" title="异常的分类"></p>
<h2 id="1-4-异常的产生过程解析"><a href="#1-4-异常的产生过程解析" class="headerlink" title="1.4     异常的产生过程解析"></a>1.4     异常的产生过程解析</h2><p>先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。</p>
<p> 工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTools</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对给定的数组通过给定的角标获取元素。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">34</span>, <span class="number">12</span>, <span class="number">67</span> &#125;;</span><br><span class="line">        intnum = ArrayTools.getElement(arr, <span class="number">4</span>)</span><br><span class="line">        System.out.println(<span class="string">"num="</span> + num);</span><br><span class="line">        System.out.println(<span class="string">"over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序执行过程图解：</p>
 



<h1 id="第二章-异常的处理"><a href="#第二章-异常的处理" class="headerlink" title="第二章 异常的处理"></a>第二章 异常的处理</h1><p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p>
<h2 id="2-1-抛出异常throw"><a href="#2-1-抛出异常throw" class="headerlink" title="2.1     抛出异常throw"></a>2.1     抛出异常throw</h2><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p>
<p>在java中，提供了一个<strong>throw</strong>关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p>
<ol>
<li><p>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p>
</li>
<li><p>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。</p>
<p>throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p>
</li>
</ol>
<p><strong>使用格式：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">throw new 异常类名(参数);</span><br></pre></td></tr></table></figure>

<p> 例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"要访问的arr数组不存在"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"该索引在数组中不存在，已超出范围"</span>);</span><br></pre></td></tr></table></figure>

<p>学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个数组 </span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">52</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">//根据索引找对应的元素 </span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> element = getElement(arr, index);</span><br><span class="line"></span><br><span class="line">        System.out.println(element);</span><br><span class="line">        System.out.println(<span class="string">"over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 根据 索引找到数组中对应的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span></span>&#123; </span><br><span class="line">       	<span class="comment">//判断  索引是否越界</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。</span></span><br><span class="line"><span class="comment">             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 </span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"哥们，角标越界了~~~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。</p>
<p>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</p>
</blockquote>
<h2 id="2-2-Objects非空判断"><a href="#2-2-Objects非空判断" class="headerlink" title="2.2 Objects非空判断"></a>2.2 Objects非空判断</h2><p>还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。</p>
<ul>
<li><code>public static &lt;T&gt; T requireNonNull(T obj)</code>:查看指定引用对象不是null。</li>
</ul>
<p>查看源码发现这里对为null的进行了抛出异常操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">      	<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-声明异常throws"><a href="#2-3-声明异常throws" class="headerlink" title="2.3  声明异常throws"></a>2.3  声明异常throws</h2><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p>
<p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p>
<p><strong>声明异常格式：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;   &#125;</span><br></pre></td></tr></table></figure>

<p>声明异常的代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        read(<span class="string">"a.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">"a.txt"</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"文件不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        read(<span class="string">"a.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span><span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">"a.txt"</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"文件不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">"b.txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-捕获异常try…catch"><a href="#2-4-捕获异常try…catch" class="headerlink" title="2.4  捕获异常try…catch"></a>2.4  捕获异常try…catch</h2><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p>
<ol>
<li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li>
<li>在方法中使用try-catch的语句块来处理异常。</li>
</ol>
<p><strong>try-catch</strong>的方式就是捕获异常。</p>
<ul>
<li><strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li>
</ul>
<p>捕获异常语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  e)&#123;</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>try：</strong>该代码块中编写可能产生异常的代码。</p>
<p><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p>
<blockquote>
<p>注意:try和catch都不能单独使用,必须连用。</p>
</blockquote>
<p>演示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">// 当产生异常时，必须有处理方式。要么捕获，要么声明。</span></span><br><span class="line">            read(<span class="string">"b.txt"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;<span class="comment">// 括号中需要定义什么呢？</span></span><br><span class="line">          	<span class="comment">//try中抛出的是什么异常，在括号中就定义什么异常类型</span></span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">"a.txt"</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"文件不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何获取异常信息：</p>
<p>Throwable类中定义了一些查看方法:</p>
<ul>
<li><code>public String getMessage()</code>:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。</li>
</ul>
<ul>
<li><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</li>
<li><code>public void printStackTrace()</code>:打印异常的跟踪栈信息并输出到控制台。</li>
</ul>
<p>​            <em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
<h2 id="2-4-finally-代码块"><a href="#2-4-finally-代码块" class="headerlink" title="2.4 finally 代码块"></a>2.4 finally 代码块</h2><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p>
<p>什么时候的代码必须最终执行？</p>
<p>当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。</p>
<p>finally的语法:</p>
<p> try…catch….finally:自身需要处理异常,最终还得关闭资源。</p>
<blockquote>
<p>注意:finally不能单独使用。</p>
</blockquote>
<p>比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。</p>
<p>finally代码参考如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            read(<span class="string">"a.txt"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">//抓取到的是编译期异常  抛出去的是运行期 </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"不管程序怎样，这里都将会被执行。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">"a.txt"</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"文件不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。</p>
</blockquote>
<h2 id="2-5-异常注意事项"><a href="#2-5-异常注意事项" class="headerlink" title="2.5   异常注意事项"></a>2.5   异常注意事项</h2><ul>
<li><p>多个异常使用捕获又该如何处理呢？</p>
<ol>
<li>多个异常分别处理。</li>
<li>多个异常一次捕获，多次处理。</li>
<li>多个异常一次捕获一次处理。</li>
</ol>
<p>一般我们是使用一次捕获多次处理方式，格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型A  e)&#123;  当<span class="keyword">try</span>中出现A类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型B  e)&#123;  当<span class="keyword">try</span>中出现B类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p>
</blockquote>
</li>
<li><p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p>
</li>
<li><p>如果finally有return语句,永远返回finally中的结果,避免该情况. </p>
</li>
<li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p>
</li>
<li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p>
</li>
</ul>
<h1 id="第三章-自定义异常"><a href="#第三章-自定义异常" class="headerlink" title="第三章 自定义异常"></a>第三章 自定义异常</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p><strong>为什么需要自定义异常类:</strong></p>
<p>我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。</p>
<p>在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？</p>
<p><strong>什么是自定义异常类:</strong></p>
<p>在开发中根据自己业务的异常情况来定义异常类.</p>
<p>自定义一个业务逻辑异常: <strong>RegisterException</strong>。一个注册异常类。</p>
<p><strong>异常类如何定义:</strong></p>
<ol>
<li>自定义一个编译期异常: 自定义类 并继承于<code>java.lang.Exception</code>。</li>
<li>自定义一个运行时期的异常类:自定义类 并继承于<code>java.lang.RuntimeException</code>。</li>
</ol>
<h2 id="3-2-自定义异常的练习"><a href="#3-2-自定义异常的练习" class="headerlink" title="3.2 自定义异常的练习"></a>3.2 自定义异常的练习</h2><p>要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。</p>
<p>首先定义一个登陆异常类RegisterException：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 业务逻辑异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空参构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 表示异常提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟数据库中已存在账号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] names = &#123;<span class="string">"bill"</span>,<span class="string">"hill"</span>,<span class="string">"jill"</span>&#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">              <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">            checkUsername(<span class="string">"nill"</span>);</span><br><span class="line">            System.out.println(<span class="string">"注册成功"</span>);<span class="comment">//如果没有异常就是注册成功</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(RegisterException e)&#123;</span><br><span class="line">            <span class="comment">//处理异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前注册账号是否存在</span></span><br><span class="line">    <span class="comment">//因为是编译期异常，又想调用者去处理 所以声明该异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(String uname)</span> <span class="keyword">throws</span> LoginException</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            <span class="keyword">if</span>(name.equals(uname))&#123;<span class="comment">//如果名字在这里面 就抛出登陆异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RegisterException(<span class="string">"亲"</span>+name+<span class="string">"已经被注册了！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-多线程"><a href="#第四章-多线程" class="headerlink" title="第四章 多线程"></a>第四章 多线程</h1><p>我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？</p>
<p>要解决上述问题,咱们得使用多进程或者多线程来解决.</p>
<h2 id="4-1-并发与并行"><a href="#4-1-并发与并行" class="headerlink" title="4.1 并发与并行"></a>4.1 并发与并行</h2><ul>
<li><p><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</p>
</li>
<li><p><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</p>
<img src="/2020/04/12/%E5%BC%82%E5%B8%B8%E4%B8%8E%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91.bmp" class="" title="并行与并发">

</li>
</ul>
<p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p>
<p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p>
<blockquote>
<p>注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p>
</blockquote>
<h2 id="4-2-线程与进程"><a href="#4-2-线程与进程" class="headerlink" title="4.2 线程与进程"></a>4.2 线程与进程</h2><ul>
<li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p>
</li>
<li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p>
<p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 </p>
</li>
</ul>
<p>我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程：</p>
<p><strong>进程</strong></p>
 <img src="/2020/04/12/%E5%BC%82%E5%B8%B8%E4%B8%8E%E7%BA%BF%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5.png" class="" title="进程">

<p><strong>线程</strong></p>
 <img src="/2020/04/12/%E5%BC%82%E5%B8%B8%E4%B8%8E%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5.png" class="" title="线程">

<p><strong>线程调度:</strong></p>
<ul>
<li><p>分时调度</p>
<p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p>
</li>
<li><p>抢占式调度</p>
<p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p>
<ul>
<li><p>设置线程的优先级</p>
<img src="/2020/04/12/%E5%BC%82%E5%B8%B8%E4%B8%8E%E7%BA%BF%E7%A8%8B/%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7.bmp" class="" title="线程优先">
</li>
<li><p>抢占式调度详解</p>
<p>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。</p>
<p>实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。<br>其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</p>
 <img src="/2020/04/12/%E5%BC%82%E5%B8%B8%E4%B8%8E%E7%BA%BF%E7%A8%8B/%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6.bmp" class="" title="异常产生过程">

</li>
</ul>
</li>
</ul>
<h2 id="4-3-创建线程类"><a href="#4-3-创建线程类" class="headerlink" title="4.3 创建线程类"></a>4.3 创建线程类</h2><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p>
<ol>
<li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ol>
<p>代码如下：</p>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建自定义线程对象</span></span><br><span class="line">		MyThread mt = <span class="keyword">new</span> MyThread(<span class="string">"新的线程！"</span>);</span><br><span class="line">		<span class="comment">//开启新线程</span></span><br><span class="line">		mt.start();</span><br><span class="line">		<span class="comment">//在主方法中执行for循环</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"main线程！"</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义指定线程名称的构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用父类的String参数的构造方法，指定线程的名称</span></span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 重写run方法，完成该线程执行的逻辑</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(getName()+<span class="string">"：正在执行！"</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>CookieSession</title>
    <url>/2020/04/10/CookieSession/</url>
    <content><![CDATA[<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>1.Cookie</p>
<p>2.Session</p>
<a id="more"></a>

<h2 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 会话：一次会话中包含多次请求和响应。</span><br><span class="line">	* 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止</span><br><span class="line"><span class="number">2</span>. 功能：在一次会话的范围内的多次请求间，共享数据</span><br><span class="line"><span class="number">3</span>. 方式：</span><br><span class="line">	<span class="number">1</span>. 客户端会话技术：Cookie</span><br><span class="line">	<span class="number">2</span>. 服务器端会话技术：Session</span><br></pre></td></tr></table></figure>

<h2 id="Cookie："><a href="#Cookie：" class="headerlink" title="Cookie："></a>Cookie：</h2><img src="/2020/04/10/CookieSession/Cookie%E5%8E%9F%E7%90%86.bmp" class="" title="Cookie原理">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 概念：客户端会话技术，将数据保存到客户端</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 快速入门：</span><br><span class="line">	* 使用步骤：</span><br><span class="line">		<span class="number">1</span>. 创建Cookie对象，绑定数据</span><br><span class="line">			* <span class="keyword">new</span> Cookie(String name, String value) </span><br><span class="line">		<span class="number">2</span>. 发送Cookie对象</span><br><span class="line">			* response.addCookie(Cookie cookie) </span><br><span class="line">		<span class="number">3</span>. 获取Cookie，拿到数据</span><br><span class="line">			* Cookie[]  request.getCookies()</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>. 实现原理</span><br><span class="line">	* 基于响应头set-cookie和请求头cookie实现</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. cookie的细节</span><br><span class="line">	<span class="number">1</span>. 一次可不可以发送多个cookie?</span><br><span class="line">		* 可以</span><br><span class="line">		* 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。</span><br><span class="line">	<span class="number">2</span>. cookie在浏览器中保存多长时间？</span><br><span class="line">		<span class="number">1</span>. 默认情况下，当浏览器关闭后，Cookie数据被销毁</span><br><span class="line">		<span class="number">2</span>. 持久化存储：</span><br><span class="line">			* setMaxAge(<span class="keyword">int</span> seconds)</span><br><span class="line">				<span class="number">1</span>. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效</span><br><span class="line">				<span class="number">2</span>. 负数：默认值</span><br><span class="line">				<span class="number">3</span>. 零：删除cookie信息</span><br><span class="line">	<span class="number">3</span>. cookie能不能存中文？</span><br><span class="line">		* 在tomcat <span class="number">8</span> 之前 cookie中不能直接存储中文数据。</span><br><span class="line">			* 需要将中文数据转码---一般采用URL编码(%E3)</span><br><span class="line">		* 在tomcat <span class="number">8</span> 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析</span><br><span class="line">	<span class="number">4</span>. cookie共享问题？</span><br><span class="line">		<span class="number">1</span>. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？</span><br><span class="line">			* 默认情况下cookie不能共享</span><br><span class="line"></span><br><span class="line">			* setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录</span><br><span class="line">				* 如果要共享，则可以将path设置为<span class="string">"/"</span></span><br></pre></td></tr></table></figure>


<p>​            </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>. 不同的tomcat服务器间cookie共享问题？</span><br><span class="line">	* setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享</span><br><span class="line">		* setDomain(<span class="string">".baidu.com"</span>),那么tieba.baidu.com和news.baidu.com中cookie可以共享</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>. Cookie的特点和作用</span><br><span class="line">	<span class="number">1</span>. cookie存储数据在客户端浏览器</span><br><span class="line">	<span class="number">2</span>. 浏览器对于单个cookie 的大小有限制(<span class="number">4</span>kb) 以及 对同一个域名下的总cookie数量也有限制(<span class="number">20</span>个)</span><br><span class="line"></span><br><span class="line">	* 作用：</span><br><span class="line">		<span class="number">1</span>. cookie一般用于存出少量的不太敏感的数据</span><br><span class="line">		<span class="number">2</span>. 在不登录的情况下，完成服务器对客户端的身份识别</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>. 案例：记住上一次访问时间</span><br><span class="line">	<span class="number">1</span>. 需求：</span><br><span class="line">		<span class="number">1</span>. 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。</span><br><span class="line">		<span class="number">2</span>. 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串</span><br><span class="line"></span><br><span class="line">	<span class="number">2</span>. 分析：</span><br><span class="line">		<span class="number">1</span>. 可以采用Cookie来完成</span><br><span class="line">		<span class="number">2</span>. 在服务器中的Servlet判断是否有一个名为lastTime的cookie</span><br><span class="line">			<span class="number">1</span>. 有：不是第一次访问</span><br><span class="line">				<span class="number">1</span>. 响应数据：欢迎回来，您上次访问时间为:<span class="number">2018</span>年<span class="number">6</span>月<span class="number">10</span>日<span class="number">11</span>:<span class="number">50</span>:<span class="number">20</span></span><br><span class="line">				<span class="number">2</span>. 写回Cookie：lastTime=<span class="number">2018</span>年<span class="number">6</span>月<span class="number">10</span>日<span class="number">11</span>:<span class="number">50</span>:<span class="number">01</span></span><br><span class="line">			<span class="number">2</span>. 没有：是第一次访问</span><br><span class="line">				<span class="number">1</span>. 响应数据：您好，欢迎您首次访问</span><br><span class="line">				<span class="number">2</span>. 写回Cookie：lastTime=<span class="number">2018</span>年<span class="number">6</span>月<span class="number">10</span>日<span class="number">11</span>:<span class="number">50</span>:<span class="number">01</span></span><br><span class="line"></span><br><span class="line">	<span class="number">3</span>. 代码实现：</span><br><span class="line">		<span class="keyword">package</span> cn.itcast.cookie;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line">		<span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line">		<span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line">		<span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line">		<span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line">		<span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line">		<span class="keyword">import</span> java.io.IOException;</span><br><span class="line">		<span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line">		<span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line">		<span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line">		<span class="keyword">import</span> java.util.Date;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/cookieTest"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieTest</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//设置响应的消息体的数据格式以及编码</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取所有Cookie</span></span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//没有cookie为lastTime</span></span><br><span class="line">        <span class="comment">//2.遍历cookie数组</span></span><br><span class="line">        <span class="keyword">if</span>(cookies != <span class="keyword">null</span> &amp;&amp; cookies.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                <span class="comment">//3.获取cookie的名称</span></span><br><span class="line">                String name = cookie.getName();</span><br><span class="line">                <span class="comment">//4.判断名称是否是：lastTime</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">"lastTime"</span>.equals(name))&#123;</span><br><span class="line">                    <span class="comment">//有该Cookie，不是第一次访问</span></span><br><span class="line"></span><br><span class="line">                    flag = <span class="keyword">true</span>;<span class="comment">//有lastTime的cookie</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//设置Cookie的value</span></span><br><span class="line">                    <span class="comment">//获取当前时间的字符串，重新设置Cookie的值，重新发送cookie</span></span><br><span class="line">                    Date date  = <span class="keyword">new</span> Date();</span><br><span class="line">                    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH:mm:ss"</span>);</span><br><span class="line">                    String str_date = sdf.format(date);</span><br><span class="line">                    System.out.println(<span class="string">"编码前："</span>+str_date);</span><br><span class="line">                    <span class="comment">//URL编码</span></span><br><span class="line">                    str_date = URLEncoder.encode(str_date,<span class="string">"utf-8"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"编码后："</span>+str_date);</span><br><span class="line">                    cookie.setValue(str_date);</span><br><span class="line">                    <span class="comment">//设置cookie的存活时间</span></span><br><span class="line">                    cookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span>);<span class="comment">//一个月</span></span><br><span class="line">                    response.addCookie(cookie);</span><br></pre></td></tr></table></figure>


<p>​        </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">            <span class="comment">//响应数据</span></span><br><span class="line">            <span class="comment">//获取Cookie的value，时间</span></span><br><span class="line">            String value = cookie.getValue();</span><br><span class="line">            System.out.println(<span class="string">"解码前："</span>+value);</span><br><span class="line">            <span class="comment">//URL解码：</span></span><br><span class="line">            value = URLDecoder.decode(value,<span class="string">"utf-8"</span>);</span><br><span class="line">            System.out.println(<span class="string">"解码后："</span>+value);</span><br><span class="line">            response.getWriter().write(<span class="string">"&lt;h1&gt;欢迎回来，您上次访问时间为:"</span>+value+<span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">	</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">	</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>​        </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(cookies == <span class="keyword">null</span> || cookies.length == <span class="number">0</span> || flag == <span class="keyword">false</span>)&#123;</span><br><span class="line">    <span class="comment">//没有，第一次访问</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置Cookie的value</span></span><br><span class="line">    <span class="comment">//获取当前时间的字符串，重新设置Cookie的值，重新发送cookie</span></span><br><span class="line">    Date date  = <span class="keyword">new</span> Date();</span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH:mm:ss"</span>);</span><br><span class="line">    String str_date = sdf.format(date);</span><br><span class="line">    System.out.println(<span class="string">"编码前："</span>+str_date);</span><br><span class="line">    <span class="comment">//URL编码</span></span><br><span class="line">    str_date = URLEncoder.encode(str_date,<span class="string">"utf-8"</span>);</span><br><span class="line">    System.out.println(<span class="string">"编码后："</span>+str_date);</span><br><span class="line">	</span><br><span class="line">    Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"lastTime"</span>,str_date);</span><br><span class="line">    <span class="comment">//设置cookie的存活时间</span></span><br><span class="line">    cookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span>);<span class="comment">//一个月</span></span><br><span class="line">    response.addCookie(cookie);</span><br><span class="line">	</span><br><span class="line">    response.getWriter().write(<span class="string">"&lt;h1&gt;您好，欢迎您首次访问&lt;/h1&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>​        </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cookie案例记住上次访问时间：<img src="/2020/04/10/CookieSession/Cookie%E6%A1%88%E4%BE%8B_%E8%AE%B0%E4%BD%8F%E4%B8%8A%E6%AC%A1%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4.bmp" class="" title="案例分析"></p>
<h2 id="Session：主菜"><a href="#Session：主菜" class="headerlink" title="Session：主菜"></a>Session：主菜</h2><img src="/2020/04/10/CookieSession/Session%E5%8E%9F%E7%90%86.bmp" class="" title="Session原理">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession</span><br><span class="line"><span class="number">2</span>. 快速入门：</span><br><span class="line">	<span class="number">1</span>. 获取HttpSession对象：</span><br><span class="line">		HttpSession session = request.getSession();</span><br><span class="line">	<span class="number">2</span>. 使用HttpSession对象：</span><br><span class="line">		<span class="function">Object <span class="title">getAttribute</span><span class="params">(String name)</span>  </span></span><br><span class="line"><span class="function">		<span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, Object value)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String name)</span>  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">3. 原理</span></span><br><span class="line"><span class="function">	* Session的实现是依赖于Cookie的。</span></span><br></pre></td></tr></table></figure>


<p>​    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>. 细节：</span><br><span class="line">	<span class="number">1</span>. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？</span><br><span class="line">		* 默认情况下。不是。</span><br><span class="line">		* 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。</span><br><span class="line">			 Cookie c = <span class="keyword">new</span> Cookie(<span class="string">"JSESSIONID"</span>,session.getId());</span><br><span class="line">	         c.setMaxAge(<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">	         response.addCookie(c);</span><br><span class="line"></span><br><span class="line">	<span class="number">2</span>. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？</span><br><span class="line">		* 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作</span><br><span class="line">			* session的钝化：</span><br><span class="line">				* 在服务器正常关闭之前，将session对象系列化到硬盘上</span><br><span class="line">			* session的活化：</span><br><span class="line">				* 在服务器启动后，将session文件转化为内存中的session对象即可。</span><br><span class="line">			</span><br><span class="line">	<span class="number">3</span>. session什么时候被销毁？</span><br><span class="line">		<span class="number">1</span>. 服务器关闭</span><br><span class="line">		<span class="number">2</span>. session对象调用invalidate() 。</span><br><span class="line">		<span class="number">3</span>. session默认失效时间 <span class="number">30</span>分钟</span><br><span class="line">			选择性配置修改	</span><br><span class="line">			&lt;session-config&gt;</span><br><span class="line">		        &lt;session-timeout&gt;30&lt;/session-timeout&gt;</span><br><span class="line">		    &lt;/session-config&gt;</span><br><span class="line"></span><br><span class="line"> <span class="number">5</span>. session的特点</span><br><span class="line">	 <span class="number">1</span>. session用于存储一次会话的多次请求的数据，存在服务器端</span><br><span class="line">	 <span class="number">2</span>. session可以存储任意类型，任意大小的数据</span><br><span class="line"></span><br><span class="line">	* session与Cookie的区别：</span><br><span class="line">		<span class="number">1</span>. session存储数据在服务器端，Cookie在客户端</span><br><span class="line">		<span class="number">2</span>. session没有数据大小限制，Cookie有</span><br><span class="line">		<span class="number">3</span>. session数据安全，Cookie相对于不安全</span><br></pre></td></tr></table></figure>


<h2 id="案例：验证码"><a href="#案例：验证码" class="headerlink" title="案例：验证码"></a>案例：验证码</h2><pre><code>1. 案例需求：
    1. 访问带有验证码的登录页面login.jsp
    2. 用户输入用户名，密码以及验证码。
        * 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误
        * 如果验证码输入有误，跳转登录页面，提示：验证码错误
        * 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您</code></pre><ol start="2">
<li>分析：<img src="/2020/04/10/CookieSession/%E7%99%BB%E5%BD%95%E6%A1%88%E4%BE%8B.bmp" class="" title="案例分析"></li>
</ol>
<p>​    </p>
]]></content>
      <tags>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title>Response介绍</title>
    <url>/2020/04/10/Response%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>1.HTTP协议：响应消息</p>
<p>2.Response对象</p>
<p>3.ServletContext对象</p>
<a id="more"></a>


<h2 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 请求消息：客户端发送给服务器端的数据</span><br><span class="line">	* 数据格式：</span><br><span class="line">		<span class="number">1</span>. 请求行</span><br><span class="line">		<span class="number">2</span>. 请求头</span><br><span class="line">		<span class="number">3</span>. 请求空行</span><br><span class="line">		<span class="number">4</span>. 请求体</span><br><span class="line"><span class="number">2</span>. 响应消息：服务器端发送给客户端的数据</span><br><span class="line">	* 数据格式：</span><br><span class="line">		<span class="number">1</span>. 响应行</span><br><span class="line">			<span class="number">1</span>. 组成：协议/版本 响应状态码 状态码描述</span><br><span class="line">			<span class="number">2</span>. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。</span><br><span class="line">				<span class="number">1</span>. 状态码都是<span class="number">3</span>位数字 </span><br><span class="line">				<span class="number">2</span>. 分类：</span><br><span class="line">					<span class="number">1</span>. <span class="number">1</span>xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送<span class="number">1</span>xx多状态码</span><br><span class="line">					<span class="number">2</span>. <span class="number">2</span>xx：成功。代表：<span class="number">200</span></span><br><span class="line">					<span class="number">3</span>. <span class="number">3</span>xx：重定向。代表：<span class="number">302</span>(重定向)，<span class="number">304</span>(访问缓存)</span><br><span class="line">					<span class="number">4</span>. <span class="number">4</span>xx：客户端错误。</span><br><span class="line">						* 代表：</span><br><span class="line">							* <span class="number">404</span>（请求路径没有对应的资源） </span><br><span class="line">							* <span class="number">405</span>：请求方式没有对应的doXxx方法</span><br><span class="line">					<span class="number">5</span>. <span class="number">5</span>xx：服务器端错误。代表：<span class="number">500</span>(服务器内部出现异常)</span><br></pre></td></tr></table></figure>


<p>​                    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>. 响应头：</span><br><span class="line">	<span class="number">1</span>. 格式：头名称： 值</span><br><span class="line">	<span class="number">2</span>. 常见的响应头：</span><br><span class="line">		<span class="number">1</span>. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式</span><br><span class="line">		<span class="number">2</span>. Content-disposition：服务器告诉客户端以什么格式打开响应体数据</span><br><span class="line">			* 值：</span><br><span class="line">				* in-line:默认值,在当前页面内打开</span><br><span class="line">				* attachment;filename=xxx：以附件形式打开响应体。文件下载</span><br><span class="line"><span class="number">3</span>. 响应空行</span><br><span class="line"><span class="number">4</span>. 响应体:传输的数据</span><br></pre></td></tr></table></figure>


<figure class="highlight"><table><tr><td class="code"><pre><span class="line">* 响应字符串格式</span><br><span class="line">	HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">	Content-Type: text/html;charset=UTF-<span class="number">8</span></span><br><span class="line">	Content-Length: <span class="number">101</span></span><br><span class="line">	Date: Wed, <span class="number">06</span> Jun <span class="number">2018</span> <span class="number">07</span>:<span class="number">08</span>:<span class="number">42</span> GMT</span><br><span class="line"></span><br><span class="line">	&lt;html&gt;</span><br><span class="line">	  &lt;head&gt;</span><br><span class="line">	    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">	  &lt;/head&gt;</span><br><span class="line">	  &lt;body&gt;</span><br><span class="line">	  hello , response</span><br><span class="line">	  &lt;/body&gt;</span><br><span class="line">	&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><img src="/2020/04/10/Response%E4%BB%8B%E7%BB%8D/%E9%87%8D%E5%AE%9A%E5%90%91.bmp" class="" title="重定向">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 功能：设置响应消息</span><br><span class="line">	<span class="number">1</span>. 设置响应行</span><br><span class="line">		<span class="number">1</span>. 格式：HTTP/<span class="number">1.1</span> <span class="number">200</span> ok</span><br><span class="line">		<span class="number">2</span>. 设置状态码：setStatus(<span class="keyword">int</span> sc) </span><br><span class="line">	<span class="number">2</span>. 设置响应头：setHeader(String name, String value) </span><br><span class="line">		</span><br><span class="line">	<span class="number">3</span>. 设置响应体：</span><br><span class="line">		* 使用步骤：</span><br><span class="line">			<span class="number">1</span>. 获取输出流</span><br><span class="line">				* 字符输出流：<span class="function">PrintWriter <span class="title">getWriter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">				* 字节输出流：ServletOutputStream <span class="title">getOutputStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">			2. 使用输出流，将数据输出到客户端浏览器</span></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 案例：</span><br><span class="line">	<span class="number">1</span>. 完成重定向</span><br><span class="line">		* 重定向：资源跳转的方式</span><br><span class="line">		* 代码实现：</span><br><span class="line">			<span class="comment">//1. 设置状态码为302</span></span><br><span class="line">	        response.setStatus(<span class="number">302</span>);</span><br><span class="line">	        <span class="comment">//2.设置响应头location</span></span><br><span class="line">	        response.setHeader(<span class="string">"location"</span>,<span class="string">"/day15/responseDemo2"</span>);</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">       <span class="comment">//简单的重定向方法</span></span><br><span class="line">       response.sendRedirect(<span class="string">"/day15/responseDemo2"</span>);</span><br><span class="line"></span><br><span class="line">* 重定向的特点:redirect</span><br><span class="line">	<span class="number">1</span>. 地址栏发生变化</span><br><span class="line">	<span class="number">2</span>. 重定向可以访问其他站点(服务器)的资源</span><br><span class="line">	<span class="number">3</span>. 重定向是两次请求。不能使用request对象来共享数据</span><br><span class="line">* 转发的特点：forward</span><br><span class="line">	<span class="number">1</span>. 转发地址栏路径不变</span><br><span class="line">	<span class="number">2</span>. 转发只能访问当前服务器下的资源</span><br><span class="line">	<span class="number">3</span>. 转发是一次请求，可以使用request对象来共享数据</span><br><span class="line"></span><br><span class="line">* forward 和  redirect 区别</span><br><span class="line">	</span><br><span class="line">* 路径写法：</span><br><span class="line">	<span class="number">1</span>. 路径分类</span><br><span class="line">		<span class="number">1</span>. 相对路径：通过相对路径不可以确定唯一资源</span><br><span class="line">			* 如：./index.html</span><br><span class="line">			* 不以/开头，以.开头路径</span><br><span class="line"></span><br><span class="line">			* 规则：找到当前资源和目标资源之间的相对位置关系</span><br><span class="line">				* ./：当前目录</span><br><span class="line">				* ../:后退一级目录</span><br><span class="line">		<span class="number">2</span>. 绝对路径：通过绝对路径可以确定唯一资源</span><br><span class="line">			* 如：http:<span class="comment">//localhost/day15/responseDemo2		/day15/responseDemo2</span></span><br><span class="line">			* 以/开头的路径</span><br><span class="line"></span><br><span class="line">			* 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出</span><br><span class="line">				* 给客户端浏览器使用：需要加虚拟目录(项目的访问路径)</span><br><span class="line">					* 建议虚拟目录动态获取：request.getContextPath()</span><br><span class="line">					* &lt;a&gt; , &lt;form&gt; 重定向...</span><br><span class="line">				* 给服务器使用：不需要加虚拟目录</span><br><span class="line">					* 转发路径</span><br></pre></td></tr></table></figure>


<p>​<br>​                        </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>. 服务器输出字符数据到浏览器</span><br><span class="line">	* 步骤：</span><br><span class="line">		<span class="number">1</span>. 获取字符输出流</span><br><span class="line">		<span class="number">2</span>. 输出数据</span><br><span class="line"></span><br><span class="line">	* 注意：</span><br><span class="line">		* 乱码问题：</span><br><span class="line">			<span class="number">1</span>. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-<span class="number">8859</span>-<span class="number">1</span></span><br><span class="line">			<span class="number">2</span>. 设置该流的默认编码</span><br><span class="line">			<span class="number">3</span>. 告诉浏览器响应体使用的编码</span><br><span class="line"></span><br><span class="line">			<span class="comment">//简单的形式，设置编码，是在获取流之前设置</span></span><br><span class="line">   			response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"><span class="number">3</span>. 服务器输出字节数据到浏览器</span><br><span class="line">	* 步骤：</span><br><span class="line">		<span class="number">1</span>. 获取字节输出流</span><br><span class="line">		<span class="number">2</span>. 输出数据</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. 验证码</span><br><span class="line">	<span class="number">1</span>. 本质：图片</span><br><span class="line">	<span class="number">2</span>. 目的：防止恶意表单注册</span><br></pre></td></tr></table></figure>



<h2 id="ServletContext对象："><a href="#ServletContext对象：" class="headerlink" title="ServletContext对象："></a>ServletContext对象：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 概念：代表整个web应用，可以和程序的容器(服务器)来通信</span><br><span class="line"><span class="number">2</span>. 获取：</span><br><span class="line">	<span class="number">1</span>. 通过request对象获取</span><br><span class="line">		request.getServletContext();</span><br><span class="line">	<span class="number">2</span>. 通过HttpServlet获取</span><br><span class="line">		<span class="keyword">this</span>.getServletContext();</span><br><span class="line"><span class="number">3</span>. 功能：</span><br><span class="line">	<span class="number">1</span>. 获取MIME类型：</span><br><span class="line">		* MIME类型:在互联网通信过程中定义的一种文件数据类型</span><br><span class="line">			* 格式： 大类型/小类型   text/html		image/jpeg</span><br><span class="line"></span><br><span class="line">		* 获取：<span class="function">String <span class="title">getMimeType</span><span class="params">(String file)</span>  </span></span><br><span class="line"><span class="function">	2. 域对象：共享数据</span></span><br><span class="line"><span class="function">		1. <span class="title">setAttribute</span><span class="params">(String name,Object value)</span></span></span><br><span class="line"><span class="function">		2. <span class="title">getAttribute</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">		3. <span class="title">removeAttribute</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">		* ServletContext对象范围：所有用户所有请求的数据</span></span><br><span class="line"><span class="function">	3. 获取文件的真实<span class="params">(服务器)</span>路径</span></span><br><span class="line"><span class="function">		1. 方法：String <span class="title">getRealPath</span><span class="params">(String path)</span>  </span></span><br><span class="line"><span class="function">			 String b </span>= context.getRealPath(<span class="string">"/b.txt"</span>);<span class="comment">//web目录下资源访问</span></span><br><span class="line">	         System.out.println(b);</span><br><span class="line">	</span><br><span class="line">	        String c = context.getRealPath(<span class="string">"/WEB-INF/c.txt"</span>);<span class="comment">//WEB-INF目录下的资源访问</span></span><br><span class="line">	        System.out.println(c);</span><br><span class="line">	</span><br><span class="line">	        String a = context.getRealPath(<span class="string">"/WEB-INF/classes/a.txt"</span>);<span class="comment">//src目录下的资源访问</span></span><br><span class="line">	        System.out.println(a);</span><br></pre></td></tr></table></figure>



<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>* 文件下载需求：
    1. 页面显示超链接
    2. 点击超链接后弹出下载提示框
    3. 完成图片文件下载


* 分析：
    1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求
    2. 任何资源都必须弹出下载提示框
    3. 使用响应头设置资源的打开方式：
        * content-disposition:attachment;filename=xxx


* 步骤：
    1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename
    2. 定义Servlet
        1. 获取文件名称
        2. 使用字节输入流加载文件进内存
        3. 指定response的响应头： content-disposition:attachment;filename=xxx
        4. 将数据写出到response输出流


* 问题：
    * 中文文件问题
        * 解决思路：
            1. 获取客户端使用的浏览器版本信息
            2. 根据不同的版本信息，设置filename的编码方式不同</code></pre>]]></content>
      <tags>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title>Junit与反射</title>
    <url>/2020/04/08/Junit%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><ol>
<li>Junit单元测试</li>
<li>反射</li>
<li>注解</li>
</ol>
<a id="more"></a>

<h2 id="Junit单元测试："><a href="#Junit单元测试：" class="headerlink" title="Junit单元测试："></a>Junit单元测试：</h2><img src="/2020/04/08/Junit%E4%B8%8E%E5%8F%8D%E5%B0%84/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB.bmp" class="" title="测试分类">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 测试分类：</span><br><span class="line">	<span class="number">1</span>. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。</span><br><span class="line">	<span class="number">2</span>. 白盒测试：需要写代码的。关注程序具体的执行流程。</span><br><span class="line"></span><br><span class="line">* Junit使用：白盒测试</span><br><span class="line">	* 步骤：</span><br><span class="line">		<span class="number">1</span>. 定义一个测试类(测试用例)</span><br><span class="line">			* 建议：</span><br><span class="line">				* 测试类名：被测试的类名Test		CalculatorTest</span><br><span class="line">				* 包名：xxx.xxx.xx.test		cn.itcast.test</span><br><span class="line"></span><br><span class="line">		<span class="number">2</span>. 定义测试方法：可以独立运行</span><br><span class="line">			* 建议：</span><br><span class="line">				* 方法名：test测试的方法名		testAdd()  </span><br><span class="line">				* 返回值：<span class="keyword">void</span></span><br><span class="line">				* 参数列表：空参</span><br><span class="line"></span><br><span class="line">		<span class="number">3</span>. 给方法加<span class="meta">@Test</span></span><br><span class="line">		<span class="number">4</span>. 导入junit依赖环境</span><br><span class="line"></span><br><span class="line">	* 判定结果：</span><br><span class="line">		* 红色：失败</span><br><span class="line">		* 绿色：成功</span><br><span class="line">		* 一般我们会使用断言操作来处理结果</span><br><span class="line">			* Assert.assertEquals(期望的结果,运算的结果);</span><br><span class="line"></span><br><span class="line">	* 补充：</span><br><span class="line">		* <span class="meta">@Before</span>:</span><br><span class="line">			* 修饰的方法会在测试方法之前被自动执行</span><br><span class="line">		* <span class="meta">@After</span>:</span><br><span class="line">			* 修饰的方法会在测试方法执行之后自动被执行</span><br></pre></td></tr></table></figure>

<h2 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h2><p>代码的三个阶段</p>
<img src="/2020/04/08/Junit%E4%B8%8E%E5%8F%8D%E5%B0%84/Java%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5.bmp" class="" title="代码的三个阶段">

<pre><code>* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码
* 反射：将类的各个组成部分封装为其他对象，这就是反射机制
    * 好处：
        1. 可以在程序运行过程中，操作这些对象。
        2. 可以解耦，提高程序的可扩展性。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 获取Class对象的方式：</span><br><span class="line">	<span class="number">1</span>. Class.forName(<span class="string">"全类名"</span>)：将字节码文件加载进内存，返回Class对象</span><br><span class="line">		* 多用于配置文件，将类名定义在配置文件中。读取文件，加载类</span><br><span class="line">	<span class="number">2</span>. 类名<span class="class">.<span class="keyword">class</span>：通过类名的属性<span class="title">class</span>获取</span></span><br><span class="line"><span class="class">		* 多用于参数的传递</span></span><br><span class="line"><span class="class">	3. 对象.<span class="title">getClass</span>()：<span class="title">getClass</span>()方法在<span class="title">Object</span>类中定义着。</span></span><br><span class="line"><span class="class">		* 多用于对象的获取字节码的方式</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">	* 结论：</span></span><br><span class="line"><span class="class">		同一个字节码文件(*.<span class="title">class</span>)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的<span class="title">Class</span>对象都是同一个。</span></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* Class对象功能：</span><br><span class="line">	* 获取功能：</span><br><span class="line">		<span class="number">1</span>. 获取成员变量们</span><br><span class="line">			* Field[] getFields() ：获取所有<span class="keyword">public</span>修饰的成员变量</span><br><span class="line">			* <span class="function">Field <span class="title">getField</span><span class="params">(String name)</span>   获取指定名称的 <span class="keyword">public</span>修饰的成员变量</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">			* Field[] <span class="title">getDeclaredFields</span><span class="params">()</span>  获取所有的成员变量，不考虑修饰符</span></span><br><span class="line"><span class="function">			* Field <span class="title">getDeclaredField</span><span class="params">(String name)</span>  </span></span><br><span class="line"><span class="function">		2. 获取构造方法们</span></span><br><span class="line"><span class="function">			* Constructor&lt;?&gt;[] <span class="title">getConstructors</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">			* Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(类&lt;?&gt;... parameterTypes)</span>  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">			* Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(类&lt;?&gt;... parameterTypes)</span>  </span></span><br><span class="line"><span class="function">			* Constructor&lt;?&gt;[] <span class="title">getDeclaredConstructors</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">		3. 获取成员方法们：</span></span><br><span class="line"><span class="function">			* Method[] <span class="title">getMethods</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">			* Method <span class="title">getMethod</span><span class="params">(String name, 类&lt;?&gt;... parameterTypes)</span>  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">			* Method[] <span class="title">getDeclaredMethods</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">			* Method <span class="title">getDeclaredMethod</span><span class="params">(String name, 类&lt;?&gt;... parameterTypes)</span>  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">		4. 获取全类名	</span></span><br><span class="line"><span class="function">			* String <span class="title">getName</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* Field：成员变量</span><br><span class="line">	* 操作：</span><br><span class="line">		<span class="number">1</span>. 设置值</span><br><span class="line">			* <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span>  </span></span><br><span class="line"><span class="function">		2. 获取值</span></span><br><span class="line"><span class="function">			* <span class="title">get</span><span class="params">(Object obj)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">		3. 忽略访问权限修饰符的安全检查</span></span><br><span class="line"><span class="function">			* <span class="title">setAccessible</span><span class="params">(<span class="keyword">true</span>)</span>:暴力反射</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* Constructor:构造方法</span><br><span class="line">	* 创建对象：</span><br><span class="line">		* <span class="function">T <span class="title">newInstance</span><span class="params">(Object... initargs)</span>  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">		* 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</span></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* Method：方法对象</span><br><span class="line">	* 执行方法：</span><br><span class="line">		* <span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span>  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	* 获取方法名称：</span></span><br><span class="line"><span class="function">		* String getName:获取方法名</span></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 案例：</span><br><span class="line">	* 需求：写一个<span class="string">"框架"</span>，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法</span><br><span class="line">		* 实现：</span><br><span class="line">			<span class="number">1</span>. 配置文件</span><br><span class="line">			<span class="number">2</span>. 反射</span><br><span class="line">		* 步骤：</span><br><span class="line">			<span class="number">1</span>. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中</span><br><span class="line">			<span class="number">2</span>. 在程序中加载读取配置文件</span><br><span class="line">			<span class="number">3</span>. 使用反射技术来加载类文件进内存</span><br><span class="line">			<span class="number">4</span>. 创建对象</span><br><span class="line">			<span class="number">5</span>. 执行方法</span><br></pre></td></tr></table></figure>


<h2 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 概念：说明程序的。给计算机看的</span><br><span class="line">* 注释：用文字描述程序的。给程序员看的</span><br><span class="line"></span><br><span class="line">* 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1<span class="number">.5</span>及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</span><br><span class="line">* 概念描述：</span><br><span class="line">	* JDK1<span class="number">.5</span>之后的新特性</span><br><span class="line">	* 说明程序的</span><br><span class="line">	* 使用注解：@注解名称</span><br></pre></td></tr></table></figure>


<p>​    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 作用分类：</span><br><span class="line">	①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】</span><br><span class="line">	②代码分析：通过代码里标识的注解对代码进行分析【使用反射】</span><br><span class="line">	③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* JDK中预定义的一些注解</span><br><span class="line">	* <span class="meta">@Override</span>	：检测被该注解标注的方法是否是继承自父类(接口)的</span><br><span class="line">	* <span class="meta">@Deprecated</span>：该注解标注的内容，表示已过时</span><br><span class="line">	* <span class="meta">@SuppressWarnings</span>：压制警告</span><br><span class="line">		* 一般传递参数all  <span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line"></span><br><span class="line">* 自定义注解</span><br><span class="line">	* 格式：</span><br><span class="line">		元注解</span><br><span class="line">		<span class="keyword">public</span> <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line">			属性列表;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	* 本质：注解本质上就是一个接口，该接口默认继承Annotation接口</span><br><span class="line">		* <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyAnno</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	* 属性：接口中的抽象方法</span><br><span class="line">		* 要求：</span><br><span class="line">			<span class="number">1</span>. 属性的返回值类型有下列取值</span><br><span class="line">				* 基本数据类型</span><br><span class="line">				* String</span><br><span class="line">				* 枚举</span><br><span class="line">				* 注解</span><br><span class="line">				* 以上类型的数组</span><br><span class="line"></span><br><span class="line">			<span class="number">2</span>. 定义了属性，在使用时需要给属性赋值</span><br><span class="line">				<span class="number">1</span>. 如果定义属性时，使用<span class="keyword">default</span>关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</span><br><span class="line">				<span class="number">2</span>. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</span><br><span class="line">				<span class="number">3</span>. 数组赋值时，值使用&#123;&#125;包裹。如果数组中只有一个值，则&#123;&#125;可以省略</span><br><span class="line">	</span><br><span class="line">	* 元注解：用于描述注解的注解</span><br><span class="line">		* <span class="meta">@Target</span>：描述注解能够作用的位置</span><br><span class="line">			* ElementType取值：</span><br><span class="line">				* TYPE：可以作用于类上</span><br><span class="line">				* METHOD：可以作用于方法上</span><br><span class="line">				* FIELD：可以作用于成员变量上</span><br><span class="line">		* <span class="meta">@Retention</span>：描述注解被保留的阶段</span><br><span class="line">			* <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到<span class="class"><span class="keyword">class</span>字节码文件中，并被<span class="title">JVM</span>读取到</span></span><br><span class="line"><span class="class">		* @<span class="title">Documented</span>：描述注解是否被抽取到<span class="title">api</span>文档中</span></span><br><span class="line"><span class="class">		* @<span class="title">Inherited</span>：描述注解是否被子类继承</span></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 在程序使用(解析)注解：获取注解中定义的属性值</span><br><span class="line">	<span class="number">1</span>. 获取注解定义的位置的对象  （Class，Method,Field）</span><br><span class="line">	<span class="number">2</span>. 获取指定的注解</span><br><span class="line">		* getAnnotation(Class)</span><br><span class="line">		<span class="comment">//其实就是在内存中生成了一个该注解接口的子类实现对象</span></span><br><span class="line"></span><br><span class="line">	            <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProImpl</span> <span class="keyword">implements</span> <span class="title">Pro</span></span>&#123;</span><br><span class="line">	                <span class="function"><span class="keyword">public</span> String <span class="title">className</span><span class="params">()</span></span>&#123;</span><br><span class="line">	                    <span class="keyword">return</span> <span class="string">"cn.itcast.annotation.Demo1"</span>;</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="function"><span class="keyword">public</span> String <span class="title">methodName</span><span class="params">()</span></span>&#123;</span><br><span class="line">	                    <span class="keyword">return</span> <span class="string">"show"</span>;</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	<span class="number">3</span>. 调用注解中的抽象方法获取配置的属性值</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 案例：简单的测试框架</span><br><span class="line">* 小结：</span><br><span class="line">	<span class="number">1</span>. 以后大多数时候，我们会使用注解，而不是自定义注解</span><br><span class="line">	<span class="number">2</span>. 注解给谁用？</span><br><span class="line">		<span class="number">1</span>. 编译器</span><br><span class="line">		<span class="number">2</span>. 给解析程序用</span><br><span class="line">	<span class="number">3</span>. 注解不是程序的一部分，可以理解为注解就是一个标签</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>java网络编程</title>
    <url>/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>软件架构CS／BS</li>
<li>网络通信三要素</li>
<li>TCP通信</li>
<li>Socket套接字</li>
<li>ServerSocket</li>
<li><a id="more"></a>


</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够辨别UDP和TCP协议特点</li>
<li><input disabled="" type="checkbox"> 能够说出TCP协议下两个常用类名称</li>
<li><input disabled="" type="checkbox"> 能够编写TCP协议下字符串数据传输程序</li>
<li><input disabled="" type="checkbox"> 能够理解TCP协议下文件上传案例</li>
<li><input disabled="" type="checkbox"> 能够理解TCP协议下案例2</li>
</ul>
<h1 id="第一章-网络编程入门"><a href="#第一章-网络编程入门" class="headerlink" title="第一章 网络编程入门"></a>第一章 网络编程入门</h1><h2 id="1-1软件结构"><a href="#1-1软件结构" class="headerlink" title="1.1软件结构"></a>1.1软件结构</h2><ul>
<li><strong>C/S结构</strong> ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。</li>
</ul>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1_cs.jpg" class="" title="cs">

<p><strong>B/S结构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</p>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2_bs.jpg" class="" title="bs">

<p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p>
<h2 id="1-2-网络通信协议"><a href="#1-2-网络通信协议" class="headerlink" title="1.2 网络通信协议"></a>1.2 网络通信协议</h2><ul>
<li><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li>
</ul>
<ul>
<li><p><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</p>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/3_tcp_ip.jpg" class="" title="四层">

</li>
</ul>
<p>上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p>
<h2 id="1-3-协议分类"><a href="#1-3-协议分类" class="headerlink" title="1.3 协议分类"></a>1.3 协议分类</h2><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p>
<p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p>
<ul>
<li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP是<strong>无连接通信</strong>协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p>
<p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p>
<p>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。</p>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/UDP%E9%80%9A%E4%BF%A1%E5%9B%BE%E8%A7%A3.bmp" class="" title="udp">

</li>
</ul>
<p>特点:数据被限制在64kb以内，超出这个范围就不能发送了。</p>
<p>数据报(Datagram):网络传输的基本单位 </p>
<ul>
<li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p>
<p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p>
<ul>
<li><p>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。</p>
<ul>
<li><p>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</p>
</li>
<li><p>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</p>
</li>
<li><p>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。</p>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/4_tcp.jpg" class="" title="tcp">

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​    完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p>
<h2 id="1-4-网络编程三要素"><a href="#1-4-网络编程三要素" class="headerlink" title="1.4 网络编程三要素"></a>1.4 网络编程三要素</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li>
</ul>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul>
<li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</li>
</ul>
<p><strong>IP地址分类</strong></p>
<ul>
<li><p>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p>
</li>
<li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p>
<p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p>
</li>
</ul>
<p><strong>常用命令</strong></p>
<ul>
<li>查看本机IP地址，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure>

<ul>
<li>检查网络是否连通，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ping 空格 IP地址</span><br><span class="line">ping <span class="number">220.181</span><span class="number">.57</span><span class="number">.216</span></span><br></pre></td></tr></table></figure>

<p><strong>特殊的IP地址</strong></p>
<ul>
<li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li>
</ul>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p>
<p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p>
<ul>
<li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li>
</ul>
<p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p>
<h1 id="第二章-TCP通信程序"><a href="#第二章-TCP通信程序" class="headerlink" title="第二章 TCP通信程序"></a>第二章 TCP通信程序</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。</p>
<p><strong>两端通信时步骤：</strong></p>
<ol>
<li>服务端程序，需要事先启动，等待客户端的连接。</li>
<li>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。</li>
</ol>
<p><strong>在Java中，提供了两个类用于实现TCP通信程序：</strong></p>
<ol>
<li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li>
<li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li>
</ol>
<h2 id="2-2-Socket类"><a href="#2-2-Socket类" class="headerlink" title="2.2 Socket类"></a>2.2 Socket类</h2><p><code>Socket</code> 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><p><code>public Socket(String host, int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。  </p>
<blockquote>
<p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p>
</blockquote>
</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket client = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><p><code>public InputStream getInputStream()</code> ： 返回此套接字的输入流。</p>
<ul>
<li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li>
<li>关闭生成的InputStream也将关闭相关的Socket。</li>
</ul>
</li>
<li><p><code>public OutputStream getOutputStream()</code> ： 返回此套接字的输出流。</p>
<ul>
<li>如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li>
<li>关闭生成的OutputStream也将关闭相关的Socket。</li>
</ul>
</li>
<li><p><code>public void close()</code> ：关闭此套接字。</p>
<ul>
<li>一旦一个socket被关闭，它不可再使用。</li>
<li>关闭此socket也将关闭相关的InputStream和OutputStream 。 </li>
</ul>
</li>
<li><p><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。   </p>
<ul>
<li>任何先前写出的数据将被发送，随后终止输出流。 </li>
</ul>
<h2 id="2-3-ServerSocket类"><a href="#2-3-ServerSocket类" class="headerlink" title="2.3 ServerSocket类"></a>2.3 ServerSocket类</h2></li>
</ul>
<p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ServerSocket(int port)</code> ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><code>public Socket accept()</code> ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 </li>
</ul>
<h2 id="2-4-简单的TCP网络程序"><a href="#2-4-简单的TCP网络程序" class="headerlink" title="2.4 简单的TCP网络程序"></a>2.4 简单的TCP网络程序</h2><h3 id="TCP通信分析图解"><a href="#TCP通信分析图解" class="headerlink" title="TCP通信分析图解"></a>TCP通信分析图解</h3><ol>
<li>【服务端】启动,创建ServerSocket对象，等待连接。</li>
<li>【客户端】启动,创建Socket对象，请求连接。</li>
<li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li>
<li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li>
<li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。</li>
</ol>
<blockquote>
<p>到此，客户端向服务端发送数据成功。</p>
</blockquote>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/5_%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%A1.jpg" class="" title="简单通信">

<blockquote>
<p>自此，服务端向客户端回写数据。</p>
</blockquote>
<ol start="6">
<li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li>
<li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li>
<li>【客户端】释放资源，断开连接。</li>
</ol>
<h3 id="客户端向服务器发送数据"><a href="#客户端向服务器发送数据" class="headerlink" title="客户端向服务器发送数据"></a>客户端向服务器发送数据</h3><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTCP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        Socket server = ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        InputStream is = server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      	<span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      	<span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="keyword">int</span> len = is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        String msg = <span class="keyword">new</span> String(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="comment">//5.关闭资源.</span></span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTCP</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"客户端 发送数据"</span>);</span><br><span class="line">		<span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">		Socket client = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">		<span class="comment">// 2.获取流对象 . 输出流</span></span><br><span class="line">		OutputStream os = client.getOutputStream();</span><br><span class="line">		<span class="comment">// 3.写出数据.</span></span><br><span class="line">		os.write(<span class="string">"你好么? tcp ,我来了"</span>.getBytes());</span><br><span class="line">		<span class="comment">// 4. 关闭资源 .</span></span><br><span class="line">		os.close();</span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务器向客户端回写数据"><a href="#服务器向客户端回写数据" class="headerlink" title="服务器向客户端回写数据"></a>服务器向客户端回写数据</h3><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTCP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        Socket server = ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        InputStream is = server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      	<span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      	<span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="keyword">int</span> len = is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        String msg = <span class="keyword">new</span> String(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">      	<span class="comment">// =================回写数据=======================</span></span><br><span class="line">      	<span class="comment">// 5. 通过 socket 获取输出流</span></span><br><span class="line">      	 OutputStream out = server.getOutputStream();</span><br><span class="line">      	<span class="comment">// 6. 回写数据</span></span><br><span class="line">      	 out.write(<span class="string">"我很好,谢谢你"</span>.getBytes());</span><br><span class="line">      	<span class="comment">// 7.关闭资源.</span></span><br><span class="line">      	out.close();</span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTCP</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"客户端 发送数据"</span>);</span><br><span class="line">		<span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">		Socket client = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">		<span class="comment">// 2.通过Scoket,获取输出流对象 </span></span><br><span class="line">		OutputStream os = client.getOutputStream();</span><br><span class="line">		<span class="comment">// 3.写出数据.</span></span><br><span class="line">		os.write(<span class="string">"你好么? tcp ,我来了"</span>.getBytes());</span><br><span class="line">      	<span class="comment">// ==============解析回写=========================</span></span><br><span class="line">      	<span class="comment">// 4. 通过Scoket,获取 输入流对象</span></span><br><span class="line">      	InputStream in = client.getInputStream();</span><br><span class="line">      	<span class="comment">// 5. 读取数据数据</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">      	<span class="keyword">int</span> len = in.read(b);</span><br><span class="line">      	System.out.println(<span class="keyword">new</span> String(b, <span class="number">0</span>, len));</span><br><span class="line">		<span class="comment">// 6. 关闭资源 .</span></span><br><span class="line">      	in.close();</span><br><span class="line">		os.close();</span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件上传案例"><a href="#3-1-文件上传案例" class="headerlink" title="3.1 文件上传案例"></a>3.1 文件上传案例</h2><h3 id="文件上传分析图解"><a href="#文件上传分析图解" class="headerlink" title="文件上传分析图解"></a>文件上传分析图解</h3><ol>
<li>【客户端】输入流，从硬盘读取文件数据到程序中。</li>
<li>【客户端】输出流，写出文件数据到服务端。</li>
<li>【服务端】输入流，读取文件数据到服务端程序。</li>
<li>【服务端】输出流，写出文件数据到服务器硬盘中。</li>
</ol>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/6_upload.jpg" class="" title="案例分析">    

<h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">      	ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">  		<span class="comment">// 2. 建立连接 </span></span><br><span class="line">        Socket accept = serverSocket.accept();</span><br><span class="line">      	<span class="comment">// 3. 创建流对象</span></span><br><span class="line">      	<span class="comment">// 3.1 获取输入流,读取文件数据</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">        <span class="comment">// 3.2 创建输出流,保存到本地 .</span></span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"copy.jpg"</span>));</span><br><span class="line">		<span class="comment">// 4. 读写数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5. 关闭 资源</span></span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">        accept.close();</span><br><span class="line">        System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUPload_Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流,读取本地文件  </span></span><br><span class="line">        BufferedInputStream bis  = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.jpg"</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端 </span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">        BufferedOutputStream   bos   = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据. </span></span><br><span class="line">        <span class="keyword">byte</span>[] b  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="keyword">int</span> len ; </span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">            bos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"文件发送完毕"</span>);</span><br><span class="line">        <span class="comment">// 3.释放资源</span></span><br><span class="line"></span><br><span class="line">        bos.close(); </span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close(); </span><br><span class="line">        System.out.println(<span class="string">"文件上传完毕 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件上传优化分析"><a href="#文件上传优化分析" class="headerlink" title="文件上传优化分析"></a>文件上传优化分析</h3><ol>
<li><p><strong>文件名称写死的问题</strong></p>
<p>服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis()+<span class="string">".jpg"</span>) <span class="comment">// 文件名称</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>循环接收的问题</strong></p>
<p>服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每次接收新的连接,创建一个Socket</span></span><br><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">    Socket accept = serverSocket.accept();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>效率问题</strong></p>
<p>服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">    Socket accept = serverSocket.accept();</span><br><span class="line">    <span class="comment">// accept 交给子线程处理.</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      	......</span><br><span class="line">        InputStream bis = accept.getInputStream();</span><br><span class="line">      	......</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">      	<span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">          	<span class="comment">/* </span></span><br><span class="line"><span class="comment">          	3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="string">".jpg"</span>);</span><br><span class="line">                    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                      bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//4. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                  	e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信息回写分析图解"><a href="#信息回写分析图解" class="headerlink" title="信息回写分析图解"></a>信息回写分析图解</h3><p>前四步与基本文件上传一致.</p>
<ol start="5">
<li>【服务端】获取输出流，回写数据。</li>
<li>【客户端】获取输入流，解析回写数据。</li>
</ol>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/6_upload2.jpg" class="" title="回写分析">    

<h4 id="回写实现"><a href="#回写实现" class="headerlink" title="回写实现"></a>回写实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">          	<span class="comment">/*</span></span><br><span class="line"><span class="comment">          	3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="string">".jpg"</span>);</span><br><span class="line">                    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.=======信息回写===========================</span></span><br><span class="line">                    System.out.println(<span class="string">"back ........"</span>);</span><br><span class="line">                    OutputStream out = accept.getOutputStream();</span><br><span class="line">                    out.write(<span class="string">"上传成功"</span>.getBytes());</span><br><span class="line">                    out.close();</span><br><span class="line">                    <span class="comment">//================================</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//5. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流,读取本地文件</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.jpg"</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据.</span></span><br><span class="line">        <span class="keyword">byte</span>[] b  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="keyword">int</span> len ;</span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 关闭输出流,通知服务端,写出数据完毕</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        System.out.println(<span class="string">"文件发送完毕"</span>);</span><br><span class="line">        <span class="comment">// 3. =====解析回写============</span></span><br><span class="line">        InputStream in = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] back = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">        in.read(back);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(back));</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="comment">// ============================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/04_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%A1%88%E4%BE%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98.bmp" class="" title="堵塞分析">    

<h2 id="3-2-模拟B-S服务器-扩展知识点"><a href="#3-2-模拟B-S服务器-扩展知识点" class="headerlink" title="3.2 模拟B\S服务器(扩展知识点)"></a>3.2 模拟B\S服务器(扩展知识点)</h2><p>模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li><p>我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    	ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8000</span>);</span><br><span class="line">    	Socket socket = server.accept();</span><br><span class="line">    	InputStream in = socket.getInputStream();</span><br><span class="line">   	    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    	<span class="keyword">int</span> len = in.read(bytes);</span><br><span class="line">    	System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">    	socket.close();</span><br><span class="line">    	server.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE.jpg" class="" title="无法访问">  
</li>
<li><p>服务器程序中字节输入流可以读取到浏览器发来的请求信息</p>
<p><img src="H:/%E5%8E%8B%E7%BC%A9%E5%8C%85/02-Java%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/02-Java%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/day11_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/img/%E8%AF%BB%E5%8F%96%E8%AE%BF%E9%97%AE%E4%BF%A1%E6%81%AF.jpg" alt=""></p>
</li>
</ol>
<p>GET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line">BufferedReader readWb = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">String requst = readWb.readLine();</span><br><span class="line"><span class="comment">//取出请求资源的路径</span></span><br><span class="line">String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line"><span class="comment">//去掉web前面的/</span></span><br><span class="line">String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">System.out.println(path);</span><br></pre></td></tr></table></figure>

<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>服务端实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端  启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 创建ServerSocket 对象</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        <span class="comment">// 转换流读取浏览器的请求消息</span></span><br><span class="line">        BufferedReader readWb = <span class="keyword">new</span></span><br><span class="line">        BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">        String requst = readWb.readLine();</span><br><span class="line">        <span class="comment">// 取出请求资源的路径</span></span><br><span class="line">        String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">// 去掉web前面的/</span></span><br><span class="line">        String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 读取客户端请求的资源文件</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">// 字节输出流,将文件写会客户端</span></span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 写入HTTP协议响应头,固定写法</span></span><br><span class="line">        out.write(<span class="string">"HTTP/1.1 200 OK\r\n"</span>.getBytes());</span><br><span class="line">        out.write(<span class="string">"Content-Type:text/html\r\n"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 必须要写入空行,否则浏览器不解析</span></span><br><span class="line">        out.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        out.close();</span><br><span class="line">        readWb.close();	</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问效果"><a href="#访问效果" class="headerlink" title="访问效果"></a>访问效果</h3><ul>
<li><p><strong>火狐</strong></p>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E6%95%88%E6%9E%9C%E5%9B%BE1.png" class="" title="无法访问">  

</li>
</ul>
<blockquote>
<p>小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。</p>
</blockquote>
<p>发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。</p>
<p>浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket socket = server.accept();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Web(socket)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Web</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket=socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line">                BufferedReader readWb = <span class="keyword">new</span></span><br><span class="line">                        BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String requst = readWb.readLine();</span><br><span class="line">                <span class="comment">//取出请求资源的路径</span></span><br><span class="line">                String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line">                System.out.println(Arrays.toString(strArr));</span><br><span class="line">                String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">                System.out.println(path);</span><br><span class="line"></span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">                System.out.println(fis);</span><br><span class="line">                <span class="keyword">byte</span>[] bytes= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">                <span class="comment">//向浏览器 回写数据</span></span><br><span class="line">                OutputStream out = socket.getOutputStream();</span><br><span class="line">                out.write(<span class="string">"HTTP/1.1 200 OK\r\n"</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">"Content-Type:text/html\r\n"</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">                <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">                &#125;</span><br><span class="line">                fis.close();</span><br><span class="line">                out.close();</span><br><span class="line">                readWb.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问效果：</strong></p>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E6%95%88%E6%9E%9C%E5%9B%BE2.png" class="" title="无法访问">  

<p><img src="H:/%E5%8E%8B%E7%BC%A9%E5%8C%85/02-Java%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/02-Java%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/day11_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/img/%E6%95%88%E6%9E%9C%E5%9B%BE2.png" alt="">图解：</p>
<img src="/2020/04/07/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/BS%E9%80%9A%E4%BF%A1.bmp" class="" title="bs分析"> ]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC连接池</title>
    <url>/2020/04/06/JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>1.数据库连接池</p>
<p>2.Spring JDBC : JDBC Template</p>
<a id="more"></a>

<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><img src="/2020/04/06/JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.bmp" class="" title="数据库连接池">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 概念：其实就是一个容器(集合)，存放数据库连接的容器。</span><br><span class="line">	当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 好处：</span><br><span class="line">	<span class="number">1</span>. 节约资源</span><br><span class="line">	<span class="number">2</span>. 用户访问高效</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 实现：</span><br><span class="line">	<span class="number">1</span>. 标准接口：DataSource   javax.sql包下的</span><br><span class="line">		<span class="number">1</span>. 方法：</span><br><span class="line">			* 获取连接：getConnection()</span><br><span class="line">			* 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接</span><br><span class="line"></span><br><span class="line">	<span class="number">2</span>. 一般我们不去实现它，有数据库厂商来实现</span><br><span class="line">		<span class="number">1</span>. C3P0：数据库连接池技术</span><br><span class="line">		<span class="number">2</span>. Druid：数据库连接池实现技术，由阿里巴巴提供的</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>. C3P0：数据库连接池技术</span><br><span class="line">	* 步骤：</span><br><span class="line">		<span class="number">1</span>. 导入jar包 (两个) c3p0-<span class="number">0.9</span><span class="number">.5</span><span class="number">.2</span>.jar mchange-commons-java-<span class="number">0.2</span><span class="number">.12</span>.jar ，</span><br><span class="line">			* 不要忘记导入数据库驱动jar包</span><br><span class="line">		<span class="number">2</span>. 定义配置文件：</span><br><span class="line">			* 名称： c3p0.properties 或者 c3p0-config.xml</span><br><span class="line">			* 路径：直接将文件放在src目录下即可。</span><br><span class="line"></span><br><span class="line">		<span class="number">3</span>. 创建核心对象 数据库连接池对象 ComboPooledDataSource</span><br><span class="line">		<span class="number">4</span>. 获取连接： getConnection</span><br><span class="line">	* 代码：</span><br><span class="line">		 <span class="comment">//1.创建数据库连接池对象</span></span><br><span class="line">        DataSource ds  = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">        <span class="comment">//2. 获取连接对象</span></span><br><span class="line">        Connection conn = ds.getConnection();</span><br><span class="line"><span class="number">5</span>. Druid：数据库连接池实现技术，由阿里巴巴提供的</span><br><span class="line">	<span class="number">1</span>. 步骤：</span><br><span class="line">		<span class="number">1</span>. 导入jar包 druid-<span class="number">1.0</span><span class="number">.9</span>.jar</span><br><span class="line">		<span class="number">2</span>. 定义配置文件：</span><br><span class="line">			* 是properties形式的</span><br><span class="line">			* 可以叫任意名称，可以放在任意目录下</span><br><span class="line">		<span class="number">3</span>. 加载配置文件。Properties</span><br><span class="line">		<span class="number">4</span>. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory</span><br><span class="line">		<span class="number">5</span>. 获取连接：getConnection</span><br><span class="line">	* 代码：</span><br><span class="line">		 <span class="comment">//3.加载配置文件</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream("druid.properties");</span><br><span class="line">        pro.load(is);</span><br><span class="line">        <span class="comment">//4.获取连接池对象</span></span><br><span class="line">        DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        <span class="comment">//5.获取连接</span></span><br><span class="line">        Connection conn = ds.getConnection();</span><br><span class="line">	<span class="number">2</span>. 定义工具类</span><br><span class="line">		<span class="number">1</span>. 定义一个类 JDBCUtils</span><br><span class="line">		<span class="number">2</span>. 提供静态代码块加载配置文件，初始化连接池对象</span><br><span class="line">		<span class="number">3</span>. 提供方法</span><br><span class="line">			<span class="number">1</span>. 获取连接方法：通过数据库连接池获取连接</span><br><span class="line">			<span class="number">2</span>. 释放资源</span><br><span class="line">			<span class="number">3</span>. 获取连接池的方法</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 代码：</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">//1.定义成员变量 DataSource</span></span><br><span class="line">	    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds ;</span><br><span class="line">	</span><br><span class="line">	    <span class="keyword">static</span>&#123;</span><br><span class="line">	        <span class="keyword">try</span> &#123;</span><br><span class="line">	            <span class="comment">//1.加载配置文件</span></span><br><span class="line">	            Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">	                pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties"));</span><br><span class="line">	            <span class="comment">//2.获取DataSource</span></span><br><span class="line">	            ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">	        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	            e.printStackTrace();</span><br><span class="line">	        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	            e.printStackTrace();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 获取连接</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 释放资源</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt,Connection conn)</span></span>&#123;</span><br><span class="line">	       <span class="comment">/* if(stmt != null)&#123;</span></span><br><span class="line"><span class="comment">	            try &#123;</span></span><br><span class="line"><span class="comment">	                stmt.close();</span></span><br><span class="line"><span class="comment">	            &#125; catch (SQLException e) &#123;</span></span><br><span class="line"><span class="comment">	                e.printStackTrace();</span></span><br><span class="line"><span class="comment">	            &#125;</span></span><br><span class="line"><span class="comment">	        &#125;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	        if(conn != null)&#123;</span></span><br><span class="line"><span class="comment">	            try &#123;</span></span><br><span class="line"><span class="comment">	                conn.close();//归还连接</span></span><br><span class="line"><span class="comment">	            &#125; catch (SQLException e) &#123;</span></span><br><span class="line"><span class="comment">	                e.printStackTrace();</span></span><br><span class="line"><span class="comment">	            &#125;</span></span><br><span class="line"><span class="comment">	        &#125;*/</span></span><br><span class="line">	</span><br><span class="line">	       close(<span class="keyword">null</span>,stmt,conn);</span><br><span class="line">	    &#125;</span><br></pre></td></tr></table></figure>


<p>​            </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs , Statement stmt, Connection conn)</span></span>&#123;</span><br></pre></td></tr></table></figure>


<p>​            </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        rs.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>​            </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();<span class="comment">//归还连接</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接池方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发</span><br><span class="line">* 步骤：</span><br><span class="line">	<span class="number">1</span>. 导入jar包</span><br><span class="line">	<span class="number">2</span>. 创建JdbcTemplate对象。依赖于数据源DataSource</span><br><span class="line">		* JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(ds);</span><br><span class="line"></span><br><span class="line">	<span class="number">3</span>. 调用JdbcTemplate的方法来完成CRUD的操作</span><br><span class="line">		* update():执行DML语句。增、删、改语句</span><br><span class="line">		* queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合</span><br><span class="line">			* 注意：这个方法查询的结果集长度只能是<span class="number">1</span></span><br><span class="line">		* queryForList():查询结果将结果集封装为list集合</span><br><span class="line">			* 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</span><br><span class="line">		* query():查询结果，将结果封装为JavaBean对象</span><br><span class="line">			* query的参数：RowMapper</span><br><span class="line">				* 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</span><br><span class="line">				* <span class="keyword">new</span> BeanPropertyRowMapper&lt;类型&gt;(类型<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">		* <span class="title">queryForObject</span>：查询结果，将结果封装为对象</span></span><br><span class="line"><span class="class">			* 一般用于聚合函数的查询</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">	4. 练习：</span></span><br><span class="line"><span class="class">		* 需求：</span></span><br><span class="line"><span class="class">			1. 修改1号数据的 <span class="title">salary</span> 为 10000</span></span><br><span class="line"><span class="class">			2. 添加一条记录</span></span><br><span class="line"><span class="class">			3. 删除刚才添加的记录</span></span><br><span class="line"><span class="class">			4. 查询<span class="title">id</span>为1的记录，将其封装为<span class="title">Map</span>集合</span></span><br><span class="line"><span class="class">			5. 查询所有记录，将其封装为<span class="title">List</span></span></span><br><span class="line"><span class="class">			6. 查询所有记录，将其封装为<span class="title">Emp</span>对象的<span class="title">List</span>集合</span></span><br><span class="line"><span class="class">			7. 查询总记录数</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">		* 代码：</span></span><br><span class="line"><span class="class">			</span></span><br><span class="line"><span class="class">			<span class="title">import</span> <span class="title">cn</span>.<span class="title">itcast</span>.<span class="title">domain</span>.<span class="title">Emp</span></span>;</span><br><span class="line">			<span class="keyword">import</span> cn.itcast.utils.JDBCUtils;</span><br><span class="line">			<span class="keyword">import</span> org.junit.Test;</span><br><span class="line">			<span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line">			<span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line">			<span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">import</span> java.sql.Date;</span><br><span class="line">			<span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line">			<span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line">			<span class="keyword">import</span> java.util.List;</span><br><span class="line">			<span class="keyword">import</span> java.util.Map;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo2</span> </span>&#123;</span><br><span class="line">			</span><br><span class="line">			    <span class="comment">//Junit单元测试，可以让方法独立执行</span></span><br></pre></td></tr></table></figure>


<p>​                </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取JDBCTemplate对象</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate template = <span class="keyword">new</span>  JdbcTemplate(JDBCUtils.getDataSource());</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 修改1号数据的 salary 为 10000</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">    <span class="comment">//2. 定义sql</span></span><br><span class="line">    String sql = <span class="string">"update emp set salary = 10000 where id = 1001"</span>;</span><br><span class="line">    <span class="comment">//3. 执行sql</span></span><br><span class="line">    <span class="keyword">int</span> count = template.update(sql);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line">			</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2. 添加一条记录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"insert into emp(id,ename,dept_id) values(?,?,?)"</span>;</span><br><span class="line">    <span class="keyword">int</span> count = template.update(sql, <span class="number">1015</span>, <span class="string">"郭靖"</span>, <span class="number">10</span>);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">			</span><br><span class="line">&#125;</span><br><span class="line">			</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3.删除刚才添加的记录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"delete from emp where id = ?"</span>;</span><br><span class="line">    <span class="keyword">int</span> count = template.update(sql, <span class="number">1015</span>);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line">			</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4.查询id为1001的记录，将其封装为Map集合</span></span><br><span class="line"><span class="comment"> * 注意：这个方法查询的结果集长度只能是1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"select * from emp where id = ? or id = ?"</span>;</span><br><span class="line">    Map&lt;String, Object&gt; map = template.queryForMap(sql, <span class="number">1001</span>,<span class="number">1002</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">    <span class="comment">//&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;</span></span><br><span class="line">			</span><br><span class="line">&#125;</span><br><span class="line">			</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 5. 查询所有记录，将其封装为List</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);</span><br><span class="line">			</span><br><span class="line">    <span class="keyword">for</span> (Map&lt;String, Object&gt; stringObjectMap : list) &#123;</span><br><span class="line">        System.out.println(stringObjectMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">			</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 6. 查询所有记录，将其封装为Emp对象的List集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">			</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">    List&lt;Emp&gt; list = template.query(sql, <span class="keyword">new</span> RowMapper&lt;Emp&gt;() &#123;</span><br><span class="line">			</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Emp <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            Emp emp = <span class="keyword">new</span> Emp();</span><br><span class="line">            <span class="keyword">int</span> id = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">            String ename = rs.getString(<span class="string">"ename"</span>);</span><br><span class="line">            <span class="keyword">int</span> job_id = rs.getInt(<span class="string">"job_id"</span>);</span><br><span class="line">            <span class="keyword">int</span> mgr = rs.getInt(<span class="string">"mgr"</span>);</span><br><span class="line">            Date joindate = rs.getDate(<span class="string">"joindate"</span>);</span><br><span class="line">            <span class="keyword">double</span> salary = rs.getDouble(<span class="string">"salary"</span>);</span><br><span class="line">            <span class="keyword">double</span> bonus = rs.getDouble(<span class="string">"bonus"</span>);</span><br><span class="line">            <span class="keyword">int</span> dept_id = rs.getInt(<span class="string">"dept_id"</span>);</span><br><span class="line">			</span><br><span class="line">            emp.setId(id);</span><br><span class="line">            emp.setEname(ename);</span><br><span class="line">            emp.setJob_id(job_id);</span><br><span class="line">            emp.setMgr(mgr);</span><br><span class="line">            emp.setJoindate(joindate);</span><br><span class="line">            emp.setSalary(salary);</span><br><span class="line">            emp.setBonus(bonus);</span><br><span class="line">            emp.setDept_id(dept_id);</span><br><span class="line">			</span><br><span class="line">            <span class="keyword">return</span> emp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>


<p>​                </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">        List&lt;Emp&gt; list = template.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Emp&gt;(Emp<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        <span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 7. 查询总记录数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select count(id) from emp"</span>;</span><br><span class="line">        Long total = template.queryForObject(sql, Long<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(total);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC基础</title>
    <url>/2020/04/04/JDBC%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><ol>
<li>JDBC基本概念</li>
<li>快速入门</li>
<li>对JDBC中各个接口和类详解</li>
</ol>
<a id="more"></a>

<h2 id="JDBC："><a href="#JDBC：" class="headerlink" title="JDBC："></a>JDBC：</h2><img src="/2020/04/04/JDBC%E5%9F%BA%E7%A1%80/JDBC%E6%9C%AC%E8%B4%A8.bmp" class="" title="JDBC本质">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库</span><br><span class="line">	* JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 快速入门：</span><br><span class="line">	* 步骤：</span><br><span class="line">		<span class="number">1</span>. 导入驱动jar包 mysql-connector-java-<span class="number">5.1</span><span class="number">.37</span>-bin.jar</span><br><span class="line">			<span class="number">1</span>.复制mysql-connector-java-<span class="number">5.1</span><span class="number">.37</span>-bin.jar到项目的libs目录下</span><br><span class="line">			<span class="number">2</span>.右键--&gt;Add As Library</span><br><span class="line">		<span class="number">2</span>. 注册驱动</span><br><span class="line">		<span class="number">3</span>. 获取数据库连接对象 Connection</span><br><span class="line">		<span class="number">4</span>. 定义sql</span><br><span class="line">		<span class="number">5</span>. 获取执行sql语句的对象 Statement</span><br><span class="line">		<span class="number">6</span>. 执行sql，接受返回结果</span><br><span class="line">		<span class="number">7</span>. 处理结果</span><br><span class="line">		<span class="number">8</span>. 释放资源</span><br><span class="line"></span><br><span class="line">	* 代码实现：</span><br><span class="line">	  	<span class="comment">//1. 导入驱动jar包</span></span><br><span class="line">        <span class="comment">//2.注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        <span class="comment">//3.获取数据库连接对象</span></span><br><span class="line">        Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/db3"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">        <span class="comment">//4.定义sql语句</span></span><br><span class="line">        String sql = <span class="string">"update account set balance = 500 where id = 1"</span>;</span><br><span class="line">        <span class="comment">//5.获取执行sql的对象 Statement</span></span><br><span class="line">        Statement stmt = conn.createStatement();</span><br><span class="line">        <span class="comment">//6.执行sql</span></span><br><span class="line">        <span class="keyword">int</span> count = stmt.executeUpdate(sql);</span><br><span class="line">        <span class="comment">//7.处理结果</span></span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//8.释放资源</span></span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 详解各个对象：</span><br><span class="line">	<span class="number">1</span>. DriverManager：驱动管理对象</span><br><span class="line">		* 功能：</span><br><span class="line">			<span class="number">1</span>. 注册驱动：告诉程序该使用哪一个数据库驱动jar</span><br><span class="line">				<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(Driver driver)</span> :注册与给定的驱动程序 DriverManager 。 </span></span><br><span class="line"><span class="function">				写代码使用：  Class.<span class="title">forName</span><span class="params">(<span class="string">"com.mysql.jdbc.Driver"</span>)</span></span>;</span><br><span class="line">				通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块</span><br><span class="line">				 <span class="keyword">static</span> &#123;</span><br><span class="line">				        <span class="keyword">try</span> &#123;</span><br><span class="line">				            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">				        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">				            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">				        &#125;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。</span><br><span class="line">			<span class="number">2</span>. 获取数据库连接：</span><br><span class="line">				* 方法：<span class="function"><span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url, String user, String password)</span> </span></span><br><span class="line"><span class="function">				* 参数：</span></span><br><span class="line"><span class="function">					* url：指定连接的路径</span></span><br><span class="line"><span class="function">						* 语法：jdbc:mysql:<span class="comment">//ip地址(域名):端口号/数据库名称</span></span></span><br><span class="line"><span class="function">						* 例子：jdbc:mysql:<span class="comment">//localhost:3306/db3</span></span></span><br><span class="line"><span class="function">						* 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:<span class="comment">///数据库名称</span></span></span><br><span class="line"><span class="function">					* user：用户名</span></span><br><span class="line"><span class="function">					* password：密码 </span></span><br><span class="line"><span class="function">	2. Connection：数据库连接对象</span></span><br><span class="line"><span class="function">		1. 功能：</span></span><br><span class="line"><span class="function">			1. 获取执行sql 的对象</span></span><br><span class="line"><span class="function">				* Statement <span class="title">createStatement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">				* PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql)</span>  </span></span><br><span class="line"><span class="function">			2. 管理事务：</span></span><br><span class="line"><span class="function">				* 开启事务：<span class="title">setAutoCommit</span><span class="params">(<span class="keyword">boolean</span> autoCommit)</span> ：调用该方法设置参数为<span class="keyword">false</span>，即开启事务</span></span><br><span class="line"><span class="function">				* 提交事务：<span class="title">commit</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">				* 回滚事务：<span class="title">rollback</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	3. Statement：执行sql的对象</span></span><br><span class="line"><span class="function">		1. 执行sql</span></span><br><span class="line"><span class="function">			1. <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String sql)</span> ：可以执行任意的sql 了解 </span></span><br><span class="line"><span class="function">			2. <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(String sql)</span> ：执行DML（insert、update、delete）语句、<span class="title">DDL</span><span class="params">(create，alter、drop)</span>语句</span></span><br><span class="line"><span class="function">				* 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。</span></span><br><span class="line"><span class="function">			3. ResultSet <span class="title">executeQuery</span><span class="params">(String sql)</span>  ：执行DQL（select)语句</span></span><br><span class="line"><span class="function">		2. 练习：</span></span><br><span class="line"><span class="function">			1. account表 添加一条记录</span></span><br><span class="line"><span class="function">			2. account表 修改记录</span></span><br><span class="line"><span class="function">			3. account表 删除一条记录</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">			代码：</span></span><br><span class="line"><span class="function">				Statement stmt </span>= <span class="keyword">null</span>;</span><br><span class="line">		        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">		        <span class="keyword">try</span> &#123;</span><br><span class="line">		            <span class="comment">//1. 注册驱动</span></span><br><span class="line">		            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">		            <span class="comment">//2. 定义sql</span></span><br><span class="line">		            String sql = <span class="string">"insert into account values(null,'王五',3000)"</span>;</span><br><span class="line">		            <span class="comment">//3.获取Connection对象</span></span><br><span class="line">		            conn = DriverManager.getConnection(<span class="string">"jdbc:mysql:///db3"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">		            <span class="comment">//4.获取执行sql的对象 Statement</span></span><br><span class="line">		            stmt = conn.createStatement();</span><br><span class="line">		            <span class="comment">//5.执行sql</span></span><br><span class="line">		            <span class="keyword">int</span> count = stmt.executeUpdate(sql);<span class="comment">//影响的行数</span></span><br><span class="line">		            <span class="comment">//6.处理结果</span></span><br><span class="line">		            System.out.println(count);</span><br><span class="line">		            <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		                System.out.println(<span class="string">"添加成功！"</span>);</span><br><span class="line">		            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		                System.out.println(<span class="string">"添加失败！"</span>);</span><br><span class="line">		            &#125;</span><br><span class="line">		</span><br><span class="line">		        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">		            e.printStackTrace();</span><br><span class="line">		        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">		            e.printStackTrace();</span><br><span class="line">		        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		            <span class="comment">//stmt.close();</span></span><br><span class="line">		            <span class="comment">//7. 释放资源</span></span><br><span class="line">		            <span class="comment">//避免空指针异常</span></span><br><span class="line">		            <span class="keyword">if</span>(stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">		                <span class="keyword">try</span> &#123;</span><br><span class="line">		                    stmt.close();</span><br><span class="line">		                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">		                    e.printStackTrace();</span><br><span class="line">		                &#125;</span><br><span class="line">		            &#125;</span><br><span class="line">		</span><br><span class="line">		            <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">		                <span class="keyword">try</span> &#123;</span><br><span class="line">		                    conn.close();</span><br><span class="line">		                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">		                    e.printStackTrace();</span><br><span class="line">		                &#125;</span><br><span class="line">		            &#125;</span><br><span class="line">		        &#125;</span><br><span class="line">			</span><br><span class="line">	<span class="number">4</span>. ResultSet：结果集对象,封装查询结果</span><br><span class="line">		* <span class="function"><span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span>: 游标向下移动一行，判断当前行是否是最后一行末尾<span class="params">(是否有数据)</span>，如果是，则返回<span class="keyword">false</span>，如果不是则返回<span class="keyword">true</span></span></span><br><span class="line"><span class="function">		* <span class="title">getXxx</span><span class="params">(参数)</span>:获取数据</span></span><br><span class="line"><span class="function">			* Xxx：代表数据类型   如： <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> ,	String <span class="title">getString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">			* 参数：</span></span><br><span class="line"><span class="function">				1. <span class="keyword">int</span>：代表列的编号,从1开始   如： <span class="title">getString</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">				2. String：代表列名称。 如： <span class="title">getDouble</span><span class="params">(<span class="string">"balance"</span>)</span></span></span><br><span class="line"><span class="function">		</span></span><br><span class="line"><span class="function">		* 注意：</span></span><br><span class="line"><span class="function">			* 使用步骤：</span></span><br><span class="line"><span class="function">				1. 游标向下移动一行</span></span><br><span class="line"><span class="function">				2. 判断是否有数据</span></span><br><span class="line"><span class="function">				3. 获取数据</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">			   <span class="comment">//循环判断游标是否是最后一行末尾。</span></span></span><br><span class="line"><span class="function">	            <span class="title">while</span><span class="params">(rs.next()</span>)</span>&#123;</span><br><span class="line">	                <span class="comment">//获取数据</span></span><br><span class="line">	                <span class="comment">//6.2 获取数据</span></span><br><span class="line">	                <span class="keyword">int</span> id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">	                String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">	                <span class="keyword">double</span> balance = rs.getDouble(<span class="number">3</span>);</span><br><span class="line">	</span><br><span class="line">	                System.out.println(id + <span class="string">"---"</span> + name + <span class="string">"---"</span> + balance);</span><br><span class="line">	            &#125;</span><br><span class="line"></span><br><span class="line">		* 练习：</span><br><span class="line">			* 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。</span><br><span class="line">				<span class="number">1</span>. 定义Emp类</span><br><span class="line">				<span class="number">2</span>. 定义方法 <span class="function"><span class="keyword">public</span> List&lt;Emp&gt; <span class="title">findAll</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">				<span class="number">3</span>. 实现方法 select * from emp;</span><br><span class="line">					</span><br><span class="line">	<span class="number">5</span>. PreparedStatement：执行sql的对象</span><br><span class="line">		<span class="number">1</span>. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题</span><br><span class="line">			<span class="number">1</span>. 输入用户随便，输入密码：a<span class="string">' or '</span>a<span class="string">' = '</span>a</span><br><span class="line">			<span class="number">2</span>. sql：select * from user where username = <span class="string">'fhdsjkf'</span> and password = <span class="string">'a'</span> or <span class="string">'a'</span> = <span class="string">'a'</span> </span><br><span class="line"></span><br><span class="line">		<span class="number">2</span>. 解决sql注入问题：使用PreparedStatement对象来解决</span><br><span class="line">		<span class="number">3</span>. 预编译的SQL：参数使用?作为占位符</span><br><span class="line">		<span class="number">4</span>. 步骤：</span><br><span class="line">			<span class="number">1</span>. 导入驱动jar包 mysql-connector-java-<span class="number">5.1</span><span class="number">.37</span>-bin.jar</span><br><span class="line">			<span class="number">2</span>. 注册驱动</span><br><span class="line">			<span class="number">3</span>. 获取数据库连接对象 Connection</span><br><span class="line">			<span class="number">4</span>. 定义sql</span><br><span class="line">				* 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;</span><br><span class="line">			<span class="number">5</span>. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql) </span><br><span class="line">			<span class="number">6</span>. 给？赋值：</span><br><span class="line">				* 方法： setXxx(参数<span class="number">1</span>,参数<span class="number">2</span>)</span><br><span class="line">					* 参数<span class="number">1</span>：？的位置编号 从<span class="number">1</span> 开始</span><br><span class="line">					* 参数<span class="number">2</span>：？的值</span><br><span class="line">			<span class="number">7</span>. 执行sql，接受返回结果，不需要传递sql语句</span><br><span class="line">			<span class="number">8</span>. 处理结果</span><br><span class="line">			<span class="number">9</span>. 释放资源</span><br><span class="line"></span><br><span class="line">		<span class="number">5</span>. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作</span><br><span class="line">			<span class="number">1</span>. 可以防止SQL注入</span><br><span class="line">			<span class="number">2</span>. 效率更高</span><br></pre></td></tr></table></figure>

<h2 id="抽取JDBC工具类-：-JDBCUtils"><a href="#抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="抽取JDBC工具类 ： JDBCUtils"></a>抽取JDBC工具类 ： JDBCUtils</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 目的：简化书写</span><br><span class="line">* 分析：</span><br><span class="line">	<span class="number">1</span>. 注册驱动也抽取</span><br><span class="line">	<span class="number">2</span>. 抽取一个方法获取连接对象</span><br><span class="line">		* 需求：不想传递参数（麻烦），还得保证工具类的通用性。</span><br><span class="line">		* 解决：配置文件</span><br><span class="line">			jdbc.properties</span><br><span class="line">				url=</span><br><span class="line">				user=</span><br><span class="line">				password=</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="number">3</span>. 抽取一个方法释放资源</span><br><span class="line"></span><br><span class="line">* 代码实现：</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//读取资源文件，获取值。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 创建Properties集合类。</span></span><br><span class="line">            Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取src路径下的文件的方式---&gt;ClassLoader 类加载器</span></span><br><span class="line">            ClassLoader classLoader = JDBCUtils<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">            URL res  = classLoader.getResource(<span class="string">"jdbc.properties"</span>);</span><br><span class="line">            String path = res.getPath();</span><br><span class="line">            System.out.println(path);<span class="comment">///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties</span></span><br><span class="line">            <span class="comment">//2. 加载文件</span></span><br><span class="line">           <span class="comment">// pro.load(new FileReader("D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties"));</span></span><br><span class="line">            pro.load(<span class="keyword">new</span> FileReader(path));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3. 获取数据，赋值</span></span><br><span class="line">            url = pro.getProperty(<span class="string">"url"</span>);</span><br><span class="line">            user = pro.getProperty(<span class="string">"user"</span>);</span><br><span class="line">            password = pro.getProperty(<span class="string">"password"</span>);</span><br><span class="line">            driver = pro.getProperty(<span class="string">"driver"</span>);</span><br><span class="line">            <span class="comment">//4. 注册驱动</span></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>​    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取连接</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 连接对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt,Connection conn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stmt.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>​    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs,Statement stmt, Connection conn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* 练习：</span><br><span class="line">	* 需求：</span><br><span class="line">		<span class="number">1</span>. 通过键盘录入用户名和密码</span><br><span class="line">		<span class="number">2</span>. 判断用户是否登录成功</span><br><span class="line">			* select * from user where username = <span class="string">""</span> and password = <span class="string">""</span>;</span><br><span class="line">			* 如果这个sql有查询结果，则成功，反之，则失败</span><br><span class="line"></span><br><span class="line">	* 步骤：</span><br><span class="line">		<span class="number">1</span>. 创建数据库表 user</span><br><span class="line">			<span class="function">CREATE TABLE <span class="title">USER</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">				id INT PRIMARY KEY AUTO_INCREMENT,</span></span></span><br><span class="line"><span class="function"><span class="params">				username VARCHAR(<span class="number">32</span>)</span>,</span></span><br><span class="line"><span class="function">				PASSWORD <span class="title">VARCHAR</span><span class="params">(<span class="number">32</span>)</span></span></span><br><span class="line"><span class="function">			</span></span><br><span class="line"><span class="function">			)</span>;</span><br><span class="line"></span><br><span class="line">			<span class="function">INSERT INTO USER <span class="title">VALUES</span><span class="params">(NULL,<span class="string">'zhangsan'</span>,<span class="string">'123'</span>)</span></span>;</span><br><span class="line">			<span class="function">INSERT INTO USER <span class="title">VALUES</span><span class="params">(NULL,<span class="string">'lisi'</span>,<span class="string">'234'</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="number">2</span>. 代码实现：</span><br><span class="line">			<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo9</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">			    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">			        <span class="comment">//1.键盘录入，接受用户名和密码</span></span><br><span class="line">			        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">			        System.out.println(<span class="string">"请输入用户名："</span>);</span><br><span class="line">			        String username = sc.nextLine();</span><br><span class="line">			        System.out.println(<span class="string">"请输入密码："</span>);</span><br><span class="line">			        String password = sc.nextLine();</span><br><span class="line">			        <span class="comment">//2.调用方法</span></span><br><span class="line">			        <span class="keyword">boolean</span> flag = <span class="keyword">new</span> JDBCDemo9().login(username, password);</span><br><span class="line">			        <span class="comment">//3.判断结果，输出不同语句</span></span><br><span class="line">			        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">			            <span class="comment">//登录成功</span></span><br><span class="line">			            System.out.println(<span class="string">"登录成功！"</span>);</span><br><span class="line">			        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			            System.out.println(<span class="string">"用户名或密码错误！"</span>);</span><br><span class="line">			        &#125;</span><br></pre></td></tr></table></figure>


<p>​                </p>
<pre><code>}</code></pre><p>​<br>​                </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String username ,String password)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(username == <span class="keyword">null</span> || password == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接数据库判断是否登录成功</span></span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    Statement stmt =  <span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//1.获取连接</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn =  JDBCUtils.getConnection();</span><br><span class="line">        <span class="comment">//2.定义sql</span></span><br><span class="line">        String sql = <span class="string">"select * from user where username = '"</span>+username+<span class="string">"' and password = '"</span>+password+<span class="string">"' "</span>;</span><br><span class="line">        <span class="comment">//3.获取执行sql的对象</span></span><br><span class="line">        stmt = conn.createStatement();</span><br><span class="line">        <span class="comment">//4.执行查询</span></span><br><span class="line">        rs = stmt.executeQuery(sql);</span><br><span class="line">        <span class="comment">//5.判断</span></span><br><span class="line">       <span class="comment">/* if(rs.next())&#123;//如果有下一行，则返回true</span></span><br><span class="line"><span class="comment">            return true;</span></span><br><span class="line"><span class="comment">        &#125;else&#123;</span></span><br><span class="line"><span class="comment">            return false;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">       <span class="keyword">return</span> rs.next();<span class="comment">//如果有下一行，则返回true</span></span><br><span class="line">			</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        JDBCUtils.close(rs,stmt,conn);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>​                </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</span><br><span class="line"><span class="number">2</span>. 操作：</span><br><span class="line">	<span class="number">1</span>. 开启事务</span><br><span class="line">	<span class="number">2</span>. 提交事务</span><br><span class="line">	<span class="number">3</span>. 回滚事务</span><br><span class="line"><span class="number">3</span>. 使用Connection对象来管理事务</span><br><span class="line">	* 开启事务：setAutoCommit(<span class="keyword">boolean</span> autoCommit) ：调用该方法设置参数为<span class="keyword">false</span>，即开启事务</span><br><span class="line">		* 在执行sql之前开启事务</span><br><span class="line">	* 提交事务：commit() </span><br><span class="line">		* 当所有sql都执行完提交事务</span><br><span class="line">	* 回滚事务：rollback() </span><br><span class="line">		* 在<span class="keyword">catch</span>中回滚事务</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. 代码：</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo10</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	        PreparedStatement pstmt1 = <span class="keyword">null</span>;</span><br><span class="line">	        PreparedStatement pstmt2 = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	        <span class="keyword">try</span> &#123;</span><br><span class="line">	            <span class="comment">//1.获取连接</span></span><br><span class="line">	            conn = JDBCUtils.getConnection();</span><br><span class="line">	            <span class="comment">//开启事务</span></span><br><span class="line">	            conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">	</span><br><span class="line">	            <span class="comment">//2.定义sql</span></span><br><span class="line">	            <span class="comment">//2.1 张三 - 500</span></span><br><span class="line">	            String sql1 = <span class="string">"update account set balance = balance - ? where id = ?"</span>;</span><br><span class="line">	            <span class="comment">//2.2 李四 + 500</span></span><br><span class="line">	            String sql2 = <span class="string">"update account set balance = balance + ? where id = ?"</span>;</span><br><span class="line">	            <span class="comment">//3.获取执行sql对象</span></span><br><span class="line">	            pstmt1 = conn.prepareStatement(sql1);</span><br><span class="line">	            pstmt2 = conn.prepareStatement(sql2);</span><br><span class="line">	            <span class="comment">//4. 设置参数</span></span><br><span class="line">	            pstmt1.setDouble(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">	            pstmt1.setInt(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	            pstmt2.setDouble(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">	            pstmt2.setInt(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">	            <span class="comment">//5.执行sql</span></span><br><span class="line">	            pstmt1.executeUpdate();</span><br><span class="line">	            <span class="comment">// 手动制造异常</span></span><br><span class="line">	            <span class="keyword">int</span> i = <span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	            pstmt2.executeUpdate();</span><br><span class="line">	            <span class="comment">//提交事务</span></span><br><span class="line">	            conn.commit();</span><br><span class="line">	        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	            <span class="comment">//事务回滚</span></span><br><span class="line">	            <span class="keyword">try</span> &#123;</span><br><span class="line">	                <span class="keyword">if</span>(conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">	                    conn.rollback();</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">	                e1.printStackTrace();</span><br><span class="line">	            &#125;</span><br><span class="line">	            e.printStackTrace();</span><br><span class="line">	        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">	            JDBCUtils.close(pstmt1,conn);</span><br><span class="line">	            JDBCUtils.close(pstmt2,<span class="keyword">null</span>);</span><br><span class="line">	        &#125;</span><br></pre></td></tr></table></figure>


<p>​        </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>​            </p>
]]></content>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>day03-List,Set</title>
    <url>/2020/04/04/day03-List-Set/</url>
    <content><![CDATA[<h1 id="day03-【List、Set、数据结构、Collections】"><a href="#day03-【List、Set、数据结构、Collections】" class="headerlink" title="day03 【List、Set、数据结构、Collections】"></a>day03 【List、Set、数据结构、Collections】</h1><a id="more"></a>

<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>数据结构</li>
<li>List集合</li>
<li>Set集合</li>
<li>Collections</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够说出List集合特点</li>
<li><input disabled="" type="checkbox"> 能够说出常见的数据结构</li>
<li><input disabled="" type="checkbox"> 能够说出数组结构特点</li>
<li><input disabled="" type="checkbox"> 能够说出栈结构特点</li>
<li><input disabled="" type="checkbox"> 能够说出队列结构特点</li>
<li><input disabled="" type="checkbox"> 能够说出单向链表结构特点</li>
<li><input disabled="" type="checkbox"> 能够说出Set集合的特点</li>
<li><input disabled="" type="checkbox"> 能够说出哈希表的特点</li>
<li><input disabled="" type="checkbox"> 使用HashSet集合存储自定义元素</li>
<li><input disabled="" type="checkbox"> 能够说出可变参数的格式</li>
<li><input disabled="" type="checkbox"> 能够使用集合工具类</li>
<li><input disabled="" type="checkbox"> 能够使用Comparator比较器进行排序</li>
</ul>
<h1 id="第一章-数据结构"><a href="#第一章-数据结构" class="headerlink" title="第一章 数据结构"></a>第一章 数据结构</h1><h2 id="2-1-数据结构有什么用？"><a href="#2-1-数据结构有什么用？" class="headerlink" title="2.1 数据结构有什么用？"></a>2.1 数据结构有什么用？</h2><p>当你用着java里面的容器类很爽的时候，你有没有想过，怎么ArrayList就像一个无限扩充的数组，也好像链表之类的。好用吗？好用，这就是数据结构的用处，只不过你在不知不觉中使用了。</p>
<p>现实世界的存储，我们使用的工具和建模。每种数据结构有自己的优点和缺点，想想如果Google的数据用的是数组的存储，我们还能方便地查询到所需要的数据吗？而算法，在这么多的数据中如何做到最快的插入，查找，删除，也是在追求更快。</p>
<p>我们java是面向对象的语言，就好似自动档轿车，C语言好似手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从 A点 开到 B点，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。当然了，数据结构内容比较多，细细的学起来也是相对费功夫的，不可能达到一蹴而就。我们将常见的数据结构：堆栈、队列、数组、链表和红黑树 这几种给大家介绍一下，作为数据结构的入门，了解一下它们的特点即可。</p>
<h2 id="2-2-常见的数据结构"><a href="#2-2-常见的数据结构" class="headerlink" title="2.2 常见的数据结构"></a>2.2 常见的数据结构</h2><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下：</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul>
<li><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li>
</ul>
<p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p>
<ul>
<li><p>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</p>
</li>
<li><p>栈的入口、出口的都是栈的顶端位置。</p>
</li>
</ul>
<p>这里两个名词需要注意：</p>
<ul>
<li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li>
<li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li>
</ul>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul>
<li><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li>
</ul>
<p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</li>
<li>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</li>
</ul>
<p>简单的说,采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li><p>查找元素快：通过索引，可以快速访问指定位置的元素</p>
</li>
<li><p>增删元素慢</p>
<ul>
<li><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。</li>
<li><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图</li>
</ul>
</li>
</ul>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul>
<li><p><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是<strong>单向链表</strong>。</p>
<img src="/2020/04/04/day03-List-Set/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9.png" class="" title="单链结构">

</li>
</ul>
<p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li><p>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</p>
<img src="/2020/04/04/day03-List-Set/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png" class="" title="单链结构">
</li>
<li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p>
</li>
<li><p>增删元素快：</p>
<ul>
<li><p>增加元素：只需要修改连接下个元素的地址即可。</p>
<img src="/2020/04/04/day03-List-Set/%E5%A2%9E%E5%8A%A0%E7%BB%93%E7%82%B9.png" class="" title="增加结点">
</li>
<li><p>删除元素：只需要修改连接下个元素的地址即可。</p>
<img src="/2020/04/04/day03-List-Set/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9.bmp" class="" title="删除结点">



</li>
</ul>
</li>
</ul>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ul>
<li><strong>二叉树</strong>：<strong>binary tree</strong> ,是每个结点不超过2的有序<strong>树（tree）</strong> 。</li>
</ul>
<p>简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。</p>
<p>二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。</p>
<p>如图：</p>
<img src="/2020/04/04/day03-List-Set/04_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%BA%A2%E9%BB%91%E6%A0%91.bmp" class="" title="红黑树">

<p>我们要说的是二叉树的一种比较有意思的叫做<strong>红黑树</strong>，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。</p>
<p>红黑树的约束:</p>
<ol>
<li>节点可以是红色的或者黑色的</li>
</ol>
<ol start="2">
<li>根节点是黑色的</li>
</ol>
<ol start="3">
<li>叶子节点(特指空节点)是黑色的</li>
<li>每个红色节点的子节点都是黑色的</li>
<li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</li>
</ol>
<p>红黑树的特点:</p>
<p>​    速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍</p>
<h1 id="第二章-List集合"><a href="#第二章-List集合" class="headerlink" title="第二章 List集合"></a>第二章 List集合</h1><p>我们掌握了Collection接口的使用后，再来看看Collection接口中的子类，他们都具备那些特性呢？</p>
<p>接下来，我们一起学习Collection中的常用几个子类（<code>java.util.List</code>集合、<code>java.util.Set</code>集合）。</p>
<h2 id="1-1-List接口介绍"><a href="#1-1-List接口介绍" class="headerlink" title="1.1 List接口介绍"></a>1.1 List接口介绍</h2><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p>
<p>看完API，我们总结一下：</p>
<p>List接口特点：</p>
<ol>
<li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li>
<li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li>
<li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li>
</ol>
<blockquote>
<p>tips:我们在基础班的时候已经学习过List接口的子类java.util.ArrayList类，该类中的方法都是来自List中定义。</p>
</blockquote>
<h2 id="1-2-List接口中常用方法"><a href="#1-2-List接口中常用方法" class="headerlink" title="1.2 List接口中常用方法"></a>1.2 List接口中常用方法</h2><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p>
<ul>
<li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li>
<li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li>
<li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li>
<li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li>
</ul>
<p>List集合特有的方法都是跟索引相关，我们在基础班都学习过，那么我们再来复习一遍吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建List集合对象</span></span><br><span class="line">    	List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 往 尾部添加 指定元素</span></span><br><span class="line">    	list.add(<span class="string">"图图"</span>);</span><br><span class="line">    	list.add(<span class="string">"小美"</span>);</span><br><span class="line">    	list.add(<span class="string">"不高兴"</span>);</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	<span class="comment">// add(int index,String s) 往指定位置添加</span></span><br><span class="line">    	list.add(<span class="number">1</span>,<span class="string">"没头脑"</span>);</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	<span class="comment">// String remove(int index) 删除指定位置元素  返回被删除元素</span></span><br><span class="line">    	<span class="comment">// 删除索引位置为2的元素 </span></span><br><span class="line">    	System.out.println(<span class="string">"删除索引位置为2的元素"</span>);</span><br><span class="line">    	System.out.println(list.remove(<span class="number">2</span>));</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// String set(int index,String s)</span></span><br><span class="line">    	<span class="comment">// 在指定位置 进行 元素替代（改） </span></span><br><span class="line">    	<span class="comment">// 修改指定位置元素</span></span><br><span class="line">    	list.set(<span class="number">0</span>, <span class="string">"三毛"</span>);</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// String get(int index)  获取指定位置元素</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 跟size() 方法一起用  来 遍历的 </span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">    		System.out.println(list.get(i));</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//还可以使用增强for</span></span><br><span class="line">    	<span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">			System.out.println(string);</span><br><span class="line">		&#125;  	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-List的子类"><a href="#第三章-List的子类" class="headerlink" title="第三章 List的子类"></a>第三章 List的子类</h1><h2 id="3-1-ArrayList集合"><a href="#3-1-ArrayList集合" class="headerlink" title="3.1 ArrayList集合"></a>3.1 ArrayList集合</h2><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p>
<p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。</p>
<h2 id="3-2-LinkedList集合"><a href="#3-2-LinkedList集合" class="headerlink" title="3.2 LinkedList集合"></a>3.2 LinkedList集合</h2><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p>
<blockquote>
<p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p>
</blockquote>
<img src="/2020/04/04/day03-List-Set/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" class="" title="双向链表">

<p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p>
<ul>
<li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li>
<li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li>
<li><code>public E getFirst()</code>:返回此列表的第一个元素。</li>
<li><code>public E getLast()</code>:返回此列表的最后一个元素。</li>
<li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li>
<li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li>
<li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li>
<li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li>
<li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li>
</ul>
<p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可）</p>
<p>方法演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; link = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        link.addFirst(<span class="string">"abc1"</span>);</span><br><span class="line">        link.addFirst(<span class="string">"abc2"</span>);</span><br><span class="line">        link.addFirst(<span class="string">"abc3"</span>);</span><br><span class="line">        System.out.println(link);</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        System.out.println(link.getFirst());</span><br><span class="line">        System.out.println(link.getLast());</span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        System.out.println(link.removeFirst());</span><br><span class="line">        System.out.println(link.removeLast());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!link.isEmpty()) &#123; <span class="comment">//判断集合是否为空</span></span><br><span class="line">            System.out.println(link.pop()); <span class="comment">//弹出集合中的栈顶元素</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(link);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-Set接口"><a href="#第四章-Set接口" class="headerlink" title="第四章 Set接口"></a>第四章 Set接口</h1><p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p>
<p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>这两个集合。</p>
<blockquote>
<p>tips:Set集合取出元素的方式可以采用：迭代器、增强for。</p>
</blockquote>
<h2 id="3-1-HashSet集合介绍"><a href="#3-1-HashSet集合介绍" class="headerlink" title="3.1 HashSet集合介绍"></a>3.1 HashSet集合介绍</h2><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，由于我们暂时还未学习，先做了解。</p>
<p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p>
<p>我们先来使用一下Set集合存储，看下现象，再进行原理的讲解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建 Set集合</span></span><br><span class="line">        HashSet&lt;String&gt;  set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        set.add(<span class="keyword">new</span> String(<span class="string">"cba"</span>));</span><br><span class="line">        set.add(<span class="string">"abc"</span>);</span><br><span class="line">        set.add(<span class="string">"bac"</span>); </span><br><span class="line">        set.add(<span class="string">"cba"</span>);  </span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (String name : set) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下，说明集合中不能存储重复元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cba</span><br><span class="line">abc</span><br><span class="line">bac</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:根据结果我们发现字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。</p>
</blockquote>
<h2 id="2-2-HashSet集合存储数据的结构（哈希表）"><a href="#2-2-HashSet集合存储数据的结构（哈希表）" class="headerlink" title="2.2  HashSet集合存储数据的结构（哈希表）"></a>2.2  HashSet集合存储数据的结构（哈希表）</h2><p>什么是哈希表呢？</p>
<p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p>
<p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。</p>
<img src="/2020/04/04/day03-List-Set/%E5%93%88%E5%B8%8C%E8%A1%A8.png" class="" title="哈希表">

<p>看到这张图就有人要问了，这个是怎么存储的呢？</p>
<p>为了方便大家的理解我们结合一个存储流程图来说明一下：</p>
<img src="/2020/04/04/day03-List-Set/%E5%93%88%E5%B8%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="" title="哈希表流程">

<p>总而言之，<strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p>
<h2 id="2-3-HashSet存储自定义类型元素"><a href="#2-3-HashSet存储自定义类型元素" class="headerlink" title="2.3  HashSet存储自定义类型元素"></a>2.3  HashSet存储自定义类型元素</h2><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一</p>
<p>创建自定义Student类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">               Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合对象   该集合中存储 Student类型对象</span></span><br><span class="line">        HashSet&lt;Student&gt; stuSet = <span class="keyword">new</span> HashSet&lt;Student&gt;();</span><br><span class="line">        <span class="comment">//存储 </span></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">"于谦"</span>, <span class="number">43</span>);</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">"郭德纲"</span>, <span class="number">44</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">"于谦"</span>, <span class="number">43</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">"郭麒麟"</span>, <span class="number">23</span>));</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Student stu2 : stuSet) &#123;</span><br><span class="line">            System.out.println(stu2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">Student [name=郭德纲, age=<span class="number">44</span>]</span><br><span class="line">Student [name=于谦, age=<span class="number">43</span>]</span><br><span class="line">Student [name=郭麒麟, age=<span class="number">23</span>]</span><br></pre></td></tr></table></figure>

<h2 id="2-3-LinkedHashSet"><a href="#2-3-LinkedHashSet" class="headerlink" title="2.3 LinkedHashSet"></a>2.3 LinkedHashSet</h2><p>我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p>
<p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p>
<p>演示代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSetDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Set&lt;String&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</span><br><span class="line">		set.add(<span class="string">"bbb"</span>);</span><br><span class="line">		set.add(<span class="string">"aaa"</span>);</span><br><span class="line">		set.add(<span class="string">"abc"</span>);</span><br><span class="line">		set.add(<span class="string">"bbc"</span>);</span><br><span class="line">        Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			System.out.println(it.next());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">  bbb</span><br><span class="line">  aaa</span><br><span class="line">  abc</span><br><span class="line">  bbc</span><br></pre></td></tr></table></figure>

<h2 id="1-9-可变参数"><a href="#1-9-可变参数" class="headerlink" title="1.9  可变参数"></a>1.9  可变参数</h2><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>其实这个书写完全等价与</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</p>
<p><strong>JDK1.5</strong>以后。出现了简化操作。<strong>…</strong> 用在参数上，称之为可变参数。</p>
<p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p>
<p>代码演示：    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">62</span>, <span class="number">431</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> sum = getSum(arr);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="comment">//  6  7  2 12 2121</span></span><br><span class="line">        <span class="comment">// 求 这几个元素和 6  7  2 12 2121</span></span><br><span class="line">        <span class="keyword">int</span> sum2 = getSum(<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">2121</span>);</span><br><span class="line">        System.out.println(sum2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 完成数组  所有元素的求和 原始写法</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">      public static int getSum(int[] arr)&#123;</span></span><br><span class="line"><span class="comment">        int sum = 0;</span></span><br><span class="line"><span class="comment">        for(int a : arr)&#123;</span></span><br><span class="line"><span class="comment">            sum += a;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        return sum;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//可变参数写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>... arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性</p>
<p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p>
</blockquote>
<h1 id="第五章-Collections"><a href="#第五章-Collections" class="headerlink" title="第五章  Collections"></a>第五章  Collections</h1><h2 id="2-1-常用功能"><a href="#2-1-常用功能" class="headerlink" title="2.1 常用功能"></a>2.1 常用功能</h2><ul>
<li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</li>
</ul>
<ul>
<li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)</code>:往集合中添加一些元素。</li>
<li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li>
</ul>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//原来写法</span></span><br><span class="line">        <span class="comment">//list.add(12);</span></span><br><span class="line">        <span class="comment">//list.add(14);</span></span><br><span class="line">        <span class="comment">//list.add(15);</span></span><br><span class="line">        <span class="comment">//list.add(1000);</span></span><br><span class="line">        <span class="comment">//采用工具类 完成 往集合中添加元素  </span></span><br><span class="line">        Collections.addAll(list, <span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>，<span class="number">2</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//排序方法 </span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">[<span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">222</span>]</span><br></pre></td></tr></table></figure>

<p>代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？</p>
<p>我们发现还有个方法没有讲，<code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。</p>
<h2 id="2-2-Comparator比较器"><a href="#2-2-Comparator比较器" class="headerlink" title="2.2 Comparator比较器"></a>2.2 Comparator比较器</h2><p>我们还是先研究这个方法</p>
<p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p>
<p>不过这次存储的是字符串类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt;  list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"cba"</span>);</span><br><span class="line">        list.add(<span class="string">"aba"</span>);</span><br><span class="line">        list.add(<span class="string">"sba"</span>);</span><br><span class="line">        list.add(<span class="string">"nba"</span>);</span><br><span class="line">        <span class="comment">//排序方法</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[aba, cba, nba, sba]</span><br></pre></td></tr></table></figure>

<p>我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？</p>
<p>说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用<code>java.lang.Comparable</code>接口去实现，一种是灵活的当我需要做排序的时候在去选择的<code>java.util.Comparator</code>接口完成。</p>
<p>那么我们采用的<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用</p>
<p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</p>
<ul>
<li><p><code>public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</p>
<blockquote>
<p>两个对象比较的结果有三种：大于，等于，小于。</p>
<p>如果要按照升序排序，<br>则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）<br>如果要按照降序排序<br>则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p>
</blockquote>
</li>
</ul>
<p>操作如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"cba"</span>);</span><br><span class="line">        list.add(<span class="string">"aba"</span>);</span><br><span class="line">        list.add(<span class="string">"sba"</span>);</span><br><span class="line">        list.add(<span class="string">"nba"</span>);</span><br><span class="line">        <span class="comment">//排序方法  按照第一个单词的降序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.charAt(<span class="number">0</span>) - o1.charAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[sba, nba, cba, aba]</span><br></pre></td></tr></table></figure>

<h2 id="2-3-简述Comparable和Comparator两个接口的区别。"><a href="#2-3-简述Comparable和Comparator两个接口的区别。" class="headerlink" title="2.3 简述Comparable和Comparator两个接口的区别。"></a>2.3 简述Comparable和Comparator两个接口的区别。</h2><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p>
<p><strong>Comparator</strong>强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p>
<h2 id="2-4-练习"><a href="#2-4-练习" class="headerlink" title="2.4  练习"></a>2.4  练习</h2><p>创建一个学生类，存储到ArrayList集合中完成指定排序操作。</p>
<p>Student 初始类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">               <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">               <span class="string">", age="</span> + age +</span><br><span class="line">               <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建四个学生对象 存储到集合中</span></span><br><span class="line">        ArrayList&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"rose"</span>,<span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"jack"</span>,<span class="number">16</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"abc"</span>,<span class="number">16</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"ace"</span>,<span class="number">17</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"mark"</span>,<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          让学生 按照年龄排序 升序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        Collections.sort(list);//要求 该list中元素类型  必须实现比较器Comparable接口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现，当我们调用Collections.sort()方法的时候 程序报错了。</p>
<p>原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。</p>
<p>于是我们就完成了Student类的一个实现，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age-o.age;<span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次测试，代码就OK 了效果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student&#123;name=<span class="string">'jack'</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">'abc'</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">'mark'</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">'ace'</span>, age=<span class="number">17</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">'rose'</span>, age=<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-扩展"><a href="#2-5-扩展" class="headerlink" title="2.5 扩展"></a>2.5 扩展</h2><p>如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor<T> c)方式，自己定义规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.getAge()-o1.getAge();<span class="comment">//以学生的年龄降序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student&#123;name&#x3D;&#39;rose&#39;, age&#x3D;18&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;ace&#39;, age&#x3D;17&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;jack&#39;, age&#x3D;16&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;abc&#39;, age&#x3D;16&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;mark&#39;, age&#x3D;16&#125;</span><br></pre></td></tr></table></figure>



<p>如果想要规则更多一些，可以参考下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 年龄降序</span></span><br><span class="line">                <span class="keyword">int</span> result = o2.getAge()-o1.getAge();<span class="comment">//年龄降序</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(result==<span class="number">0</span>)&#123;<span class="comment">//第一个规则判断完了 下一个规则 姓名的首字母 升序</span></span><br><span class="line">                    result = o1.getName().charAt(<span class="number">0</span>)-o2.getName().charAt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student&#123;name&#x3D;&#39;rose&#39;, age&#x3D;18&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;ace&#39;, age&#x3D;17&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;abc&#39;, age&#x3D;16&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;jack&#39;, age&#x3D;16&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;mark&#39;, age&#x3D;16&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>day02[Collection.泛型]</title>
    <url>/2020/04/04/day02-Collection-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="day02【Collection、泛型】"><a href="#day02【Collection、泛型】" class="headerlink" title="day02【Collection、泛型】"></a>day02【Collection、泛型】</h1><a id="more"></a>

<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>Collection集合</li>
<li>迭代器</li>
<li>增强for</li>
<li>泛型</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够说出集合与数组的区别</li>
<li><input disabled="" type="checkbox"> 说出Collection集合的常用功能</li>
<li><input disabled="" type="checkbox"> 能够使用迭代器对集合进行取元素</li>
<li><input disabled="" type="checkbox"> 能够说出集合的使用细节</li>
<li><input disabled="" type="checkbox"> 能够使用集合存储自定义类型</li>
<li><input disabled="" type="checkbox"> 能够使用foreach循环遍历集合</li>
<li><input disabled="" type="checkbox"> 能够使用泛型定义集合对象</li>
<li><input disabled="" type="checkbox"> 能够理解泛型上下限</li>
<li><input disabled="" type="checkbox"> 能够阐述泛型通配符的作用</li>
</ul>
<h1 id="第一章-Collection集合"><a href="#第一章-Collection集合" class="headerlink" title="第一章 Collection集合"></a>第一章 Collection集合</h1><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1 集合概述"></a>1.1 集合概述</h2><p>在前面基础班我们已经学习过并使用过集合ArrayList<E> ,那么集合到底是什么呢?</p>
<ul>
<li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li>
</ul>
<p>集合和数组既然都是容器，它们有啥区别呢？</p>
<ul>
<li>数组的长度是固定的。集合的长度是可变的。</li>
<li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li>
</ul>
<h2 id="1-2-集合框架"><a href="#1-2-集合框架" class="headerlink" title="1.2  集合框架"></a>1.2  集合框架</h2><p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p>
<p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>，今天我们主要学习<code>Collection</code>集合，在day04时讲解<code>Map</code>集合。</p>
<ul>
<li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素无序，而且不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li>
</ul>
<p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。</p>
<img src="/2020/04/04/day02-Collection-%E6%B3%9B%E5%9E%8B/01.jpg" class="" title="This is an 01 image">

<p>其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。</p>
<p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p>
<h2 id="1-3-Collection-常用功能"><a href="#1-3-Collection-常用功能" class="headerlink" title="1.3 Collection 常用功能"></a>1.3 Collection 常用功能</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p>
<ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code> :清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
</ul>
<p>方法演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建集合对象 </span></span><br><span class="line">    	<span class="comment">// 使用多态形式</span></span><br><span class="line">    	Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	<span class="comment">// 使用方法</span></span><br><span class="line">    	<span class="comment">// 添加功能  boolean  add(String s)</span></span><br><span class="line">    	coll.add(<span class="string">"小李广"</span>);</span><br><span class="line">    	coll.add(<span class="string">"扫地僧"</span>);</span><br><span class="line">    	coll.add(<span class="string">"石破天"</span>);</span><br><span class="line">    	System.out.println(coll);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// boolean contains(E e) 判断o是否在集合中存在</span></span><br><span class="line">    	System.out.println(<span class="string">"判断  扫地僧 是否在集合中"</span>+coll.contains(<span class="string">"扫地僧"</span>));</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//boolean remove(E e) 删除在集合中的o元素</span></span><br><span class="line">    	System.out.println(<span class="string">"删除石破天："</span>+coll.remove(<span class="string">"石破天"</span>));</span><br><span class="line">    	System.out.println(<span class="string">"操作之后集合中元素:"</span>+coll);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// size() 集合中有几个元素</span></span><br><span class="line">		System.out.println(<span class="string">"集合中有"</span>+coll.size()+<span class="string">"个元素"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Object[] toArray()转换成一个Object数组</span></span><br><span class="line">    	Object[] objects = coll.toArray();</span><br><span class="line">    	<span class="comment">// 遍历数组</span></span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">			System.out.println(objects[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// void  clear() 清空集合</span></span><br><span class="line">		coll.clear();</span><br><span class="line">		System.out.println(<span class="string">"集合中内容为："</span>+coll);</span><br><span class="line">		<span class="comment">// boolean  isEmpty()  判断是否为空</span></span><br><span class="line">		System.out.println(coll.isEmpty());  	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p>
</blockquote>
<h2 id="第二章-Iterator迭代器"><a href="#第二章-Iterator迭代器" class="headerlink" title="第二章 Iterator迭代器"></a>第二章 Iterator迭代器</h2><h2 id="2-1-Iterator接口"><a href="#2-1-Iterator接口" class="headerlink" title="2.1 Iterator接口"></a>2.1 Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p>
<p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p>
<ul>
<li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li>
</ul>
<p>下面介绍一下迭代的概念：</p>
<ul>
<li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li>
</ul>
<p>Iterator接口的常用方法如下：</p>
<ul>
<li><code>public E next()</code>:返回迭代的下一个元素。</li>
<li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
</ul>
<p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">"串串星人"</span>);</span><br><span class="line">        coll.add(<span class="string">"吐槽星人"</span>);</span><br><span class="line">        coll.add(<span class="string">"汪星人"</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">//  泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            String s = it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p>
</blockquote>
<h2 id="2-2-迭代器的实现原理"><a href="#2-2-迭代器的实现原理" class="headerlink" title="2.2 迭代器的实现原理"></a>2.2 迭代器的实现原理</h2><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p>
<p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p>
<img src="/2020/04/04/day02-Collection-%E6%B3%9B%E5%9E%8B/02_%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86(1).bmp" class="" title="迭代器原理">

<p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p>
<h2 id="2-3-增强for"><a href="#2-3-增强for" class="headerlink" title="2.3 增强for"></a>2.3 增强for</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">  	<span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p>
<h4 id="练习1：遍历数组"><a href="#练习1：遍历数组" class="headerlink" title="练习1：遍历数组"></a>练习1：遍历数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBForDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">87</span>&#125;;</span><br><span class="line">       	<span class="comment">//使用增强for遍历数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;<span class="comment">//a代表数组中的每个元素</span></span><br><span class="line">			System.out.println(a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习2-遍历集合"><a href="#练习2-遍历集合" class="headerlink" title="练习2:遍历集合"></a>练习2:遍历集合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">    	Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	coll.add(<span class="string">"小河神"</span>);</span><br><span class="line">    	coll.add(<span class="string">"老河神"</span>);</span><br><span class="line">    	coll.add(<span class="string">"神婆"</span>);</span><br><span class="line">    	<span class="comment">//使用增强for遍历</span></span><br><span class="line">    	<span class="keyword">for</span>(String s :coll)&#123;<span class="comment">//接收变量s代表 代表被遍历到的集合元素</span></span><br><span class="line">    		System.out.println(s);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p>
</blockquote>
<h1 id="第三章-泛型"><a href="#第三章-泛型" class="headerlink" title="第三章 泛型"></a>第三章 泛型</h1><h2 id="3-1-泛型概述"><a href="#3-1-泛型概述" class="headerlink" title="3.1  泛型概述"></a>3.1  泛型概述</h2><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p>
<p>大家观察下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		coll.add(<span class="string">"abc"</span>);</span><br><span class="line">		coll.add(<span class="string">"itcast"</span>);</span><br><span class="line">		coll.add(<span class="number">5</span>);<span class="comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span></span><br><span class="line">		Iterator it = coll.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			<span class="comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span></span><br><span class="line">			String str = (String) it.next();</span><br><span class="line">			System.out.println(str.length());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p>
<ul>
<li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li>
</ul>
<blockquote>
<p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p>
</blockquote>
<h2 id="3-2-使用泛型的好处"><a href="#3-2-使用泛型的好处" class="headerlink" title="3.2  使用泛型的好处"></a>3.2  使用泛型的好处</h2><p>上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？</p>
<ul>
<li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li>
<li>避免了类型强转的麻烦。</li>
</ul>
<p>通过我们如下代码体验一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"abc"</span>);</span><br><span class="line">        list.add(<span class="string">"itcast"</span>);</span><br><span class="line">        <span class="comment">// list.add(5);//当集合明确类型后，存放类型不一致就会编译报错</span></span><br><span class="line">        <span class="comment">// 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String str = it.next();</span><br><span class="line">            <span class="comment">//当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span></span><br><span class="line">            System.out.println(str.length());</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p>
</blockquote>
<h2 id="3-3-泛型的定义与使用"><a href="#3-3-泛型的定义与使用" class="headerlink" title="3.3  泛型的定义与使用"></a>3.3  泛型的定义与使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p>
<p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p>
<h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>例如，API中的ArrayList集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123; &#125;</span><br><span class="line">   	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用泛型： 即什么时候确定泛型。</p>
<p><strong>在创建对象的时候确定泛型</strong></p>
<p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p>
<p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt;</span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p>
<p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">Integer</span>&gt; </span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Integer e)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例自定义泛型类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericClass</span>&lt;<span class="title">MVP</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span></span><br><span class="line">	<span class="keyword">private</span> MVP mvp;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMVP</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mvp = mvp;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MVP <span class="title">getMVP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassDemo</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		 </span><br><span class="line">         <span class="comment">// 创建一个泛型为String的类</span></span><br><span class="line">         MyGenericClass&lt;String&gt; my = <span class="keyword">new</span> MyGenericClass&lt;String&gt;();    	</span><br><span class="line">         <span class="comment">// 调用setMVP</span></span><br><span class="line">         my.setMVP(<span class="string">"大胡子登登"</span>);</span><br><span class="line">         <span class="comment">// 调用getMVP</span></span><br><span class="line">         String mvp = my.getMVP();</span><br><span class="line">         System.out.println(mvp);</span><br><span class="line">         <span class="comment">//创建一个泛型为Integer的类</span></span><br><span class="line">         MyGenericClass&lt;Integer&gt; my2 = <span class="keyword">new</span> MyGenericClass&lt;Integer&gt;(); </span><br><span class="line">         my2.setMVP(<span class="number">123</span>);   	  </span><br><span class="line">         Integer mvp2 = my2.getMVP();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericMethod</span> </span>&#123;	  </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    	System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function">MVP <span class="title">show2</span><span class="params">(MVP mvp)</span> </span>&#123;	</span><br><span class="line">    	<span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        MyGenericMethod mm = <span class="keyword">new</span> MyGenericMethod();</span><br><span class="line">        <span class="comment">// 演示看方法提示</span></span><br><span class="line">        mm.show(<span class="string">"aaa"</span>);</span><br><span class="line">        mm.show(<span class="number">123</span>);</span><br><span class="line">        mm.show(<span class="number">12.45</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title">getE</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：</p>
<p><strong>1、定义类时确定泛型的类型</strong></p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp1</span> <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，泛型E的值就是String类型。</p>
<p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p>
<p> 例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       	 <span class="comment">// 省略...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确定泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyImp2&lt;String&gt;  my = <span class="keyword">new</span> MyImp2&lt;String&gt;();  </span><br><span class="line">        my.add(<span class="string">"aa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-泛型通配符"><a href="#3-4-泛型通配符" class="headerlink" title="3.4  泛型通配符"></a>3.4  泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p>
<h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p>
<p>此时只能接受数据,不能往该集合中存储数据。</p>
<p>举个例子大家理解使用即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Intger&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:泛型不存在继承关系 Collection<Object> list = new ArrayList<String>();这种是错误的。</p>
</blockquote>
<h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p>
<p><strong>泛型的上限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li>
</ul>
<p><strong>泛型的下限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li>
</ul>
<p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement(list1);</span><br><span class="line">    getElement(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement(list3);</span><br><span class="line">    getElement(list4);<span class="comment">//报错</span></span><br><span class="line">  </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement2</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-集合综合案例"><a href="#第四章-集合综合案例" class="headerlink" title="第四章 集合综合案例"></a>第四章 集合综合案例</h1><h2 id="4-1-案例介绍"><a href="#4-1-案例介绍" class="headerlink" title="4.1 案例介绍"></a>4.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。<br>具体规则：</p>
<p>使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</p>
<h2 id="4-2-案例分析"><a href="#4-2-案例分析" class="headerlink" title="4.2 案例分析"></a>4.2 案例分析</h2><ul>
<li><p>准备牌：</p>
<p>牌可以设计为一个ArrayList<String>,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collections类的shuffle方法进行随机排序。</p>
</li>
<li><p>发牌</p>
<p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p>
</li>
</ul>
<ul>
<li><p>看牌</p>
<p>直接打印每个集合。</p>
<img src="/2020/04/04/day02-Collection-%E6%B3%9B%E5%9E%8B/04_%E6%96%97%E5%9C%B0%E4%B8%BB%E6%A1%88%E4%BE%8B%E7%9A%84%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90.bmp" class="" title="斗地主案例分析">

</li>
</ul>
<h2 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1: 准备牌操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//1.1 创建牌盒 将来存储牌面的 </span></span><br><span class="line">        ArrayList&lt;String&gt; pokerBox = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//1.2 创建花色集合</span></span><br><span class="line">        ArrayList&lt;String&gt; colors = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.3 创建数字集合</span></span><br><span class="line">        ArrayList&lt;String&gt; numbers = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.4 分别给花色 以及 数字集合添加元素</span></span><br><span class="line">        colors.add(<span class="string">"♥"</span>);</span><br><span class="line">        colors.add(<span class="string">"♦"</span>);</span><br><span class="line">        colors.add(<span class="string">"♠"</span>);</span><br><span class="line">        colors.add(<span class="string">"♣"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            numbers.add(i+<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        numbers.add(<span class="string">"J"</span>);</span><br><span class="line">        numbers.add(<span class="string">"Q"</span>);</span><br><span class="line">        numbers.add(<span class="string">"K"</span>);</span><br><span class="line">        numbers.add(<span class="string">"A"</span>);</span><br><span class="line">        <span class="comment">//1.5 创造牌  拼接牌操作</span></span><br><span class="line">        <span class="comment">// 拿出每一个花色  然后跟每一个数字 进行结合  存储到牌盒中</span></span><br><span class="line">        <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">            <span class="comment">//color每一个花色 </span></span><br><span class="line">            <span class="comment">//遍历数字集合</span></span><br><span class="line">            <span class="keyword">for</span>(String number : numbers)&#123;</span><br><span class="line">                <span class="comment">//结合</span></span><br><span class="line">                String card = color+number;</span><br><span class="line">                <span class="comment">//存储到牌盒中</span></span><br><span class="line">                pokerBox.add(card);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.6大王小王</span></span><br><span class="line">        pokerBox.add(<span class="string">"小☺"</span>);</span><br><span class="line">        pokerBox.add(<span class="string">"大☠"</span>);	  </span><br><span class="line">        <span class="comment">// System.out.println(pokerBox);</span></span><br><span class="line">        <span class="comment">//洗牌 是不是就是将  牌盒中 牌的索引打乱 </span></span><br><span class="line">        <span class="comment">// Collections类  工具类  都是 静态方法</span></span><br><span class="line">        <span class="comment">// shuffer方法   </span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * static void shuffle(List&lt;?&gt; list) </span></span><br><span class="line"><span class="comment">         *     使用默认随机源对指定列表进行置换。 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//2:洗牌</span></span><br><span class="line">        Collections.shuffle(pokerBox);</span><br><span class="line">        <span class="comment">//3 发牌</span></span><br><span class="line">        <span class="comment">//3.1 创建 三个 玩家集合  创建一个底牌集合</span></span><br><span class="line">        ArrayList&lt;String&gt; player1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player3 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; dipai = <span class="keyword">new</span> ArrayList&lt;String&gt;();	  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历 牌盒  必须知道索引   </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;pokerBox.size();i++)&#123;</span><br><span class="line">            <span class="comment">//获取 牌面</span></span><br><span class="line">            String card = pokerBox.get(i);</span><br><span class="line">            <span class="comment">//留出三张底牌 存到 底牌集合中</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">51</span>)&#123;<span class="comment">//存到底牌集合中</span></span><br><span class="line">                dipai.add(card);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//玩家1   %3  ==0</span></span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                  	player1.add(card);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">1</span>)&#123;<span class="comment">//玩家2</span></span><br><span class="line">                  	player2.add(card);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//玩家3</span></span><br><span class="line">                  	player3.add(card);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看看</span></span><br><span class="line">        System.out.println(<span class="string">"令狐冲："</span>+player1);</span><br><span class="line">        System.out.println(<span class="string">"田伯光："</span>+player2);</span><br><span class="line">        System.out.println(<span class="string">"绿竹翁："</span>+player3);</span><br><span class="line">        System.out.println(<span class="string">"底牌："</span>+dipai);  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>javaseObject类</title>
    <url>/2020/04/03/day01%E3%80%90Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%91-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="day01【Object类、常用API】"><a href="#day01【Object类、常用API】" class="headerlink" title="day01【Object类、常用API】"></a>day01【Object类、常用API】</h1><a id="more"></a>
<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>Object类</li>
<li>Date类</li>
<li>DateFormat类</li>
<li>Calendar类</li>
<li>System类</li>
<li>StringBuilder类</li>
<li>包装类</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><p>-[ ] 能够说出Object类的特点<br>-[ ] 能够重写Object类的toString方法<br>-[ ] 能够重写Object类的equals方法<br>-[ ] 能够使用日期类输出当前日期<br>-[ ] 能够使用将日期格式化为字符串的方法<br>-[ ] 能够使用将字符串转换成日期的方法<br>-[ ] 能够使用System类的数组复制方法<br>-[ ] 能够使用System类获取当前毫秒时刻值<br>-[ ] 能够说出使用StringBuilder类可以解决的问题<br>-[ ] 能够使用StringBuilder进行字符串拼接操作<br>-[ ] 能够说出8种基本类型对应的包装类名称<br>-[ ] 能够说出自动装箱、自动拆箱的概念<br>-[ ] 能够将字符串转换为对应的基本类型<br>-[ ] 能够将基本类型转换为对应的字符串</p>
<h1 id="第一章-Object类"><a href="#第一章-Object类" class="headerlink" title="第一章 Object类"></a>第一章 Object类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p>
<p>如果一个类没有特别指定父类，    那么默认则继承自Object类。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> /*<span class="keyword">extends</span> <span class="title">Object</span>*/ </span>&#123;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：</p>
<ul>
<li><code>public String toString()</code>：返回该对象的字符串表示。</li>
<li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li>
</ul>
<h2 id="1-2-toString方法"><a href="#1-2-toString方法" class="headerlink" title="1.2 toString方法"></a>1.2 toString方法</h2><h3 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul>
<li><code>public String toString()</code>：返回该对象的字符串表示。</li>
</ul>
<p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p>
<p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p>
<h3 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h3><p>如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> + <span class="string">"name='"</span> + name + <span class="string">'\''</span> + <span class="string">", age="</span> + age + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略构造器与Getter Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在IntelliJ IDEA中，可以点击<code>Code</code>菜单中的<code>Generate...</code>，也可以使用快捷键<code>alt+insert</code>，点击<code>toString()</code>选项。选择需要包含的成员变量并确定。如下图所示：</p>
<blockquote>
<p>小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。</p>
</blockquote>
<h2 id="1-3-equals方法"><a href="#1-3-equals方法" class="headerlink" title="1.3 equals方法"></a>1.3 equals方法</h2><h3 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul>
<li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li>
</ul>
<p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p>
<h3 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h3><p>如果没有覆盖重写equals方法，那么Object类中默认进行<code>==</code>运算符的对象地址比较，只要不是同一个对象，结果必然为false。</p>
<h3 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h3><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果对象地址一样，则认为相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果参数为空，或者类型信息不一样，则认为不同</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 转换为当前类型</span></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span></span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用<code>Code</code>菜单中的<code>Generate…</code>选项，也可以使用快捷键<code>alt+insert</code>，并选择<code>equals() and hashCode()</code>进行自动代码生成。</p>
<blockquote>
<p>tips：Object类当中的hashCode等其他方法，今后学习。</p>
</blockquote>
<h2 id="1-4-Objects类"><a href="#1-4-Objects类" class="headerlink" title="1.4 Objects类"></a>1.4 Objects类</h2><p>在刚才IDEA自动重写equals代码中，使用到了<code>java.util.Objects</code>类，那么这个类是什么呢？</p>
<p>在<strong>JDK7</strong>添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</p>
<p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p>
<ul>
<li><code>public static boolean equals(Object a, Object b)</code>:判断两个对象是否相等。</li>
</ul>
<p>我们可以查看一下源码，学习一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第二章-日期时间类"><a href="#第二章-日期时间类" class="headerlink" title="第二章 日期时间类"></a>第二章 日期时间类</h1><h2 id="2-1-Date类"><a href="#2-1-Date类" class="headerlink" title="2.1 Date类"></a>2.1 Date类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>java.util.Date</code>类 表示特定的瞬间，精确到毫秒。</p>
<p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。</p>
<ul>
<li><code>public Date()</code>：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li>
<li><code>public Date(long date)</code>：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</li>
</ul>
<blockquote>
<p>tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。</p>
</blockquote>
<p>简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Date</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建日期对象，把当前的时间</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date()); <span class="comment">// Tue Jan 16 14:37:35 CST 2018</span></span><br><span class="line">        <span class="comment">// 创建日期对象，把当前的毫秒值转成日期对象</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date(<span class="number">0L</span>)); <span class="comment">// Thu Jan 01 08:00:00 CST 1970</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。</p>
</blockquote>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>Date类中的多数方法已经过时，常用的方法有：</p>
<ul>
<li><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</li>
</ul>
<h2 id="2-2-DateFormat类"><a href="#2-2-DateFormat类" class="headerlink" title="2.2 DateFormat类"></a>2.2 DateFormat类</h2><p><code>java.text.DateFormat</code> 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。</p>
<ul>
<li><strong>格式化</strong>：按照指定的格式，从Date对象转换为String对象。</li>
<li><strong>解析</strong>：按照指定的格式，从String对象转换为Date对象。</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>由于DateFormat为抽象类，不能直接使用，所以需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：</p>
<ul>
<li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li>
</ul>
<p>参数pattern是一个字符串，代表日期时间的自定义格式。</p>
<h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><p>常用的格式规则为：</p>
<table>
<thead>
<tr>
<th>标识字母（区分大小写）</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>时</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody></table>
<blockquote>
<p>备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。</p>
</blockquote>
<p>创建SimpleDateFormat对象的代码如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02SimpleDateFormat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对应的日期格式如：2018-01-16 15:06:38</span></span><br><span class="line">        DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>DateFormat类的常用方法有：</p>
<ul>
<li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li>
<li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li>
</ul>
<h4 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h4><p>使用format方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 把Date对象转换成String</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03DateFormatMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">// 创建日期格式化对象,在获取格式化对象时可以指定风格</span></span><br><span class="line">        DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日"</span>);</span><br><span class="line">        String str = df.format(date);</span><br><span class="line">        System.out.println(str); <span class="comment">// 2008年1月23日</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a>parse方法</h4><p>使用parse方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 把String转换成Date对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04DateFormatMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日"</span>);</span><br><span class="line">        String str = <span class="string">"2018年12月11日"</span>;</span><br><span class="line">        Date date = df.parse(str);</span><br><span class="line">        System.out.println(date); <span class="comment">// Tue Dec 11 00:00:00 CST 2018</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-练习"><a href="#2-3-练习" class="headerlink" title="2.3 练习"></a>2.3 练习</h2><p>请使用日期时间相关的API，计算出一个人已经出生了多少天。</p>
<p><strong>思路：</strong></p>
<p>1.获取当前时间对应的毫秒值</p>
<p>2.获取自己出生日期对应的毫秒值</p>
<p>3.两个时间相减（当前时间– 出生日期）</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"请输入出生日期 格式 YYYY-MM-dd"</span>);</span><br><span class="line">	<span class="comment">// 获取出生日期,键盘输入</span></span><br><span class="line">	String birthdayString = <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line">	<span class="comment">// 将字符串日期,转成Date对象</span></span><br><span class="line">	<span class="comment">// 创建SimpleDateFormat对象,写日期模式</span></span><br><span class="line">	SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">	<span class="comment">// 调用方法parse,字符串转成日期对象</span></span><br><span class="line">	Date birthdayDate = sdf.parse(birthdayString);	</span><br><span class="line">	<span class="comment">// 获取今天的日期对象</span></span><br><span class="line">	Date todayDate = <span class="keyword">new</span> Date();	</span><br><span class="line">	<span class="comment">// 将两个日期转成毫秒值,Date类的方法getTime</span></span><br><span class="line">	<span class="keyword">long</span> birthdaySecond = birthdayDate.getTime();</span><br><span class="line">	<span class="keyword">long</span> todaySecond = todayDate.getTime();</span><br><span class="line">	<span class="keyword">long</span> secone = todaySecond-birthdaySecond;	</span><br><span class="line">	<span class="keyword">if</span> (secone &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		System.out.println(<span class="string">"还没出生呢"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.println(secone/<span class="number">1000</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-Calendar类"><a href="#2-4-Calendar类" class="headerlink" title="2.4 Calendar类"></a>2.4 Calendar类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>日历我们都见过</p>
<p><code>java.util.Calendar</code>是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p>
<h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：</p>
<p>Calendar静态方法</p>
<ul>
<li><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06CalendarInit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><p>根据Calendar类的API文档，常用方法有：</p>
<ul>
<li><code>public int get(int field)</code>：返回给定日历字段的值。</li>
<li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li>
<li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li>
<li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</li>
</ul>
<p>Calendar类中提供很多成员常量，代表给定的日历字段：</p>
<table>
<thead>
<tr>
<th>字段值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>年</td>
</tr>
<tr>
<td>MONTH</td>
<td>月（从0开始，可以+1使用）</td>
</tr>
<tr>
<td>DAY_OF_MONTH</td>
<td>月中的天（几号）</td>
</tr>
<tr>
<td>HOUR</td>
<td>时（12小时制）</td>
</tr>
<tr>
<td>HOUR_OF_DAY</td>
<td>时（24小时制）</td>
</tr>
<tr>
<td>MINUTE</td>
<td>分</td>
</tr>
<tr>
<td>SECOND</td>
<td>秒</td>
</tr>
<tr>
<td>DAY_OF_WEEK</td>
<td>周中的天（周几，周日为1，可以-1使用）</td>
</tr>
</tbody></table>
<h4 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get/set方法"></a>get/set方法</h4><p>get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Calendar对象</span></span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 设置年 </span></span><br><span class="line">        <span class="keyword">int</span> year = cal.get(Calendar.YEAR);</span><br><span class="line">        <span class="comment">// 设置月</span></span><br><span class="line">        <span class="keyword">int</span> month = cal.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 设置日</span></span><br><span class="line">        <span class="keyword">int</span> dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.print(year + <span class="string">"年"</span> + month + <span class="string">"月"</span> + dayOfMonth + <span class="string">"日"</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        cal.set(Calendar.YEAR, <span class="number">2020</span>);</span><br><span class="line">        System.out.print(year + <span class="string">"年"</span> + month + <span class="string">"月"</span> + dayOfMonth + <span class="string">"日"</span>); <span class="comment">// 2020年1月17日</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        System.out.print(year + <span class="string">"年"</span> + month + <span class="string">"月"</span> + dayOfMonth + <span class="string">"日"</span>); <span class="comment">// 2018年1月17日</span></span><br><span class="line">        <span class="comment">// 使用add方法</span></span><br><span class="line">        cal.add(Calendar.DAY_OF_MONTH, <span class="number">2</span>); <span class="comment">// 加2天</span></span><br><span class="line">        cal.add(Calendar.YEAR, -<span class="number">3</span>); <span class="comment">// 减3年</span></span><br><span class="line">        System.out.print(year + <span class="string">"年"</span> + month + <span class="string">"月"</span> + dayOfMonth + <span class="string">"日"</span>); <span class="comment">// 2015年1月18日; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getTime方法"><a href="#getTime方法" class="headerlink" title="getTime方法"></a>getTime方法</h4><p>Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        Date date = cal.getTime();</span><br><span class="line">        System.out.println(date); <span class="comment">// Tue Jan 16 16:03:09 CST 2018</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>​     西方星期的开始为周日，中国为周一。</p>
<p>​     在Calendar类中，月份的表示是以0-11代表1-12月。</p>
<p>​     日期是有大小关系的，时间靠后，时间越大。</p>
</blockquote>
<h1 id="第三章-System类"><a href="#第三章-System类" class="headerlink" title="第三章 System类"></a>第三章 System类</h1><p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：</p>
<ul>
<li><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。</li>
<li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li>
</ul>
<h2 id="3-1-currentTimeMillis方法"><a href="#3-1-currentTimeMillis方法" class="headerlink" title="3.1 currentTimeMillis方法"></a>3.1 currentTimeMillis方法</h2><p>实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       	<span class="comment">//获取当前时间毫秒值</span></span><br><span class="line">        System.out.println(System.currentTimeMillis()); <span class="comment">// 1516090531144</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>验证for循环打印数字1-9999所需要使用的时间（毫秒）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"共耗时毫秒："</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-arraycopy方法"><a href="#3-2-arraycopy方法" class="headerlink" title="3.2 arraycopy方法"></a>3.2 arraycopy方法</h2><ul>
<li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li>
</ul>
<p>数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：</p>
<table>
<thead>
<tr>
<th>参数序号</th>
<th>参数名称</th>
<th>参数类型</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>src</td>
<td>Object</td>
<td>源数组</td>
</tr>
<tr>
<td>2</td>
<td>srcPos</td>
<td>int</td>
<td>源数组索引起始位置</td>
</tr>
<tr>
<td>3</td>
<td>dest</td>
<td>Object</td>
<td>目标数组</td>
</tr>
<tr>
<td>4</td>
<td>destPos</td>
<td>int</td>
<td>目标数组索引起始位置</td>
</tr>
<tr>
<td>5</td>
<td>length</td>
<td>int</td>
<td>复制元素个数</td>
</tr>
</tbody></table>
<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo11SystemArrayCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] src = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        System.arraycopy( src, <span class="number">0</span>, dest, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">/*代码运行后：两个数组中的元素发生了变化</span></span><br><span class="line"><span class="comment">         src数组元素[1,2,3,4,5]</span></span><br><span class="line"><span class="comment">         dest数组元素[1,2,3,9,10]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-StringBuilder类"><a href="#第四章-StringBuilder类" class="headerlink" title="第四章 StringBuilder类"></a>第四章 StringBuilder类</h1><h2 id="4-1-字符串拼接问题"><a href="#4-1-字符串拼接问题" class="headerlink" title="4.1 字符串拼接问题"></a>4.1 字符串拼接问题</h2><p>由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"Hello"</span>;</span><br><span class="line">        s += <span class="string">"World"</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。</p>
<p>根据这句话分析我们的代码，其实总共产生了三个字符串，即<code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>和<code>&quot;HelloWorld&quot;</code>。引用变量s首先指向<code>Hello</code>对象，最终指向拼接出来的新字符串对象，即<code>HelloWord</code> 。</p>
<p>由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用<code>java.lang.StringBuilder</code>类。</p>
<h2 id="4-2-StringBuilder概述"><a href="#4-2-StringBuilder概述" class="headerlink" title="4.2 StringBuilder概述"></a>4.2 StringBuilder概述</h2><p>查阅<code>java.lang.StringBuilder</code>的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p>
<p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p>
<p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)</p>
<p><img src="..%5Cimg%5C01_StringBuilder%E7%9A%84%E5%8E%9F%E7%90%86.bmp" alt="01-StringBuilder的原理"></p>
<h2 id="4-3-构造方法"><a href="#4-3-构造方法" class="headerlink" title="4.3 构造方法"></a>4.3 构造方法</h2><p>根据StringBuilder的API文档，常用构造方法有2个：</p>
<ul>
<li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li>
<li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        System.out.println(sb1); <span class="comment">// (空白)</span></span><br><span class="line">        <span class="comment">// 使用带参构造</span></span><br><span class="line">        StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(<span class="string">"itcast"</span>);</span><br><span class="line">        System.out.println(sb2); <span class="comment">// itcast</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-常用方法"><a href="#4-4-常用方法" class="headerlink" title="4.4 常用方法"></a>4.4 常用方法</h2><p>StringBuilder常用的方法有2个：</p>
<ul>
<li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li>
<li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li>
</ul>
<h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><p>append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02StringBuilder</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建对象</span></span><br><span class="line">		StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//public StringBuilder append(任意类型)</span></span><br><span class="line">		StringBuilder builder2 = builder.append(<span class="string">"hello"</span>);</span><br><span class="line">		<span class="comment">//对比一下</span></span><br><span class="line">		System.out.println(<span class="string">"builder:"</span>+builder);</span><br><span class="line">		System.out.println(<span class="string">"builder2:"</span>+builder2);</span><br><span class="line">		System.out.println(builder == builder2); <span class="comment">//true</span></span><br><span class="line">	    <span class="comment">// 可以添加 任何类型</span></span><br><span class="line">		builder.append(<span class="string">"hello"</span>);</span><br><span class="line">		builder.append(<span class="string">"world"</span>);</span><br><span class="line">		builder.append(<span class="keyword">true</span>);</span><br><span class="line">		builder.append(<span class="number">100</span>);</span><br><span class="line">		<span class="comment">// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。</span></span><br><span class="line">        <span class="comment">// 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下</span></span><br><span class="line">		<span class="comment">//链式编程</span></span><br><span class="line">		builder.append(<span class="string">"hello"</span>).append(<span class="string">"world"</span>).append(<span class="keyword">true</span>).append(<span class="number">100</span>);</span><br><span class="line">		System.out.println(<span class="string">"builder:"</span>+builder);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：StringBuilder已经覆盖重写了Object当中的toString方法。</p>
</blockquote>
<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo16StringBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 链式创建</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Hello"</span>).append(<span class="string">"World"</span>).append(<span class="string">"Java"</span>);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        String str = sb.toString();</span><br><span class="line">        System.out.println(str); <span class="comment">// HelloWorldJava</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第五章-包装类"><a href="#第五章-包装类" class="headerlink" title="第五章 包装类"></a>第五章 包装类</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应的包装类（位于java.lang包中）</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h2 id="5-2-装箱与拆箱"><a href="#5-2-装箱与拆箱" class="headerlink" title="5.2 装箱与拆箱"></a>5.2 装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p>
<ul>
<li><p><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</p>
</li>
<li><p><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</p>
</li>
</ul>
<p>用Integer与 int为例：（看懂代码即可）</p>
<p>基本数值—-&gt;包装对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">4</span>);<span class="comment">//使用构造函数函数</span></span><br><span class="line">Integer iii = Integer.valueOf(<span class="number">4</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br></pre></td></tr></table></figure>

<p>包装对象—-&gt;基本数值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = i.intValue();</span><br></pre></td></tr></table></figure>
<h2 id="5-3自动装箱与自动拆箱"><a href="#5-3自动装箱与自动拆箱" class="headerlink" title="5.3自动装箱与自动拆箱"></a>5.3自动装箱与自动拆箱</h2><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span></span><br><span class="line"><span class="comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure>

<h2 id="5-3-基本类型与字符串之间的转换"><a href="#5-3-基本类型与字符串之间的转换" class="headerlink" title="5.3 基本类型与字符串之间的转换"></a>5.3 基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><p>   基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基本类型直接与””相连接即可；如：34+&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>String转换成对应的基本类型 </p>
<p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p>
<ul>
<li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li>
<li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li>
<li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li>
<li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li>
<li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li>
<li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li>
<li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li>
</ul>
<p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo18WrapperParse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(<span class="string">"100"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p>
</blockquote>
]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/2020/04/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="我的博客编写"><a href="#我的博客编写" class="headerlink" title="我的博客编写"></a>我的博客编写</h1><a id="more"></a>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用标题时需要#</p>
<h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>这是第一段<br>这是第二段</p>
<h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><p>这是一段引用</p>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="https://www.baidu.com/?tn=44004473_17_oem_dg&ctsutp8=14" target="_blank" rel="noopener">百度</a>  </p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="https://dss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3778173668,1422088699&fm=26&gp=0.jpg" alt="风景"> </p>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul>
<li>无序列表  </li>
<li>无序列表  </li>
</ul>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>1.有序1<br>2.尤须2  </p>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
